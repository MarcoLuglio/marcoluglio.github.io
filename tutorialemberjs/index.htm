<!DOCTYPE html>
<html
	xmlns="http://www.w3.org/1999/xhtml"
	lang="pt-BR"
	xml:lang="pt-br"
	>
<head>
	<title>JavaScript Orientado à Objeto</title>
	<meta charset="utf-8" />
	<style type="text/css">
	@font-face {
		font-family: 'Code';
		src: url('fontes/code_light.eot');
		src: url('fontes/code_light.eot?#iefix') format('embedded-opentype'),
			 url('fontes/code_light.woff') format('woff'),
			 url('fontes/code_light.ttf') format('truetype');
		font-weight: normal;
		font-style: normal;
	}

	@font-face {
		font-family: 'Code';
		src: url('fontes/code_bold.eot');
		src: url('fontes/code_bold.eot?#iefix') format('embedded-opentype'),
			 url('fontes/code_bold.woff') format('woff'),
			 url('fontes/code_bold.ttf') format('truetype');
		font-weight: bold;
		font-style: normal;
	}

	html * {
		margin: 0;
		padding: 0;
	}

	body {
		font-family: Arial, Helvetica, sans-serif;
		font-size: 14px;
		line-height: 22px;
		padding: 20px;
	}

	h1 {
		margin-bottom: 20px;
	}

	h2 {
		font-family: Code, Arial, Helvetica, sans-serif;
		font-size: 45px;
		line-height: 50px;
		margin-top: 85px;
		margin-bottom: 45px;
	}

	h2 span {
		font-size: 25px;
		display: block;
	}

	p {
		margin-bottom: 20px;
	}

	ul,
	ol {
		margin-left: 15px;
		margin-top: 10px;
		margin-bottom: 10px;
	}

	blockquote {
		font-size: 13px;
		margin: 20px;
	}

	code {
		font-family: Consolas, Menlo, "Courier New", Courier;
		white-space: pre;
		color: #666666; /* em homenagem à Mari */
		background-color: #EEEEEE;
	}

	code strong,
	code strong * {
		color: #FF0000 !important;
	}

	div code {
		display: block;
		padding: 25px;
		margin-top: 25px;
		margin-bottom: 25px;
	}

	.javascript .palavraReservada {
		color: #004499;
	}

	.javascript .string {
		color: #0099FF;
	}

	.javascript .comentario,
	.html .comentario {
		color: #FF6600;
	}

	.html .tag {
		color: #004499;
	}
	</style>
	<script>
		(function() {
			"use strict";



			function documentReady(funcao) {

				if (document.readyState === "interactive"
					|| document.readyState === "complete"
					|| document.readyState === "loaded"
					) {

					funcao(null);

				// se não, se registra para executar no evento
				} else {

					// registro do evento para navegadores legais
					if (document.addEventListener) {
						document.addEventListener('DOMContentLoaded', funcao);

					// registro de evento para IE8-
					} else if (window.attachEvent) {
						window.attachEvent('onload', funcao);
					}

				}


			}



			var indice = {


				init: function() {
					Object.seal(this);
				},


				gerar: function(idConteiner, niveis, mostrarPrimeiroNivel) {

					var conteiner = document.getElementById(idConteiner);
					var seletorTitulos = '';
					var titulos = null;
					var i = 0;
					var j = 0;
					var lista = document.createElement('ul');
					var listaBuffer = '';

					var pilhaNiveis = [];
					var nivelAtual = 0;
					var nivelAnterior = 0;
					var subnivelAtual = 0;
					var subnivelAnterior = 0;
					var indiceString = '';

					i = 2;
					if (mostrarPrimeiroNivel) {
						i = 1;
					}

					for (i; i <= niveis; i++) {
						seletorTitulos += ', h' + i;
					}
					seletorTitulos = seletorTitulos.substr(2);

					titulos = document.querySelectorAll(seletorTitulos);

					for (i = 0; i < titulos.length; i++) {

						nivelAnterior = nivelAtual;
						nivelAtual = this.getNivel(titulos.item(i));

						pilhaNiveis[nivelAtual] = pilhaNiveis[nivelAtual] || 0;

						if (nivelAtual <= nivelAnterior) {
							listaBuffer += '</li>';
						}

						//anterior h2, atual h1 por exemplo
						if (nivelAtual < nivelAnterior) {
							listaBuffer += '</ul>';
							pilhaNiveis[nivelAnterior] = 0;
						}

						//anterior h1, atual h2 por exemplo
						if (nivelAtual > nivelAnterior) {
							listaBuffer += '<ul>';
						}

						pilhaNiveis[nivelAtual]++;

						indiceString = 'indice';
						j = 2;
						if (mostrarPrimeiroNivel) {
							j = 1;
						}
						for (j; j < pilhaNiveis.length; j++) {
							// + nivelAtual + '-' + pilhaNiveis[nivelAtual];
							indiceString += '-' + j + pilhaNiveis[j];
						}
						titulos.item(i).id = indiceString;
						listaBuffer += '<li><a href="#' + indiceString + '">' + titulos.item(i).innerHTML + '</a>';

					}

					listaBuffer += '</li></ul>';

					lista.innerHTML = listaBuffer;

					conteiner.appendChild(lista);

				},


				getNivel: function(titulo) {
					var nivelString = titulo.tagName.substr(1);
					var nivel = parseInt(nivelString, 10);
					return nivel;
				}


			};



			var realcador = Object.create(Object.prototype, {


				init: {
					value: function() {
						Object.seal(this);
					},
					writable: false
				},


				realcar: {
					value: function(input) {
						//
					},
					writable: false
				},


				splice: {
					value: function(indice, quantoRemover, oQueInserir) {
						var input = this.output.toString();
						this.output = input.substring(0, indice);
						this.output += oQueInserir;
						this.output += input.substring(indice + quantoRemover);
					},
					writable: false
				},


				verificarIndices: {
					value: function(indiceA, indiceB) {
						var indicesDisponiveis = this.procurarIndicesDisponiveis(indiceA, indiceB);
						if (indicesDisponiveis[0] > -1 || indicesDisponiveis[1] > -1) {
							return true;
						}
						return false;
					},
					writable: false
				},


				/**
				 * Salva as faixas de indices que não devem mais ser realçadas
				 *
				 * @param indiceA
				 * @param indiceB
				 * @param offset Deslocamento a ser aplicado aos indices posteriores à inserção deste indice
				 */
				bloquearIndices: {

					value: function(indiceA, indiceB, inicioRealce, fimRealce) {
						var indicesDisponiveis = this.procurarIndicesDisponiveis(indiceA, indiceB);
						this.indiceRealces[0].splice(indicesDisponiveis[0], 0, indiceA, indiceB);
						this.indiceRealces[1].splice(indicesDisponiveis[0], 0, inicioRealce, fimRealce);
					},

					writable: false

				},


				procurarIndicesDisponiveis: {

					value: function(indiceA, indiceB) {

						var indices = [-1, -1];
						var i = 0;
						var indice = 0;
						var ultimoIndice = 0;
						var penultimoIndice = 0;

						//se é o primeiro bloqueio
						if (this.indiceRealces[0].length === 0) {
							return [0, 0];
						}

						//se estou bloqueando indices maiores do que os já bloqueados
						if (indiceA > this.indiceRealces[0][this.indiceRealces[0].length - 1]) {
							return [this.indiceRealces[0].length, this.indiceRealces[0].length];
						}

						for (i = 0; i < this.indiceRealces[0].length; i = i + 2) {
							indice = this.indiceRealces[0][i + 1];
							if (indice < indiceA) {
								ultimoIndice = indice;
								penultimoIndice = this.indiceRealces[0][i];
							} else {
								if (this.indiceRealces[0][i] > indiceB) {
									indices[0] = i;
									indices[1] = i + 1;
								}
								break;
							}
							//colocar 4,5
							//colocar 3,4
							//2,3  6,7
						}

						return indices;

					},

					writable: false

				},


				efetuarRealces: {

					/**
					 * Substitui os realces indexados
					 */
					value: function() {
						var i = 0;
						//a substituição é feita de trás para frente para que não seja necessário recalcular os índices em cada substituição
						for (i = this.indiceRealces[0].length - 1; i > 0; i = i - 2) {
							this.splice(this.indiceRealces[0][i] + 1, 0, this.indiceRealces[1][i]);
							this.splice(this.indiceRealces[0][i - 1], 0, this.indiceRealces[1][i - 1]);
						}
					},

					writable: false

				},


				output: {
					value: '',
					writable: true
				},


				indiceRealces: {
					value: [[], []],
					writable: true
				},


				indiceA: {
					value: 0,
					writable: true
				},


				indiceB: {
					value: 0,
					writable: true
				}


			});



			var realcadorJavaScript = Object.create(realcador, {


				realcar: {

					value: function(input) {

						this.indiceRealces = [[], []];
						this.output = input;

						this.indexarRealceComentarios(0);//TODO realçar blocos de comentários
						this.indexarRealceStrings(0);

						var palavrasChave = 'var |function|new|this|for |do |while |continue|if |else |switch|case|break|try |catch |return|true|false|null|undefined|delete|typeof|import |export '.split('|');
						for (var i = 0; i < palavrasChave.length; i++) {
							this.indexarRealcePalavrasChave(0, palavrasChave[i]);
						}

						this.efetuarRealces();

						return this.output;

					},

					writable: false

				},


				indexarRealceStrings: {

					value: function(indice) {

						this.indiceA = -1;
						this.indiceB = -1;

						this.indiceA = this.output.indexOf("'", indice);
						this.indiceB = this.output.indexOf('"', indice);

						if (this.indiceA === -1
							&& this.indiceB === -1
							) {

							return;
						}

						if (this.indiceB === -1
							|| (this.indiceA !== -1 && this.indiceA < this.indiceB)
							) {

							this.indiceB = this.output.indexOf("'", this.indiceA + 1);

						} else if (this.indiceA === -1
							|| this.indiceB < this.indiceA
							) {

							this.indiceA = this.indiceB;
							this.indiceB = this.output.indexOf('"', this.indiceA + 1);
						}

						if (!this.verificarIndices(this.indiceA, this.indiceB)) {
							return
						}

						this.bloquearIndices(this.indiceA, this.indiceB, '<span class="string">', '</span>');

						this.indexarRealceStrings(this.indiceB + 1);

					},

					writable: false

				},


				indexarRealceComentarios: {

					value: function(indice) {

						this.indiceA = -1;
						this.indiceB = -1;

						this.indiceA = this.output.indexOf('//', indice);

						if (this.indiceA === -1) {
							return;
						}

						this.indiceB = this.output.indexOf('\n', this.indiceA + '//'.length);

						if (this.indiceB === -1) {
							this.indiceB = this.output.length - 1;
						}

						if (!this.verificarIndices(this.indiceA, this.indiceB)) {
							return
						}

						this.bloquearIndices(this.indiceA, this.indiceB, '<span class="comentario">', '</span>');

						this.indexarRealceComentarios(this.indiceB + 1);

					},

					writable: false


				},


				indexarRealcePalavrasChave: {

					value: function(indice, palavra) {

						this.indiceA = -1;
						this.indiceB = -1;

						this.indiceA = this.output.indexOf(palavra, indice);

						if (this.indiceA === -1) {
							return;
						}

						this.indiceB = this.indiceA + palavra.length - 1

						if (!this.verificarIndices(this.indiceA, this.indiceB)) {
							return
						}

						this.bloquearIndices(this.indiceA, this.indiceB, '<span class="palavraReservada">', '</span>');

						this.indexarRealcePalavrasChave(this.indiceB + 1, palavra);

					},

					writable: false

				}


			});



			var realcadorHtml = Object.create(realcador, {


				realcar: {

					value: function(input) {

						this.indiceRealces = [[], []];
						this.output = input;

						this.indexarRealceComentarios(0);
						this.indexarRealceTags(0);
						this.efetuarRealces();
						//this.indexarRealceAtributos();

						return this.output

					},

					writable: false

				},


				indexarRealceComentarios: {

					value: function(indice) {

						this.indiceA = -1;
						this.indiceB = -1;

						this.indiceA = this.output.indexOf('&lt;!--', indice);

						if (this.indiceA === -1) {
							return;
						}

						this.indiceB = this.output.indexOf('--&gt;', this.indiceA + '&lt;!--'.length);

						if (this.indiceB === -1) {
							this.indiceB = this.output.length - 1;
						} else {
							this.indiceB += '--&gt'.length;
						}

						if (!this.verificarIndices(this.indiceA, this.indiceB)) {
							return
						}

						this.bloquearIndices(this.indiceA, this.indiceB, '<span class="comentario">', '</span>');

						this.indexarRealceComentarios(this.indiceB + 1);

					},

					writable: false


				},


				indexarRealceTags: {

					value: function(indice) {

						this.indiceA = -1;
						this.indiceB = -1;

						this.indiceA = this.output.indexOf('&lt;', indice);

						if (this.indiceA === -1) {
							return;
						}

						//TODO verificar se não são comentários

						this.indiceB = this.output.indexOf('&gt;', this.indiceA + '&lt;'.length);

						if (this.indiceB === -1) {
							this.indiceB = this.output.length - 1;
						} else {
							this.indiceB += '&gt'.length;
						}

						if (!this.verificarIndices(this.indiceA, this.indiceB)) {
							return
						}

						this.indexarRealceAtributos(this.indiceA, this.indiceB);

						this.bloquearIndices(this.indiceA, this.indiceB, '<span class="tag">', '</span>');

						this.indexarRealceTags(this.indiceB + 1);

					},

					writable: false


				},


				indexarRealceAtributos: {

					value: function() {

						//TODO
						//aumentar o this.indiceB e o this.offsetRealce

					},

					writable: false

				}


			});



			var realcadorC = Object.create(realcador);



			var realceSintaxe = {


				init: function() {
					Object.seal(this);
				},


				realcar: function() {

					var blocosDeCodigo = document.querySelectorAll('code');
					var i = 0;

					for (i = 0; i < blocosDeCodigo.length; i++) {
						if (blocosDeCodigo.item(i).className === 'javascript') {//TODO melhorar essa verificação
							blocosDeCodigo.item(i).innerHTML = this.processadores[1][0].realcar(blocosDeCodigo.item(i).innerHTML);
						} else if (blocosDeCodigo.item(i).className === 'html') {
							blocosDeCodigo.item(i).innerHTML = this.processadores[1][1].realcar(blocosDeCodigo.item(i).innerHTML);
						} else if (blocosDeCodigo.item(i).className === 'c') {
							//blocosDeCodigo.item(i).innerHTML = this.processadores[1][1].realcar(blocosDeCodigo.item(i).innerHTML);
						} else {
							//console.log(blocosDeCodigo.item(i).className);
						}

					}

				},


				processadores: [
					[
						'javascript',
						'html',
						'c'
					], [
						realcadorJavaScript,
						realcadorHtml,
						realcadorC
					]
				]


			};



			documentReady(function(evento) {
				try {
					indice.init();
					indice.gerar('indice', 3, false);
					realceSintaxe.init();
					realceSintaxe.realcar();
				} catch (erro) {
					console.error('Erro ao iniciar a página. ' + erro + '\n' + erro.stack);
				}
			});



		})();
	</script>
</head>
<body>

<h1>Ember App Kit antes que vc afunde</h1>
<!--<p>Bem-vindo ao tutorial de JavaScript orientado à objeto, politicamente incorreto.</p>-->


<section>

<h2>Índice</h2>
<nav id="indice">
</nav>

</section>



<section>

<h2>Intro</h2>

<p>Ember parece de longe com XAML da Microsoft. Ember não parece nada com HTML + JavaScript. De fato, Ember é uma <strong>camada de abstração tão grossa</strong> que dificilmente você irá usar qualquer método JavaScript nativo, ou jQuery. Portanto, se vc já mexeu um pouquinho que seja com XAML, vai ter mais facilidade do que se for um expert em HTML e JavaScript.</p>

<p>Se você está muito <strong>ansioso</strong> pra fazer qualquer coisa com Ember e mal pode esperar pra escrever uma linha de código, <strong>melhor não começar pelo App Kit</strong>, e sim pelo Starter Kit, que não precisa de nenhuma configuração ou ferramentas extras para funcionar. Pode ir lá, eu espero ;)<p/>

<p>Wow, isso foi rápido. Bom, agora que você brincou um pouco com o Starter Kit e resolver usar o App Kit, baixe o arquivo em <a href="http://iamstef.net/ember-app-kit">http://iamstef.net/ember-app-kit</a> e descompacte-o. Dentro do diretório do kit você vai ter que rodar alguns comandos <code>brew</code> ou <code>apt-get</code> + <code>npm</code>, <code>bower</code> e <code>grunt</code> conforme a documentação indica.<p/>

```
ALERTA DE PROXY EM UNIX LIKE OS
Caso você esteja usando um proxy para acessar a internet, note que
alguns estes comandos dependem de uma configuração individual,
indepentende da configuração do bash. Devemos configurar um proxy
para o <em>npm</em> e <em>git</em>, do qual o <em>npm</em>em depende.
```

<p>Só depois disso vamos conseguir acessar nosso app pelo navegador, através do comando <code>sudo grunt server</code>. Apenas descompactar o app kit não é suficiente. Mais sobre isso posteriormente.</p>

<p>Como estrutura de nosso app, temos um diretório com pastas e arquivos que o grunt usa, e dentro dele um diretório chamado <em>app</em>, onde vamos efetivamente trabalhar.</p>


<p>No Ember, temos basicamente os seguintes tipos de objetos principais:</p>

<ul>
	<li>a aplicação</li>
	<li>ember objects</li>
	<li>promises</li>
	<li>routes</li>
	<li>models
		<ul>
			<li>adapters</li>
			<li>serializers</li>
		</ul>
	</li>
	<li>controllers</li>
	<li>views</li>
</ul>

<p>Sim, é bastante coisa. Ember possui uma curva de aprendizado bastante íngreme.</p>

</section>

<section>

<h2>A Aplicação</h2>

<p>No <strong>Ember normal</strong>, a aplicação funciona como um namespace onde definimos nossos objetos.</p>

<p>No <strong>Ember App Kit</strong> ela ñ é praticamente usada, pois o kit usa uma funcionalidade do ECMAScript 6 (ES6) chamada <strong>modules</strong> (note que é diferente de <em>models</em>). Essa funcionalidade permite declararmos cada objeto num arquivo separado, e num diretório específico dependendo do tipo.</p>

<p>O App Kit também utiliza grunt para validar, traduzir e combinar estes modulos (<em>transpilar</em> para ES5 na verdade). Isso é feito quando rodamos no terminal o comando <code>sudo grunt server</code>, dentro pasta de nosso kit, e é refeito automaticamente enquanto o grunt estiver rodando, toda a vez que criamos ou modificamos um arquivo dentro do diretório do app. Após rodarmos este comando, poderemos acessar nosso app pelo endereço <a href="http://0.0.0.0:8000">http://0.0.0.0:8000</a> ou o que for indicado no terminal.</p>

<p>Este é o motivo de não podermos acessar diretamente nosso app assim que descompactamos o kit. Dependemos do grunt realizar vários processos para gerar algo efetivamente executável no navegador.</p>



<h3>Nota sobre modules</h3>

<p>Cada tipo de objeto tem um <strong>diretório específico.</strong> Mais pra frente explico o que cada tipo faz com exemplos. Se vc ñ tem experiência com ember talvez seja melhor pular essa parte por enquanto e voltar quando ler sobre os tipos de objetos.</p>

<p>Os diretórios mais usados são:</p>

<ul>
	<li><strong>routes:</strong> /routes</li>
	<li><strong>models:</strong> /models</li>
	<li><strong>adapters:</strong> /adapters</li>
	<li><strong>serializers:</strong> /callers. brincadeira, se chama /serializers ;)</li>
	<li><strong>controllers:</strong> tchanananan surpresa! o diretório se chama /controllers</li>
</ul>

<p>No <strong>Ember normal</strong>, declararíamos um modelo e rota como abaixo. O código pode ou não ser incluso todo num mesmo arquivo.</p>

<div>
<code class="javascript"
>App.UsuarioAutenticado = DS.Model.extend({
	//propriedades aqui
});

App.IndexRoute = Ember.Route.extend({
	setupController: function(controller) {
		controller.set('title', "My App");
	},
	model: function() {
		return this.store.find('usuarioAutenticado');
	}
});</code>
</div>

<p>No <strong>Ember App Kit</strong>, fazemos <strong>obrigatoriamente em arquivos separados</strong>, com regras diferentes para nomeclatura.</p>

<p>No arquivo <strong>/models/usuario-autenticado.js</strong>:</p>

<div>
<code class="javascript"
>export default DS.Model.extend({
	//propriedades aqui
});</code>
</div>

<p>Ou então:</p>

<div>
<code class="javascript"
>var usuarioAutenticado = DS.Model.extend({
	//propriedades aqui
});

export default usuarioAutenticado;</code>
</div>

<p>E no arquivo <strong>/routes/index.js</strong></p>

<div>
<code class="javascript"
>import UsuarioAutenticado from 'appkit/models/usuario-autenticado';

export default Ember.Route.extend({
	setupController: function(controller) {
		controller.set('title', "My App");
	},
	model: function() {
		return this.store.find('usuarioAutenticado');
	}
});</code>
</div>

<p>Ou novamente a sintaxe alternativa:</p>

<div>
<code class="javascript"
>import UsuarioAutenticado from 'appkit/models/usuario-autenticado';

var indexRoute = Ember.Route.extend({
	setupController: function(controller) {
		controller.set('title', "My App");
	},
	model: function() {
		return this.store.find('usuarioAutenticado');
	}
});

export default indexRoute;</code>
</div>

<p>Note que devemos <strong>explicitamente exportar</strong> os objetos de dentro do arquivo, e <strong>importar os objetos que iremos usar.</strong> Se não fizermos isso, nossos arquivos não irão validar, levando nossa app a não ser <q>compilada</q> pelo grunt. O que nos leva à próxima nota.</p>

<h3>Nota sobre validação</h3>

<p>O App Kit usa <a href="http://www.jshint.com">JSHint</a> para validar seu código, e <strong>mostra as mensagens de erro de validacão na janela do terminal</strong> que você mandou rodar o grunt. Como dito anteriormente, precisamos importar explicitamente cada objeto que quisermos usar dentro de nosso arquivo. Se precisarmos utilizar um objeto que foi <strong>definido no espaço global</strong> (incluído numa tag <code>script</code> do index por exemplo), precisamos indicar isso ao JSHint, por meio de um comentário no topo de nosso módulo.</p>

<p>Por exemplo:</p>

<div>
<code class="javascript"
>/* global localStorage:false */
/* global ic.ajax:false */
/* global console:false */

import UsuarioAutenticado from 'appkit/models/usuario-autenticado';

export default Ember.Route.extend({
	//usar localStorage, ic.ajax e console aqui
});</code>
</div>

<p>Se utilizarmos frequentemente algum objeto, fica chato ter que declarar toda a vez em cada arquivo. Pra esses casos podemos editar um <strong>arquivo oculto</strong> do JSHint. O <em>.jshintrc</em>, que se encontra no diretório raiz de nossa aplicação.</p>

<p>Este arquivo é um <abbr title="JavaScript Object Notation">JSON</abbr>, no qual podemos incluir o seguinte trecho:</p>

<div>
<code class="json"
>{
	...
	"globals": {
		"$":false,
		"jQuery":false,
		"console":false
	}
	...
}</code>
</div>

<p>Neste exemplo indicamos para o JSHint que <code>jQuery</code> e <code>console</code> foram declarados no espaço global, e que ele não deve lançar erros se estes objetos forem usados sem serem importados para dentro dos módulos.</p>

</section>



<section>

<h2>Ember Objects</h2>

<p><strong>No Ember, você nunca</strong> irá utilizar os <strong>objetos nativos</strong> JavaScript, nem usar a <strong>herança nativa</strong>. Isso porque Ember utiliza o conceito de <em>databinding</em> (mais sobre isso adiante), que requer que os objetos possam ser <em>observados</em> quanto à mudanças em suas propriedades.</p>

<p>Portanto você deve sempre <strong>extender objetos do tipo</strong> <code>Ember.Object</code>, que são <strong>observáveis</strong>. Estes objetos devem ter suas propriedades acessadas e <strong>alteradas por meio dos métodos</strong> genéricos <code>get</code> e <code>set</code>. Isso se faz necessário para que o mecanismo de observação funcione.</p>

<div>
<code class="javascript"
>var meuObjeto = Ember.Object.extend({
	propriedade: '';
});

meuObject.set('propriedade', 'observe!');</code>
</div>

<p>Aqui temos um problema com Ember. Se <strong>acessarmos diretamente</strong> essas propriedades, não será disparado nenhum erro, porém, isso <strong>quebra o fluxo</strong> que o framework espera e pode causar problemas. Por exemplo:</p>

<div>
<code class="javascript"
><strong>//ERRADO!! NÃO COPIE ESSE EXEMPLO</strong>
var meuObjeto = Ember.Object.extend({
	propriedade: '';
});

meuObject.propriedade = 'maneira errada de especificar valor.';</code>
</div>

<p>Quando um objeto é observável, podemos executar ações quando alguma propriedade dele muda. Isso é fundamental para o conceito de <em>binding</em> que veremos mais adiante.</p>

<p>Os objetos do Ember possuem uma coisa chamada <strong>propriedades computadas</strong>. Novamente fazendo uma analogia com C#, estas propriedades funcionam como <strong>getters e setters implícitos</strong>. Outro problema com Ember é que, se estes getters e setters não forem definidos adequadamente, não lançarão exceções, mas apresentarão um comportamento inesperado.</p>

<p><strong>Em Ember, setters tem que retornar um valor!</strong></p>

<p>Um exemplo com propriedades computadas - apenas getter:</p>

<div>
<code class="javascript"
>//getter
export default DS.Model.extend({

	...

	_login: DS.attr('string'),

	login: function() {
		return this.get('_login');
	}.property('_login')

	...

});</code>
</div>

<p>Outro exemplo com getter e setter:</p>

<div>
<code class="javascript"
>//getter e setter
export default DS.Model.extend({

	...

	_login: DS.attr('string'),

	//Note que se o método não tiver as propriedades devidamente
	//declaradas (chave e valor), AO CONTRÁRIO DO FUNCIONAMENTO
	//nativo do javascript, ember não chamará corretamente
	//o método, embora não lance exceção
	//Note também que o setter deve retornar um valor, diferente
	//de todas as outras linguagens do mundo!
	login: function(chave, valor) {
		//setter
		//IMPORTANTE, deve sempre retornar um valor
		if (arguments.length > 1) {
			this.set('_login', valor);
		}
		//getter - sempre executa por causa do setter
		return this.get('_login');
	}.property('_login')

	...

});</code>
</div>

</section>



<section>

<h2>Promises</h2>

<p>Promise é uma funcionalidade que <strong>substitui alguns casos</strong> onde seria necessário utilizar <strong>eventos</strong>. Ela permite manter seu código mais linear, ao invés de quebrá-lo em <em>event handlers</em> e <em>callbacks</em>. Promises estão presente em linguagens como Java, C++ e C#, e será incluída na próxima versão do JavaScript. Chrome já tem suporte nativo e o Firefox terá na versão 29. Ember usa promises hoje através de uma biblioteca chamada RSVP.</p>

<p>Promises são como <strong>variáveis</strong> que terão seu valor especificado num <strong>momento futuro</strong>. Quando as promessas são realizadas, isto é, quando elas finalmente tem seu valor especificado, geralmente executamos algum código que dependa desse valor.</p>

<p>Básico de como usar promises:</p>

<div>
<code class="javascript"
>var valorFuturo = new RSVP.Promise(function(resolve, reject){
	//fazer alguma coisa assíncrona aqui
});

//continuar seu código normalmente aqui
return valorFuturo;</code>
</div>

<p>Mais detalhadamente:</p>

<div>
<code class="javascript"
>var valorFuturo = new RSVP.Promise(function(resolve, reject){

	//fazer o que precisar aqui pra objer o valor
	//por exemplo um processo demorado de maneira assíncrona, como uma chamada ajax
	var resposta = jQuery.ajax({...});

	resposta.then(function() {
		//quando obter o valor, chamar o método resolve
		resolve(resposta.responseText);
	});

	//ou, caso tenha havido falha ao obter o valor, chamar o método reject,
	//passando uma string como motivo da falha
	reject('Problema de proxy, como sempre...');

});

return valorFuturo;</code>
</div>

<p>Note que tudo isso é executado na thread da UI, e portanto todas as ações demoradas dentro da promise devem ser feitas de maneira assíncrona.</p>

<p>Promessas podem ser encadeadas:</p>

<div>
<code class="javascript"
>var valorFuturo = new RSVP.Promise(function(resolve, reject){
	//fazer algo assíncrono e chamar
	resolve(resposta);
}).then(function(valor) {
	//resto do meu código em sequência aqui
	//ou retornar mais uma promessa com código assíncrono
	//o valor é o que foi passdo no resolve da promessa
).then(function(valor) {
	 //mais um pedacinho aqui
},
function(motivo) {
	//e aqui se der erro, pegar o motivo passado no reject
});</code>
</div>

<p>Exemplo real numa rota:</p>

<div>
<code class="javascript"
>export default Ember.Route.extend({

	model: function() {

		//salva referência do this para possibilitar acesso a store dentro da promise
		var self = this;

		//"importa" o objeto promise
		var Promise = Ember.RSVP.Promise;

		//cria uam promessa que irá conter o usuário salvo ou um novo
		var usuarioAutenticado = new Promise(function(resolve, reject){

			//método assíncrono que tb devolve uma promessa
			var usuariosAutenticados = self.store.find('usuarioAutenticado');

			//por isso também posso encadear um then nela
			usuariosAutenticados.then(
				function(usuarios) {
					if (usuarios.get('length') > 0) {
						resolve(usuariosAutenticados.objectAt(0));
					} else {
						resolve(self.store.createRecord(
							'usuarioAutenticado',
							{
								login: '',
								senha: ''
							}
						));
					}
				},
				function(motivo) {
					//tratar erro
					console.log('erro ao buscar usuário no local storage');
					resolve(self.store.createRecord(
						'usuarioAutenticado',
						{
							login: '',
							senha: ''
						}
				));
				}
			);

		});

		//retorna imediatamente a promessa do usuário, seu valor será
		//especificado futuramente, quando a promessa do método find for cumprida
		return usuarioAutenticado;

	},

});</code>
</div>

</section>



<section>

<h2>Routes</h2>

<p>Esta é uma das partes que não existe dentro de programas feitos com <abbr>XAML</abbr>, e é relativa ao ambiente do navegador de internet.</p>

<p>Rotas são representações dos caminhos digitados na barra de endereços do navegador. Elas fornecem um *model* para seu *controller* respectivo, que por sua vez fornece dados para a *view* respectiva que é mostrada para a rota em questão.</p>

<p>Como Ember nunca muda de página, e portanto toda a sua aplicação roda no arquivo *index.htm*, Devemos digitar a **rota desejada após o #** da url (o nome técnico é fragmento da url).</p>

<p>Por exemplo:</p>

<ul>
* **http://0.0.0.0:8000** é a rota index
* **http://0.0.0.0:8000/#/index** também é a rota index
* **http://0.0.0.0:8000/#/noticias** é a rota de notícias
* **http://0.0.0.0:8000/#/noticias/38** é a rota da notícia com id 38
</ul>

<p>Para **criarmos uma rota** no Ember App Kit, primeiro registramos ela no arquivo */router.js*. Depois criamos um objeto dentro da pasta */routes* que extende `Ember.Route`. A rota *index* é implicita e não precisa ser declarada.</p>

<p>Dentre os métodos do objeto `Ember.Route`, 4 são bastante utilizados. São eles `beforeModel`, `model`, `afterModel`, e `actions.error`. Este último executa caso haja algum problema na requisição de dados para o modelo ou outras situações.</p>

<p>Dentre outras coisas, utilizamos estes métodos para **controle de acesso de permissões.** Fazemos isso criando uma rota que extende a rota nativa do Ember. Esta rota irá conter verificações de autenticação dentro destes métodos, e servirá de base para todas as demais rotas que criarmos.</p>

<p>O método `model` deve retornar um modelo, ou uma promessa para um modelo. Se você retornar uma **promessa, o Ember se vira sozinho** pra utilizar ela depois, quando ela se realizar.</p>

</section>



<section>

<h2>Models</h2>

<p>Usamos preferencialmente `Ember.Object` opcionalmente com `Promise` como modelo de nossos dados. Ou podemos utilizar um pedaço do Ember chamado **Ember Data**, que retorna estes tipos de objetos para nós, além de possuir outras funcionalidades.</p>

<p>Se optarmos por não utilizar Ember Data, construímos geralmente nossos modelos através de requisições ajax construídas manualmente e os retornamos para o *controller*.</p>

<p>Se utilizarmos Ember Data, precisamos aprender sobre mais 2 objetos. `DS.RESTAdapter` e `DS.RESTSerializer`. Mais sobre isso abaixo.</p>

<p>**Vale lembrar novamente** que em nosso modelo, toda a vez que alterarmos alguma propriedade, devemos fazer através do método genérico `set`, para que nossa view seja atualizada automaticamente através de *databinding*.</p>

<p>As arrays do Ember possuem um comportamento diferente de arrays nativas, pois seus elementos são <em>materializados</em> após a array ser construída. Portanto, se acessarmos os elementos diretamente usando o operador <code>[]</code>, <strong>corremos sério risco</strong> de obtermos um valor <code>null</code> para um índice que <strong>poderia conter um objeto válido.</strong> Para termos certeza que o elemento que desejamos já esteja materializado, devemos utilizar sempre os métodos <code>objectAt</code> e <code>forEach</code> das arrays Ember.</p>

<h3>Adapters</h3>

<p>Adapter é o que o Ember Data usa para saber <strong>aonde buscar os dados</strong> de um determinado tipo de objeto.</p>

<p>Podemos ter um <strong>adapter geral da aplicação, e adapters específicos para alguns tipos.</strong> No Ember App Kit, basta criar na pasta <em>/adapters</em> um adapter com o mesmo nome do modelo respectivo que está na pasta <em>/models</em>. O adapter com o nome <em>application.js</em> é o adapter geral da aplicação.</p>

<p>Por exemplo:</p>

<ul>
	<li><strong>modelo:</strong> /models/post-comment.js</li>
	<li><strong>adapter:</strong> /adapters/post-comment.js</li>
</ul>

<p>Os adapters que utilizam <strong>requisições ajax</strong> para obter os dados são do tipo <code>RESTAdapter</code>. Neles podemos especificar entre outras coisas, urls personalizadas.</p>

<p><code>RESTAdapter</code> requisita por padrão uma url no formato <em>/recurso/id</em>, e espera como resposta um objeto JSON. Se precisarmos de uma <strong>url personalizada</strong> como <em>/recurso/id/subrecurso</em> devemos extender o adapter, sobrescrevendo o método <code>buildURL</code>.</p>

<p>Por exemplo, para fazer uma requisição para <em>/usuario/id/perfil</em>:</p>

<div>
<code class="javascript"
>Ember.Inflector.inflector.uncountable('perfil');
//requisita /perfil ao invés de perfils/.
//Pra usar perfis tem que usar Ember.Inflector.inflector.irregular('perfil', 'perfis');

export default DS.RESTAdapter.extend({

	buildURL: function(type, id) {

		var url = [];
		var urlString = null;
		var host = this.host;
		var prefix = this.urlPrefix();

		if (prefix) {
			url.push(prefix);
		}
		if (id) {
			url.push(id);
		}
		if (type) {
			url.push(this.pathForType(type));
		}

		urlString = url.join('/');
		if (!host &amp;&amp; urlString) {
			urlString = '/' + urlString;
		}

		return urlString;

	},

	/**
	 * Caminho das requisições no host
	 */
	namespace: 'usuario',

	/**
	 * Host
	 */
	host: 'http://localhost/api'

});</code>
</div>




<h3>Serializers</h3>

<p>Serializer é o que o Ember Data usa para <strong>transformar <abbr title="JavaScript Object Notation">JSON</abbr></strong> em <code>Ember.Object</code>.</p>

<p>Assim, como no caso dos <em>adapters</em>, podemos ter <em>serializers</em> <strong>específicos para alguns tipos.</strong> No Ember App Kit, basta criar na pasta <em>/serializers</em> um serializer com o mesmo nome do modelo respectivo que está na pasta <em>/models</em>.</p>

<p>Por exemplo:</p>

<ul>
	<li><strong>modelo:</strong> /models/post-comment.js</li>
	<li><strong>serializer:</strong> /serializers/post-comment.js</li>
</ul>

<p>E em conjunto com um adapter:</p>

<ul>
	<li><strong>modelo:</strong> /models/post-comment.js</li>
	<li><strong>adapter:</strong> /adapters/post-comment.js</li>
	<li><strong>serializer:</strong> /serializers/post-comment.js</li>
</ul>

<p>Serializers que respondem a <strong>requisições ajax</strong> são do tipo <code>RESTSerializer</code>. Neles podemos transformar a resposta <abbr title="JavaScript Object Notation">JSON</abbr> para uma estrutura <strong>compatível com a que o Ember Data espera,</strong> sobrescrevendo o método <code>normalizePayload</code>.</p>

Por exemplo:

<div>
<code class="javascript"
>// transforma
// { "id": 1, "email": "ninguem@nada.com" }
// no formato ember data
// { "perfil": { "id": 1, "email": "ninguem@nada.com" } }
// note que temos que deletar as propriedades antigas, atribuir null não é suficiente

export default DS.RESTSerializer.extend({

	normalizePayload: function(type, payload) {

		payload.perfil = {
			id: payload.id,
			email: payload.email,
		};

		delete payload.id;
		delete payload.email;

		return payload;

	}

});</code>
</div>



<h3>A store</h3>

<p>Qualquer operação ou alteração que é feita nos modelos só é efetuada quando chamamos o método <code>save</code> neles. Inclusive a operação <code>delete</code>. Se vc achar muito estranho apagar e salvar o modelo, pode chamar o método <code>destroy</code>, que efetua a operação <code>delete</code> automaticamente.</p>

<div>
<code class="javascript"
>//isso é feito na memória, sem realizar nenhuma requisição
novoRegistro = self.store.createRecord(
	'registro',
	{
		'data': '',
		'texto': ''
	}
);
novoRegistro.set('data', new Date());
novoRegistro.set('texto', 'escrito agora!');

//só agora realiza efetivamente a requisição
novoRegistro.save();</code>
</div>



<h3>Cache</h3>

<p>A store faz cache das consultas. Para limparmos o cache usamos os métodos <code>store.unloadRecord</code> e <code>store.unloadAll</code>. Porém, não é possível descarregar da memória registros com alterações não salvas, nem o modelo carregado atualmente no controller aparentemente, pelo menos com o adapter de local storage.</p>

<p>Também podemos limpar as alterações do modelo utilizando o método <code>reload</code> do modelo.</p>

</section>



<section>

<h2>Controllers</h2>
<p>Possuem métodos dentro da propriedade <code>actions</code>, que são executados de acordo com o indicado nas <em>views</em>.</p>

</section>



<section>

<h2>Views</h2>

<p>São pedaçoes de html com uma sintaxe própria para declarar valores dinâmicos. Esses valores dinâmicos são *databound*, isto é, são atualizados automaticamente quando nosso modelo é modificado. Para tanto colocamos o nome da propriedade de nosso controller ou modelo entre chaves duplas.</p>

<p>Por exemplo:</p>

<div>
<code class="html"
>&lt;p&gt;index.htm - olá mundo&lt;/p&gt;
&lt;code class="html"
{{email}}
&lt;button type="button" {{action "mudar"}}&gt;Mudar&lt;/button&gt;
&lt;div {{bind-attr class="emAndamento"}}&gt;&lt;img src="indicador.gif" /&gt;&lt;/div&gt;</code
>
</div>


<h3>Onde colocar o CSS</h3>
<p>Na pasta <em>/styles</em></p>


<h3>Onde colocar as imagens</h3>
<p>Na pasta <em>/assets</em>, direto na raiz usada pelo grunt, fora da pasta app.</p>

</section>


</body>
</html>