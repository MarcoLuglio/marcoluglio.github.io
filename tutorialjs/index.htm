<!DOCTYPE html>
<html
	xmlns='http://www.w3.org/1999/xhtml'
	lang='pt-BR'
	xml:lang='pt-br'
	>
<head>
	<title>JavaScript Orientado à Objeto</title>
	<meta charset='utf-8' />
	<link rel='stylesheet' href='css/main.css' />
	<script type='module' src='../compartilhado/js/utils.js'></script>
	<script type='module' src='../compartilhado/js/index.js'></script>
	<script type='module' src='../compartilhado/js/highlighter.js'></script>
	<script type='module' src='../compartilhado/js/highlightEnhancer.js'></script>
	<script type='module' src='js/home.js'></script>
</head>
<body>



<h1>Tutorial JavaScript Orientado à Objeto</h1>
<p>Bem-vindo ao tutorial politicamente incorreto de JavaScript orientado à objeto.</p>


<section>

<h2>Índice</h2>
<nav id='indice'>
</nav>

</section>



<section>

<h2 id='historia'>A pressa passa e a merda fica <span>Introdução Histórica (e lição de vida)</span></h2>

<p>JavaScript foi criado e programado em 2 semanas pela Netscape para validar formulários dentro dos navegadores, sem a necessidade de recarregar a página. Aparentemente na época das conexões discadas medidas em BAUDS isso era muito importante (e com o 3G da tim tb ¬¬). Porém, este período curto para desenvolvimento da linguagem gerou um produto com diversas questões controversas. Seu nome foi puramente uma jogada de marketing, tentando se aproveitar da popularidade do Java, que na época era muito usado para fazer applets para páginas de internet. JavaScript teve várias versões após isso, sendo que a versão atual, padronizada como <abbr title='ECMAScript ou European Computer Manufacturers Association Script'>ES6</abbr>, é bastante diferente da inicial.</p>

<p>Por enquanto, ela é a única linguagem de programação capaz de interagir com todos os navegadores de internet. Existe uma <a rel='external nofollow' href='https://github.com/webassembly'>especificação em progresso</a> que criará um formato binário capaz de se comunicar com JavaScript, e que poderá ser criado por outras linguagens. Mas ainda levará algum tempo para vermos isso acontecer. JavaScript também pode ser utilizado para programação server side, através do <a rel='external nofollow' href='http://nodejs.org/'>Node.js</a>, mas não vou abordar isso por enquanto.</p>

<p>JavaScript já foi chamada de linguagem mais mal entendida do mundo. Grandes empresas como a Microsoft e o Google passaram bastante tempo desenvolvendo ferramentas para que não seja necessário escrever JavaScript. E o motivo de tudo isso... é que JavaScript é como espanhol.<p>

<blockquote>Hay um hombre <strong>tarado</strong> con el...</blockquote>
<p>Parece com português, mas significa uma coisa completamente diferente.</p>

<blockquote>Há um homem <strong>careca</strong> com o <strong>casaco</strong> na mão correndo atrás do <strong>ônibus.</strong></blockquote>

<p>PS: Essas palavras se chamam falsos cognatos.</p>

<p>A sintaxe do JavaScript parece com C e derivados, mas significa coisas diferentes. Por exemplo, <code class='javascript'>this</code> faz <a href='#oop'>coisas bem diferentes</a> dos seus equivalentes em C#. É um <q>falso cognato</q></p>

<p>Vou enfatizar justamente as diferenças ao longo desse tutorial. Mas antes cabe rapidamente rever um outro fato histórico, importante no desenvolvimento dessa linguagem.</p>

<p>A Netscape inicialmente não tinha intenção que a linguagem fosse padronizada ou aberta. Ela queria dominar o mercado, forçando as pessoas a fazerem páginas que só funcionavam no Netscape, e abriam zoadas no seu concorrente, o internet explorer. Esse episódio é conhecido como <a rel='external nofollow' href='http://en.wikipedia.org/wiki/Browser_wars'>Browser Wars</a>. O resultado disso foi uma grande divisão na linguagem, gerando incompatibilidades que temos que lidar até a versão 8 do Internet Explorer. Este foi o principal motivo do sucesso de bibliotecas com jQuery, que escondem estas incompatibilidades através de sua <abbr title='Application Programming Interface'>API</abbr>.</p>

<p>Como os smartphones já nasceram com navegadores posteriores ao <abbr title='Internet Explorer 8'>IE8</abbr>, sites e aplicativos para estes dispositivos não precisam se preocupar com isso.</p>

</section>



<section>

<h2 id='helloworld'>JavaScript un zero un <span>¡Hola Mundo!</span></h2>

<p>Sei que vc é um programador fodástico e que não precisa que ninguém te ensine nada de programação. Então não vou mostrar nada além do estritamente necessário para explicar as diferenças de JavaScript em comparação com C e derivados. Ok?</p>

<p>A linguagem em si não é muito grande se você tirar toda velharia que ainda existe por causa de compatibilidade. E se você precisa suportar uma outra velharia chamada IE, suas incompatibilidades nesse caso são poucas. <strong>Mas</strong>, existe uma API exposta pelos navegadores, comumente utilizada em conjunto com JavaScript, chamada Document Object Model (<abbr title='Document Object Model'>DOM</abbr>), que é bem <strong>maior e mais incompatível</strong>. Ele serve para que o JavaScript acesse os elementos de um arquivo html, xml ou <abbr title='Scalable Vector Graphics'>svg</abbr>. Mas vamos ver uma coisa de cada vez.</p>

<p>JavaScript pode existir dentro de um arquivo .js, .htm ou .svg</p>

<p>Arquivos .js contém apenas programação, ao passo que arquivos .htm e .svg misturam linguagens de marcação com JavaScript.
Podemos usar o bloco de notas para criar e editar um arquivo .js.</p>

<p>O firefox tem uma ferramentinha bem útil pra testarmos pequenos blocos de JavaScript, sem precisar usar um arquivo .js externo. Ela se chama scratchpad.</p>

<p>Para o próximo exemplo, vamos usar um arquivo .htm bem simples para fazer nossos testes. Copie o trecho abaixo no bloco de notas de sua preferência, e salve como um arquivo .htm</p>

<div class='codeblock'>
<p>index.htm - olá mundo</p>
<code class='html'
>&lt;!DOCTYPE html&gt;
&lt;html
	xmlns='http://www.w3.org/1999/xhtml'
	lang='pt-BR'
	xml:lang='pt-br'
	&gt;
&lt;head&gt;
	&lt;title&gt;Html mínimo aceitável&lt;/title&gt;
	&lt;meta charset='utf-8' /&gt;
	&lt;script src='tutorial.js'&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;</code
>
</div>

<p>PS: Html também tem versões, que fazem com que a página pareça e se comporte de maneira diferente de versão para versão. A primeira linha do arquivo:</p>

<div class='codeblock'>
<code class='html'
>&lt;!DOCTYPE html&gt;</code
>
</div>

<p>indica que estamos usando a <strong>versão 5</strong> do html.</p>

<p>Depois cole o texto abaixo num arquivo novo, e salve com a extensão .js. Salve na mesma pasta que o arquivo .htm
Note que os arquivos deste exemplo são salvos em utf-8.</p>

<div class='codeblock'>
<p>tutorial.js - olá mundo</p>
<code class='javascript'
>'use strict';

console.log('Utilizadores de alert terão seus dedos cortados fora.');</code
>
</div>

<p>Abra o arquivo .htm no seu navegador. Se vc fez tudo certo, observe atentamente que não vai acontecer absolutamente porra nenhuma. Porém, se for IE 10-, vai gerar um erro! Começamos bem hein! Disse que não ia mostrar nada além do estritamente necessário para explicar as diferenças de JavaScript. E o propósito desse exemplo é explicar algumas coisas sobre o ambiente de execução da linguagem e das ferramentas de desenvolvimento dos navegadores.</p>

<p>Pra ver o resultado de nossa programação precisamos abrir as ferramentas de desenvolvimento, que todos os navegadores possuem (o Firefox possui duas, uma nativa e uma em forma de extensão). Para abrir faça:</p>

<ul>
	<li>Chrome, Firefox (nativo), Opera e Safari: Ctrl + Shift + i</li>
	<li>Firefox (extensão firebug), Edge e IE: F12</li>
</ul>

<p>Procure por uma aba chamada console. <strong>É para o console que as mensagens de debug vão.</strong> Recarregue a página e você deverá ver nossa mensagem instrutiva, inclusive no IE. As ferramentas de desenvolvimento também possibilitam inserir breakpoints no meio do código e avançar linha por linha, como outras IDEs.</p>

<p>Vamos agora explicar nosso exemplo inicial linha por linha.</p>

<div class='codeblock'>
<code class='javascript'
>'use strict';</code
>
</div>

<p>A versão ES5 do JavaScript possui um modo, chamado <a rel='external nofollow' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode#Changes_in_strict_mode'>modo estrito</a>. Ao incluir <code class='javascript'>'use strict';</code> como a primeira linha do arquivo, você está habilitando este modo. Ele garante compatibilidade futura com novas versões da linguagem, além de reduzir as chances de introduzir erros na programação. Este modo pode ser <strong>habilitado para o arquivo inteiro, ou apenas para determinadas funções.</strong> Veremos esta <a href='#funcaoestrita'>segunda forma</a> mais adiante.</p>

<div class='codeblock'>
<code class='javascript'
>console.log('Utilizadores de alert terão seus dedos cortados fora.');</code
>
</div>

<p><code class='javascript'>console</code> é um objeto, mas não pertence à linguagem. Ele faz parte da API do navegador, o <abbr title='Document Object Model'>DOM</abbr>. Na prática isso significa que <strong>nem sempre ele está disponível para nós utilizarmos. Cada navegador expõe métodos diferentes deste objeto, e os interpreta de maneiras diversas.</strong> O método <code class='javascript'>log</code> existe em todos eles, e possui inúmeras vantagens sobre métodos anteriores de debug.</p>

<p>Note que <strong>não existe um método <code class='c'>main</code>.</strong> Uma página pode conter diversos blocos separados de JavaScript, portanto não existe o conceito do ponto único de entrada do seu código. Assim que o navegador identifica um trecho de código JavaScript, ele o interpreta e executa linha por linha (o que efetivamente acontece é um pouco mais sofisticado, mas vou deixar este assunto por aqui). Se o mesmo arquivo for inserido duas vezes, ele será executado duas vezes. Não existem <em>include guards</em> em JavaScript, como em C ou PHP.(<code class='c'>#ifndef</code> <code class='c'>#define</code> <code class='c'>#endif</code>, <code class='php'>include_once</code>...).</p>

<p>Em .net, existe algo similar em funcionalidade aos <em>include guards</em>. O método <code class='generic'><span class='symbol'>RegisterStartupScript</span></code>, recebe uma id ao registrar um script. Se for registrado um novo script com a mesma id, o script anterior é descartado.</p>

</section>



<section>

<h2 id='tipos'>Como declarar uma variável <span>Sério mesmo, como declarar uma variável!</span></h2>

<p><strong>Existem duas maneiras de declarar uma variável em JavaScript.</strong> A maneira mais antiga, que utiliza a palavra-chave <code class='javascript'>var</code>, e tem várias pegadinhas que veremos mais para frente. E a maneira mais nova, com a palavra-chave <code class='javascript'>let</code>, que se comporta de maneira mais similar à que estamos acostumados em outras linguagens. Existe também a possibilidade de declararmos constantes com <code class='javascript'>const</code>.</p>

<p>Declaramos uma constante com a palavra-chave <code class='javascript'>const</code>, seguida pelo nome da constante, e obrigatoriamente o sinal de igual e um valor a ser atribuído à constante.</p>

<div class='codeblock'>
<p>declaração de constantes</p>
<code class='javascript'
>'use strict';

const naoPodeMudar = 'o valor';
const vaiLancarErro; // é obrigatório atribuir o valor às constantes assim que as declaramos</code
>
</div>

<p>Declaramos uma variável com a palavra-chave <code class='javascript'>let</code> ou com <code class='javascript'>var</code>, seguidas do nome da variável. Opcionalmente atribuímos um valor para ela. Se não atribuirmos, ela terá o valor padrão <code class='javascript'>undefined</code>.</p>

<div class='codeblock'>
<p>declaração de variáveis</p>
<code class='javascript'
>'use strict';

let naoInicializada; // possui valor undefined
let dica = 'JavaScript não é "fortemente tipado"';

var naoInicializada2; // possui valor undefined
var dica2 = 'Use "let" ao invés de "var"';</code
>
</div>

<p>Não declaramos o tipo da variável, pois JavaScript não proíbe que o tipo dela mude (não é fortemente tipada). O tipo é <strong>inferido</strong> através do valor <strong>atualmente atribuído</strong> à variável. Note porém que se mantivermos o mesmo tipo da variável ao longo da execução de nosso código, o compilador consegue aplicar <strong>otimizações de performance.</strong> Se necessário, é possível verificar de <strong>maneira limitada</strong> o tipo da variável usando o operador <code class='javascript'>typeof</code> ou <strong>outros métodos</strong> como <code class='javascript'>Array.isArray</code>.</p>

<p>A lista completa dos <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference'>tipos das variáveis pode ser vista no <abbr title='Mozilla Developer Network'>MDN</abbr></a>, que é o portal de desenvolvimento da Mozilla. Vamos ver apenas os tipos que diferem de alguma maneira de seus primos em outras linguagens.</p>

<p>Note que podemos chamar métodos de instâncias através das literais como veremos em alguns exemplos.</p>


<h3 id='falsy'>Conversão de tipos e falsy values</h3>

<p>Além de não proibir que o tipo das variáveis mude ao longo da execução do código, <strong>JavaScript converte tipos automaticamente em <code class='javascript'>true</code> e <code class='javascript'>false</code> quando necessário.</strong> Isso nos proporciona uma sintaxe reduzida para verificar estes valores e a existência de variáveis.</p>

<p>Os valores que são convertidos para <code class='javascript'>false</code> são chamados de <em>falsy</em>. são eles <code class='javascript'>''</code> (string vazia), <code class='javascript'>0</code>, <code class='javascript'>null</code>, <code class='javascript'>undefined</code> e <abbr title='Not a Number'><code class='javascript'>NaN</code></abbr>. Todos os demais são convertidos para <code class='javascript'>true</code>.</p>

<div class='codeblock'>
<code class='javascript'
>var objeto = {};

// a verificação reduzida
if (objeto) {
	//
}

// equivale a verificação
if (objeto === true) {
	//
}

// e ainda à verificação
if (objeto !== false &amp;&amp; objeto !== '' &amp;&amp; objeto !== 0 &amp;&amp; objeto !== null &amp;&amp; objeto !== undefined &amp;&amp; objeto !== NaN) {
	//
}</code
>
</div>

<p>Note que <strong>existem dois comparadores de igualdade em JavaScript.</strong> <code class='javascript'>==</code> e <code class='javascript'>===</code>, assim como seus opostos <code class='javascript'>!=</code> e <code class='javascript'>!==</code>. A primeira forma converte automaticamente os tipos, enquanto que a outra não.</p>


<h3 id='null'>Null e nullable</h3>

<p>Como podemos possivelmente mudar livremente os tipos das varáveis que declaramos (embora não seja recomendado), <strong>não existe uma sintaxe especial para indicar que as variáveis podem ser <em>nullable</em>.</strong> Basta não atribuir valor nenhum, e nesse caso a variável terá o valor especial <code class='javascript'>undefined</code>. Ou atribuir o valor <code class='javascript'>null</code> a elas. Em algumas linguagens existe um <strong>operador específico para lidar com tipos nulos,</strong> chamado <em>null coalescing operator</em> (geralmente representado como <code class='generic'><span class='operator'>??</span></code> ou ainda uma forma abreviada do operador <code class='generic'><span class='operator'>?:</span></code>, também chamado de operador Elvis). <strong>Em JavaScript, quem faz as vezes desse operador é o OR lógico <code class='javascript'>||</code>.</strong></p>

<p>TODO mostrar em outras linguagens quando pode ser nullable</p>

<div class='codeblock'>
<p>tipos null com let</p>
<code class='javascript'
>'use strict';

let k; // undefined
let l = null; // null

// || funciona como null coalescing operator
// isso quer dizer que se k for undefined ou null, m recebe o valor 2 ao invés de k
// o mesmo vale para n, que recebe o valor 2 se l for undefined ou null

let m = k || 2; // 2
let n = l || 2; // 2

// existem outros valores que podem ser entendidos como null, como mencionei anteriormente no tópico falsy values

let o = '';
let p = o || 2; // 2, pois '' é falsy</code
>
</div>

<h4>Namespaces</h4>

<p>Essa funcionalidade, juntamente com <code class='javascript'>var</code>, costumava ser utilizada para <strong>simular namespaces,</strong> já que JavaScript não os possui nativamente. Note que atualmente a utilização de um <strong>padrão de módulos chamados <a hef='#amd'><abbr title='Asynchronous Module Definition'>AMD</abbr></a> é mais recomendada</strong> por motivos de uso de memória. Existe também uma <a href='http://www.ecma-international.org/ecma-262/6.0/#sec-imports' rel='external nofollow'>expecificação para criação de módulos</a> usando as palavras <code class='javascript'>import</code> e <code class='javascript'>export</code>, que ainda não foi implementada em nenhum navegador.</p>

<div class='codeblock'>
<p>tipos null com var</p>
<code class='javascript'
>'use strict';

var a = 1;
var b = null;

// var permite que se declare a mesma variável mais de uma vez
// então se a ou b já existirem, utilizamos o valor das variáveis existentes
// se não, atribuímos o valor 2

var a = a || 2; // 1
var b = b || 2; // 2</code
>
</div>

<p>Num mesmo arquivo a utilidade disso não parece muito grande, mas em dois arquivos, este padrão se mostrava mais atrativo.</p>

<div class='codeblock'>
<p>sanfona.js - namespaces</p>
<code class='javascript'
>'use strict'

// namespace widgets
var widgets = widgets || {}; // garantimos que widgets exista antes de adicionarmos propriedades a ele

// namespace sanfona
widgets.sanfona = {};</code
>
</div>

<div class='codeblock'>
<p>calendario.js - namespaces</p>
<code class='javascript'
>'use strict'

// namespace widgets
var widgets = widgets || {}; // garantimos que widgets exista antes de adicionarmos propriedades a ele

// namespace calendario
widgets.calendario = {};</code
>
</div>

<div class='codeblock'>
<code class='javascript'
>var console = console || {}; // cria um objeto somente se console não existir</code
>
</div>

<p>Vimos anteriormente que utilizando funções anônimas autoexecutáveis isolamos um escopo. Porém, não conseguimos acessá-lo de fora. Para tanto, precisamos simular um namespace. Aproveitamos que JavaScript permite adicionar dinamicamente propriedades em objetos para fazer isso.</p>

<div class='codeblock'>
<p>simulação de namespaces</p>
<code class='javascript'
>var namespace = namespace || {};
namespace.subnamespace = namespace.subnamespace || {};

namespace.subnamespace.meuObjeto = {
	metodo: function() {
		//
	}
};

(function() {
	// "import"
	var meuObjeto = namespace.subnamespace.meuObjeto;

	meuObjeto.metodo();
})();</code
>
</div>

<p>O primeiro nivel do namescape ocupa o espaço global, que como já vimos, é compartilhado por todos os arquivos e blocos de script da página. Portanto, podemos acrescentar mais coisas posteriormente ao mesmo namespace em um arquivo diferente.</p>

<div class='codeblock'>
<p>simulação de namespaces, outro arquivo</p>
<code class='javascript'
>var namespace = namespace || {};
namespace.subnamespace = namespace.subnamespace || {};

namespace.subnamespace.meuOutroObjeto = {
	metodo: function() {
		//
	}
};

(function() {
	// "import"
	var meuObjeto = namespace.subnamespace.meuObjeto;
	var meuOutroObjeto = namespace.subnamespace.meuOutroObjeto;

	meuObjeto.metodo();
	meuOutroObjeto.metodo();
})();</code
>
</div>


<h3 id='number'>Number</h3>

<p>É o <strong>único tipo numérico</strong> existente em JavaScript. <strong>Sempre é um <em>double</em></strong> <em>(double-precision 64-bit binary format IEEE 754-2008)</em> independente da notação que usamos. Pode também conter os valores especiais <code class='javascript'>NaN</code>, infinito positivo (<code class='javascript'>Number.POSITIVE_INFINITY</code>) e infinito negativo (<code class='javascript'>Number.NEGATIVE_INFINITY</code>).</p>

<div class='codeblock'>
<p>formatos números</p>
<code class='javascript'
>'use strict';

let i = 1; // é um double!
let area = 4.527; // também é um double
const negativo = -2; // sem notação especial para números negativos
let abreviado = .7; // 0.7

// notação científica usa e ou E
let c1 = 1e0; // 1 × 10^0 = 1 × 1 = 1
let c2 = 1E-1; // 1 × 10^-1 = 1 × 0.1 = 0.1
let c3 = -.7e-2; // -0.7 × 10^-2 = -0.7 × 0.01 = -0.007

// notação binária usa b ou B
// também são double
let binario = 0b01;
let bipolarOtimista = 0B11010;
let bipolarNegativo = -0b11010;

// notação octal usa o (letra ó minúsculo) ou O (letra ó maiúsculo)
// vc adivinhou, eles também são double
let octal = 0o01234567;
let entreMeusDedos = 0O12345670;

// notação hexadecimal usa x ou X
// isso mesmo, você é quase um expert
// os números que utilizam essa notação também são double
let hexadecimal = 0x0123456789ABCDEF;
let cor = 0Xff0000;

// NOTAÇÃO DECIMAL
// ===============
// JavaScript permite que os números
// sejam precedidos por 0 sem
// que isso influencie em seu valor
int i1 = 10;
int p1 = 01;

let impossible1 = 1 / 0; /// Infinity

let impossible2 = Math.sqrt(-1); // NaN
let impossible3 = Number.parseInt('wrong format'); // NaN

area.toFixed(1); // retorna '4.5'

1.9.toFixed(); // retorna '2'</code
>
</div>

<p><strong>Números não sofrem <em>overflow</em> nem <em>underflow</em>, mas não dão aviso se você tentar passar dos limites.</strong></p>

<div class='codeblock'>
<p>formatos números</p>
<code class='javascript'
>'use strict';

let i = Number.MAX_VALUE;
let j = Number.MAX_VALUE + 1; // não dá aviso
if (i === j) {
	console.log('j foi limitado');
}

i = -i
j = -j - 1; // não dá aviso
if (i === j) {
	console.log('j foi limitado');
}</code
>
</div>

<h3 id='string'>String</h3>

<p>É um objeto <strong>imutável.</strong> Pode usar como delimitador <strong>aspas simples ou duplas</strong> dependendo da necessidade. Para quebrá-la em mais de uma linha, escapamos a quebra de linha com uma barra invertida. Podemos escapar caracteres especiais assim como em outras linguagens.</p>

<div class='codeblock'>
<p>tipos de strings</p>
<code class='javascript'
>'use strict';

let simples = 'A primeira faz "tchan"';
let dupla = "A segunda faz 'tchun'";

const iara = "mãe d'água";
const modoDificil = 'O\'Reilly';
let html = '&lt;em class="especial"&gt;ênfase&lt;/em&gt;';

let calvinHarris = 'how deep\nis your love'; // 2 linhas

let pareceMasNaoE = 'começa e \
termina na mesma linha?'; // 1 linha apenas

// várias linhas
let josePauloPaes = 'Meu amor é simples, Dora,\n\
Como a água e o pão.\n\
\n\
Como o céu refletido\n\
Nas pupilas de um cão.';

let emoji = '😍';
let es5 = '\uD83D\uDE0D'; // code units / surrogates
let es6 = '\u{1F60D}'; // code point

// string é imutável, então seus métodos retornam novas instâncias
let beeGees = calvinHarris.replace('love', 'looove'); // pq um tutorial de programação não é completo sem uma homenagem aos bee gees ;)

'Gritando'.toUpperCase(); // retorna 'GRITANDO'</code
>
</div>

<p>Existem strings um pouco <strong>mais poderosas</strong> à partir da versão ES6, chamadas <em>Template Strings</em>. Elas permitem ser quebradas em mais de uma linha. Seu <strong>demilitador é a crase.</strong></p>

<div class='codeblock'>
<p>template strings</p>
<code class='javascript'
>'use strict';

let duplaTemplate = `A primeira faz "tchan". A segunda faz 'tchun'`;

// várias linhas
let leminskiTemplate = `Merda é veneno.
No entanto, não há nada
que seja mais bonito
que uma bela cagada.
Cagam ricos, cagam pobres,
cagam reis e cagam fadas.
Não há merda que se compare
à bosta da pessoa amada.`;</code
>
</div>

<p>A representação interna das strings é UTF-16. Nas versões ES6+, podemos iterar pelos <em>code points</em> das strings, isto é, ler caractere por caractere independente do número de bytes que eles usam. Nas versões ES5-, apenas <em>code units</em> são suportadas. O site 2ality tem um artigo bem completo sobre <a rel='external nofollow' href='http://www.2ality.com/2013/09/javascript-unicode.html'>codificação de strings</a> e outro <a rel='external nofollow' href='http://www.2ality.com/2015/01/es6-strings.html'>atualizado para ES6</a>.</p>

<div class='codeblock'>
<p>code points</p>
<code class='javascript'
>'use strict';

const multibyte = 'd😍b';
for (let caractere of multibyte) {
	console.log(caractere);
	console.log(caractere.length);
}

// d
// 1
// 😍
// 2
// b
// 1</code
>
</div>

<h4>Interpolação de variáveis</h4>

<p>O real motivo das <em>template strings</em> existirem é para facilitar a <strong>utilização de variáveis junto com strings.</strong></p>

<div class='codeblock'>
<p>strings simples e template strings com variáveis</p>
<code class='javascript'
>'use strict';

let nome = 'Pafúncio';
let respostaSimples = 'Oi ' + nome + '. Já te ligo ok?';
let respostaTemplate = `Oi ${nome}. Já te ligo ok?`;
// ambos geram Oi Pafúncio. Já te ligo ok?</code
>
</div>

<p>Existe ainda um <a href='#reticencias'>uso mais avançado de templates</a> que veremos em na parte sobre funções.</p>


<h3 id='array'>Array</h3>

<p>Mistura de <code class='c'>Array</code> e <code class='c'>ArrayList&lt;Object&gt;</code>, isto é, <strong>muda de tamanho conforme a necessidade, e pode armazenar tipos misturados.</strong> Podemos inicializar com um tamanho inicial por motivos de performance. Acessamos os elementos dela com o operador <code class='javascript'>[]</code>. Note que não é feito <strong>nenhum tipo de restrição</strong> para acessar <strong>índices inexistentes</strong> na <code class='javascript'>Array</code>!</p>
<p>Assim como ganhamos performance ao <strong>manter</strong> sempre o mesmo tipo para uma variável, <strong>ganhamos performance ao armazenar</strong> sempre o mesmo tipo de variáveis numa <code class='javascript'>Array</code>.</p>

<div class='codeblock'>
<p>arrays</p>
<code class='javascript'
>'use strict';

let noticias = []; // array vazia

console.log(noticias.length); // mostra 0
console.log(noticias[56]); // mostra undefined e continua normalmente

// array é mutável, então seus métodos modificam a array
noticias.push('notícia extremamente curta :P'); // insere um elemento ao final da Array
noticias[5] = 'e outra reduzida também'; // insere um elemento no índice 5
noticias.push('ao vivo'); // insere um elemento no índice 6, que é o final da Array

let noticias2 = new Array(10); // array vazia com espaço pré-alocado para 10 elementos.

console.log(noticias2.length); // mostra 10
console.log(noticias2[4]); // mostra undefined, pois não atribuímos um valor para este índice
console.log(noticias2[20]); // mostra undefined, pois não atribuímos um valor para este índice

noticias2.push('vai no índice 11'); // os 10 primeiros são undefined

let bagunca = [38, 'texto']; // perfeitamente legal, embora seja lento</code
>
</div>

<p>A <code class='javascript'>Array</code> possui alguns métodos nativos úteis, como <code class='javascript'>forEach</code>, <code class='javascript'>filter</code>, <code class='javascript'>map</code> e <code class='javascript'>reduce</code>. Mas devido ao <a href='#async'>modelo de paralelismo</a> da linguagem, creio que a otimização desses métodos <strong>não seja</strong> tão grande assim.</p>

<p>Os exemplos abaixo são um pouco mais complicados, então talvez você queira ler a parte sobre funções e objetos e voltar aqui depois se não entender alguma coisa.</p>

<div class='codeblock'>
<p>bonus métodos array</p>
<code class='javascript'
>'use strict';

// retorna uma nova array sem os elementos das posições pares
// se lembre que o índice começa em 0, e não em 1
[21, 72, 3, 34, 55, 60].filter(function(element, index) {
	if(index % 2 === 0) {
		return true;
	}
	return false;
});

// cria uma array literal
[1, 2]

	// executa o callback em cada elemento da array
	.map(function(currentValue) {
		return currentValue + 1;
	}) // [2, 3]

	// executa o callback em cada elemento da array
	// e vai acumulando o resultado
	.reduce(function(previousValue, currentValue) {
		return previousValue + currentValue;
	}); // o retorno de reduce é 5</code
>
</div>


<h3 id='regex'>RegExp</h3>

<p>Além do objeto <code class='javascript'>RegExp</code>, JavaScript possui expressões regulares em forma de literal, delimitadas por barras, e opcionalmente com <em>flags</em> após a barra final.</p>

<div class='codeblock'>
<p>formatos de expressões regulares</p>
<code class='javascript'
>'use strict';

const regex = /a+/gi; // expressão na forma literal com flags g (não parar no primeiro match) e i (case insensitive)
const regex2 = new RegExp('a+', 'gi'); // mesma expressão na forma de objeto

regex.test('abobrinha'); // retorna true
/why don't you/.test('me now\?'); // retorna false</code
>
</div>


<h3 id='function'>Function</h3>

<p>Em JavaScript, métodos e funções <strong>sempre são <a rel='external nofollow' href='https://en.wikipedia.org/wiki/Function_object'>objetos</a>!</strong> Isso significa que elas possuem propriedades e métodos como o <code class='javascript'>call</code> por exemplo.</p>

<p>Nunca declaramos o tipo de retorno de uma função. Uma vez que JavaScript não proíbe que os tipos das variáveis mude, é permitido que a função retorne qualquer coisa, misture os tipos de retorno, etc. O número de parâmetros também <strong>não precisa</strong> ser declarado, ou seja, todas as funções em JavaScript são <a href='https://en.wikipedia.org/wiki/Variadic_function' rel='external nofollow'>variádicas</a>. Esta funcionalidade costumava ser usada para simular <strong>sobrecarga de função</strong>, juntamente com o objeto <code class='javascript'>arguments</code> que toda a função <strong>recebe implicitamente.</strong> Porém esta é uma <strong>prática não mais recomendada.</strong> Para a solução atual recomendada, veja <a href='#reticencias'>operador rest</a>.</p>

<p>Note que embora a chamada de funções da maneira descrita acima seja permitida, o compilador ainda pode lançar exceções ao tentar utilizar variáveis que não foram devidamente passadas ao método.</p>

<div class='codeblock'>
<p>chamadas válidas de métodos</p>
<code class='javascript'
>'use strict';

function comum() {
	console.log(arguments); // objeto arguments iniciado automaticamente, contendo os parâmetros utilizados na chamada
}

function normal(texto) {
	console.log(arguments); // objeto arguments iniciado automaticamente, contendo os parâmetros utilizados na chamada
}

function retornoMisturado(numero) {
	if (numero > 0) {
		return 'texto';
	}
	return 25;
}

// chamadas perfeitamente válidas
comum(); // arguments será []
comum('lala'); // arguments será ['lala']
comum('lala', 'lolo'); // arguments será ['lala', 'lolo']
normal('lolo'); // texto será 'lolo' e  arguments será ['lolo']

// chamada válida
normal(); // o parâmetro texto terá o valor undefined e arguments será []

normal.call(this, 'dadaísmo'); // o parâmetro texto terá o valor 'dadaísmo' e arguments será ['dadaísmo']

retornoMisturado(-1); // retorna 25
retornoMisturado(1); // retorna 'texto'</code
>
</div>

<p>Como mencionei, a possibilidade de chamar funções com parâmetros diferentes dos definidos costumava ser usada para simular sobrecarga de função. Se você precisa dar manutenção em códigos antigos, saiba que em Javascript, os <strong>métodos são diferenciados pelo seu nome exclusivamente,</strong> e sua sobrecarga antigamente era feita da seguinte maneira:</p>

<div class='codeblock'>
<p>sobrecarga de função</p>
<code class='javascript'
>'use strict';

function efetuarRequisicaoAjax(endereco) {

	const url = endereco;

	<strong>// SINTAXE ANTIGA!!! NÃO COPIE!!!</strong>

	if (arguments[1]) {

		if (typeof arguments[1] === 'number') { // segundo parâmetro passado para a função
			url += '?pagina=' + arguments[1];
		} else if (typeof arguments[1] === 'string') {
			url += '?token=' + arguments[1];
		}

	}

	<strong>// SINTAXE ANTIGA!!! NÃO COPIE!!!</strong>

	if (arguments[2]) {
		url += '&amp;pagina=' + arguments[2]; // terceiro parâmetro passado para a função
	}

	console.log(url); // vamos ver um exemplo real de ajax lá no final ;)

}

<strong>// SINTAXE ANTIGA!!! NÃO COPIE!!!</strong>

efetuarRequisicaoAjax('webservicedagrecia.ashx');
efetuarRequisicaoAjax('webservicedagrecia.ashx', 2);
efetuarRequisicaoAjax('webserviceseguro.ashx', '987dcb987d6b96a9d5ab');
efetuarRequisicaoAjax('webserviceseguro.ashx', '987dcb987d6b96a9d5ab', 2);</code
>
</div>

<p id='funcaoestrita'>Como mencionei lá no começo, funções podem ser selecionadas individualmente para utilizar o modo estrito. Isso é útil nos casos em que precisamos dar manutenção em códigos antigos, ou quando inserimos código <strong>dentro de tags</strong> <code class='html'>&lt;script /&gt;</code>, ao invés de em arquivos externos.</p>

<div class='codeblock'>
<p>funções estritas</p>
<code class='javascript'
>function funcaoNormal() {
	console.log(varNaoDeclarada); // mostra undefined em navegadores antigos, nos novos lança exceção
}

function funcaoEstrita() {
	'use strict';

	console.log(varNaoDeclarada); // lança exceção
}</code
>
</div>

<p>JavaScript suporta <strong>funções anônimas, ou expressões lambda.</strong> Expressões lambda são utilizados frequentemente em JavaScript, por isso é importante compreender o que são.</p>

<p>Expressões lambda são declarações de funções anônimas diretamente no meio do código. Basicamente em qualquer lugar onde podemos passar uma referência para uma função, podemos criar uma expressão lambda. Seguem exemplos em outras linguagens de expressões lambdas.</p>

<div class='codeblock'>
<p>código C</p>
<code class='generic'
><span class='comment'>// lambda em C</span>
<span class='comment'>// pegadinha do malandro! C não tem isso.</span></code
>
</div>

<div class='codeblock'>
<p>código Swift</p>
<code class='generic'
><span class='comment'>// lambda em Swift</span>

<span class='symbol'>superior</span><span class='operator'>(</span><strong><span class='operator'>{() -></span> <span class='type'>TipoDoRetorno</span> <span class='keyword'>in</span></strong>
	<span class='comment'>// corpo da função</span>
<strong><span class='operator'>}</span></strong><span class='operator'>)</span></code
>
</div>

<div class='codeblock'>
<p>código Objective-C</p>
<code class='generic'
><span class='comment'>// lambda em Objective-C (OS X v10.6+ e iOS 4+) - chamado de Block</span>

<span class='operator'>[</span><span class='symbol'>superior</span> <span class='symbol'>usando</span><span class='operator'>:</span><strong><span class='operator'>^() {</span></strong>
	<span class='comment'>// corpo da função</span>
<strong><span class='operator'>}</span></strong><span class='operator'>];</span></code
>
</div>

<div class='codeblock'>
<p>código C#</p>
<code class='generic'
><span class='comment'>// lambda em C# 4 - idêntico a JavaScript</span>

<span class='symbol'>superior</span><span class='operator'>(</span><strong><span class='operator'>() =&gt; {</span></strong>
	<span class='comment'>// corpo da função</span>
<strong><span class='operator'>}</span></strong><span class='operator'>);</span></code
>
</div>

<div class='codeblock'>
<p>código Java</p>
<code class='generic'
><span class='comment'>// lambda em Java 8</span>

<span class='symbol'>superior</span><span class='operator'>(</span><strong><span class='operator'>() -&gt; {</span></strong>
	<span class='comment'>// corpo da função</span>
<strong><span class='operator'>}</span></strong><span class='operator'>);</span></code
>
</div>

<div class='codeblock'>
<p>código C++</p>
<code class='generic'
><span class='comment'>// lambda em C++11</span>

<span class='symbol'>superior</span><span class='operator'>(</span><strong><span class='operator'>[] () {</span></strong>
	<span class='comment'>// corpo da função</span>
<strong><span class='operator'>}</span></strong><span class='operator'>);</span></code
>
</div>

<div class='codeblock'>
<p>código Rust</p>
<code class='generic'
><span class='comment'>// lambda em Rust</span>

<span class='symbol'>superior</span><span class='operator'>(</span><strong><span class='operator'>|| {</span></strong>
	<span class='comment'>// corpo da função</span>
<strong><span class='operator'>}</span></strong><span class='operator'>);</span></code
>
</div>

<div class='codeblock'>
<p>código PHP</p>
<code class='generic'
><span class='comment'>// lambda em PHP - idêntico a JavaScript</span>

<span class='symbol'>superior</span><span class='operator'>(</span><strong>function<span class='operator'>() {</span></strong>
	<span class='comment'>// corpo da função</span>
<strong><span class='operator'>}</span></strong><span class='operator'>);</span></code
>
</div>

<p>E as duas formas possíveis em JavaScript.</p>

<div class='codeblock'>
<p>código JavaScript - funções de ordem superior</p>
<code class='javascript'
>'use strict';

// função normal
function normal() {
	//
}

// função de ordem superior
function superior(funcao) {
	funcao(); // executa a função passada
}

<strong>// função normal sendo passado como parâmetro - note que usamos apenas o nome, sem executar com ()</strong>
superior(<strong class='small'>normal</strong>);

<strong>// expressão lambda sendo passada como parâmetro</strong>
superior(<strong class='small'>function() {</strong>
	//
<strong>}</strong>);

<strong>// expressão lambda com nova sintaxe de flecha (ES6) sendo passada como parâmetro</strong>
<strong>// dependendo do que a expressão lambda fizer, alguns caracteres podem ser omitidos</strong>
superior(<strong class='small'>() =&gt; {</strong>
	//
<strong>}</strong>);</code
>
</div>

<p>Funções definidas com a flecha gorda, possuem novas regras específicas para a palavra-chave this utilizada dentro de seu corpo. Vale conferir as <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Lexical_this' rel='external nofollow'>regras na MDN</a>.</p>

<p>Além de expressões lambda, JavaScript suporta um modo de declaração chamado <strong><q>expressão de função</q>.</strong> Mais adiante veremos <a href='#funcaoanonimaescopo'>outro uso para este tipo de declaração</a>.</p>

<div class='codeblock'>
<p>expressões de função</p>
<code class='javascript'
>'use strict';

// declaração de função
function normal() {
	//
}

// expressão de função - tratamos a função como um valor
const surpresa = function() {
	//
};

// expressão de função
const outraSurpresa = normal;

normal();
surpresa();
outraSurpresa();

// expressão de função anônima - note os () em volta dela
// veremos mais adiante <a href='#funcaoanonimaescopo'>outros usos para essa forma</a>
(function() {
	//
});
</code
>
</div>

<h3 id='reticencias'>Operadores rest e spread</h3>

<p>Agora que conhecemos funções, strings e arrays, podemos ver um exemplo mais completo dessas partes. Existem dois operadores em JavaScript que são representados por <code class='javascript'>...</code>, chamados rest e spread. A função deles é respectivamente transformar uma sequência de elementos em uma <code class='javascript'>Array</code>, e expandir uma <code class='javascript'>Array</code> em uma sequência de elementos. Como ambos usam <code class='javascript'>...</code>, o que diferencia um do outro é o local de uso.</p>

<p>Num local onde faça sentido expandir a <code class='javascript'>Array</code>, teremos o operador spread.</p>

<div class='codeblock'>
<p>operador spread</p>
<code class='javascript'
>'use strict';

let comeco = [1, 2, 3];
let completo = [...comeco, 4, 5]; // [1, 2, 3, 4, 5]

function tresArgumentos(primeiro, segundo, terceiro) {
	//
}

// expandindo argumentos passados
tresArgumentos(...comeco); // primeiro = 1, segundo = 2, terceiro = 3</code
>
</div>

<p>E portanto, num local onde faça mais sentido juntar os elementos, teremos o operador rest.</p>

<div class='codeblock'>
<p>operador rest</p>
<code class='javascript'
>'use strict';

let a, b, outros;
[a, b] = [1, 2]; // a = 1, b = 2
[a, b, ...outros] = [1, 2, 3, 4, 5]; // a = 1, b = 2, outros = [3, 4, 5]

// agrupando argumentos que se espera receber
// ou funções variádicas
function variosArgumentos(primeiro, segundo, ...outros) {
	//
}

variosArgumentos(1, 2, 3, 4, 5); // primeiro = 1, segundo = 2, outros = [3, 4, 5]</code
>
</div>

<p>Este operador é o recomendado atualmente para a programação de <strong>sobrecarga de métodos,</strong> ao invés de utilizar o objeto legado <code class='javascript'>arguments</code>. Suas vantagens incluem a maior facilidade de misturar parâmetros nomeados e não nomeados, percorrer os parâmetros não nomeados como uma <code class='javascript'>Array</code> (ao passo que <code class='javascript'>arguments</code> é um objeto com propriedades numeradas) e servir exclusivamente para gerenciar parâmetros, sendo que <code class='javascript'>arguments</code> possui propriedades depreciadas como <code class='javascript'>arguments.caller</code> e <code class='javascript'>arguments.callee</code>.</p>

 <p>Em linguagens mais estritas, os métodos são diferenciados pela sua assinatura, que é composta pelo nome e pela quantidade e tipos de parâmetros. Portanto, podemos declarar funções e métodos com nomes diferentes desde que seus parâmetros também sejam diferentes.</p>

<div class='codeblock'>
<p>sobrecarga de função em C# / Java</p>
<code class='generic'
><span class='comment lineComment'>// Sobrecarga de método em C# / Java</span>

<span class='keyword'>public</span> <span class='keyword'>class</span> <span class='symbol'>Overloaded</span> <span class='operator'>{</span>
	<span class='keyword'>public</span> <span class='keyword'>void</span> <span class='symbol'>skip</span><span class='operator'>()</span> <span class='operator'>{</span> <span class='comment blockComment'>/**/</span> <span class='operator'>}</span>
	<span class='keyword'>public</span> <span class='keyword'>void</span> <span class='symbol'>skip</span><span class='operator'>(</span><span class='type nativeType'>int</span> <span class='symbol'>amount</span><span class='operator'>)</span> <span class='operator'>{</span> <span class='comment blockComment'>/**/</span> <span class='operator'>}</span>
<span class='operator'>}</span>
</code
>
</div>

<div class='codeblock'>
<p>sobrecarga de função em C++</p>
<code class='generic'
><span class='comment lineComment'>// Sobrecarga de método em C++</span>

<span class='keyword'>public</span> <span class='keyword'>class</span> <span class='symbol'>Overloaded</span> <span class='operator'>{</span>
	<span class='keyword'>public</span>:
	<span class='keyword'>void</span> <span class='symbol'>skip</span><span class='operator'>()</span> <span class='operator'>{</span> <span class='comment blockComment'>/**/</span> <span class='operator'>}</span>
	<span class='keyword'>void</span> <span class='symbol'>skip</span><span class='operator'>(</span><span class='type nativeType'>int</span> <span class='symbol'>amount</span><span class='operator'>)</span> <span class='operator'>{</span> <span class='comment blockComment'>/**/</span> <span class='operator'>}</span>
}
</code
>
</div>

<p>Em JavaScript tal diferenciação não existe. As funções são diferenciadas exclusivamente pelo seu nome. Portanto, a maneira mais próxima de obtermos o que queremos, é utilizando outro recurso, também presente em diversas outras linguagens. Podemos permitir uma quantidade variável de parâmetros nas funções, e depois escolhermos o que fazer baseados nos tipos dos argumentos.</p>

<p>Das linguagens mais utilizadas atualmente que suportam esse recurso, C e Objective-C possuem uma sintaxe própria com macros. C++ usa templates, que são ligeiramente mais verbosos. As demais são bastante parecidas como podemos ver a seguir.</p>

<div class='codeblock'>
<p>funções variádicas em Swift</p>
<code class='generic'
><span class='comment lineComment'>// funções variádicas em Swift</span>

<strong class='comment'><span class='comment lineComment'>// argumentos do mesmo tipo</span></strong>

<strong><span class='keyword'>func</span> <span class='symbol'>imprimirSimples</span><span class='operator'>(</span></strong><span class='symbol'>titulo titulo</span><span class='operator'>:</span><span class='type'>String</span><span class='operator'>,</span> <strong><span class='symbol'>paginas</span><span class='operator'>:</span><span class='type'>Int</span><span class='operator'>...) {</span></strong>
	<strong><span class='keyword'>for</span> <span class='symbol'>pagina</span> <span class='keyword'>in</span> <span class='symbol'>paginas</span> <span class='operator'>{</span></strong>
		<span class='symbol'>print</span><span class='operator'>(</span><span class='string'>"Imprimindo página \(pagina) num total de \(paginas.count)"</span><span class='operator'>)</span>
	<strong><span class='operator'>}</span></strong>
<strong><span class='operator'>}</span></strong>

<span class='symbol'>imprimirSimples</span><span class='operator'>(</span><span class='symbol'>titulo</span><span class='operator'>:</span> <span class='string'>"resumo"</span><span class='operator'>,</span> <span class='symbol'>paginas</span><span class='operator'>:</span> <span class='number'>1</span><span class='operator'>,</span> <span class='number'>2</span><span class='operator'>,</span> <span class='number'>5</span><span class='operator'>)</span>

<strong class='comment'><span class='comment lineComment'>// argumentos de todos os tipos</span></strong>

<span class='keyword'>func</span> <span class='symbol'>imprimir</span><span class='operator'>(</span><span class='symbol'>titulo titulo</span><span class='operator'>:</span><span class='type'>String</span><span class='operator'>,</span> <strong><span class='symbol'>paginas</span><span class='operator'>:</span><span class='type'>Any</span><span class='operator'>...</span></strong><span class='operator'>) {</span>
	<span class='keyword'>for</span> <span class='symbol'>valor</span> <span class='keyword'>in</span> <span class='symbol'>paginas</span> <span class='operator'>{</span>
		<strong><span class='keyword'>switch</span> <span class='symbol'>valor</span> <span class='operator'>{</span></strong>
		<strong><span class='keyword'>case</span></strong> <span class='keyword'>let</span> <span class='symbol'>pagina</span> <strong><span class='keyword'>as</span> <span class='type'>Int</span><span class='operator'>:</span></strong>
			<span class='symbol'>print</span><span class='operator'>(</span><span class='string'>"Imprimindo página \(pagina)"</span><span class='operator'>)</span>
		<strong><span class='keyword'>case</span></strong> <span class='keyword'>let</span> <span class='symbol'>faixa</span> <strong><span class='keyword'>as</span> <span class='type'>Range&lt;Int&gt;</span><span class='operator'>:</span></strong>
			<span class='symbol'>print</span><span class='operator'>(</span><span class='string'>"Imprimindo páginas \(faixa.first!) até \(faixa.last!)"</span><span class='operator'>)</span>
		<strong><span class='keyword'>default</span><span class='operator'>:</span></strong>
			<span class='symbol'>print</span><span class='operator'>(</span><span class='string'>"Imprimindo outra coisa"</span><span class='operator'>)</span>
		<strong><span class='operator'>}</span></strong>
	<span class='operator'>}</span>
<span class='operator'>}</span>

<span class='symbol'>imprimir</span><span class='operator'>(</span><span class='symbol'>titulo</span><span class='operator'>:</span> <span class='string'>"resumo"</span><span class='operator'>,</span> <span class='symbol'>paginas</span><span class='operator'>:</span> <span class='number'>1</span><span class='operator'>,</span> <span class='number'>2</span><span class='operator'>...</span><span class='number'>5</span><span class='operator'>,</span> <span class='string'>"capítulo 2"</span><span class='operator'>)</span></code
>
</div>

<div class='codeblock'>
<p>funções variádicas em C#</p>
<code class='generic'
><span class='comment lineComment'>// funções variádicas em C#</span>
<span class='comment lineComment'>// a propósito, o estilo padrão de { e } em C# é que eles fiquem em linhas separadas</span>
<span class='comment lineComment'>// mas ia ocupar muito espaço desnecessário nesse exemplo</span>

<strong class='comment'><span class='comment lineComment'>// argumentos do mesmo tipo</span></strong>

<strong><span class='keyword'>void</span> <span class='symbol'>ImprimirSimples</span><span class='operator'>(</span></strong><span class='type'>string</span> <span class='symbol'>titulo</span><span class='operator'>,</span> <strong><span class='keyword'>params</span> <span class='type'>int[]</span> <span class='symbol'>paginas</span><span class='operator'>)</span> <span class='operator'>{</span></strong>
	<strong><span class='keyword'>foreach</span> <span class='operator'>(</span><span class='type'>int</span> <span class='symbol'>pagina</span> <span class='keyword'>in</span> <span class='symbol'>paginas</span><span class='operator'>)</span> <span class='operator'>{</span></strong>
		<span class='symbol'>System</span><span class='operator'>.</span><span class='symbol'>Console</span><span class='operator'>.</span><span class='symbol'>WriteLine</span><span class='operator'>(</span><span class='string'>@"Imprimindo pagina {0} num total de {1}"</span><span class='operator'>,</span> <span class='symbol'>pagina</span><span class='operator'>,</span> <span class='symbol'>paginas</span><span class='operator'>.</span><span class='symbol'>Length</span><span class='operator'>)</span><span class='operator'>;</span>
	<strong><span class='operator'>}</span></strong>
<strong><span class='operator'>}</span></strong>

<span class='symbol'>ImprimirSimples</span><span class='operator'>(</span><span class='string'>@"resumo"</span><span class='operator'>,</span> <span class='number'>1</span><span class='operator'>,</span> <span class='number'>2</span><span class='operator'>,</span> <span class='number'>5</span><span class='operator'>)</span><span class='operator'>;</span>

<strong class='comment'><span class='comment lineComment'>// argumentos de todos os tipos</span></strong>

<span class='keyword'>void</span> <span class='symbol'>Imprimir</span><span class='operator'>(</span><span class='type'>string</span> <span class='symbol'>titulo</span><span class='operator'>,</span> <strong><span class='keyword'>params</span> <span class='type'>object[]</span> <span class='symbol'>paginas</span></strong><span class='operator'>)</span> <span class='operator'>{</span>
	<span class='keyword'>foreach</span> <span class='operator'>(</span><span class='type'>object</span> <span class='symbol'>valor</span> <span class='keyword'>in</span> <span class='symbol'>paginas</span><span class='operator'>)</span> <span class='operator'>{</span>
		<strong><span class='keyword'>if</span></strong> <span class='operator'>(</span><span class='symbol'>valor</span> <strong><span class='keyword'>is</span> <span class='type'>int</span></strong><span class='operator'>)</span> <span class='operator'>{</span>
			<span class='symbol'>System</span><span class='operator'>.</span><span class='symbol'>Console</span><span class='operator'>.</span><span class='symbol'>WriteLine</span><span class='operator'>(</span><span class='string'>@"Imprimindo página {0}"</span><span class='operator'>,</span> <span class='symbol'>valor</span><span class='operator'>)</span><span class='operator'>;</span>
		<span class='operator'>}</span> <span class='keyword'>else</span> <strong><span class='keyword'>if</span></strong> <span class='operator'>(</span><span class='symbol'>valor</span> <strong><span class='keyword'>is</span> <span class='type'>IEnumerable&lt;int&gt;</span></strong><span class='operator'>)</span> <span class='operator'>{</span>
			<span class='symbol'>System</span><span class='operator'>.</span><span class='symbol'>Console</span><span class='operator'>.</span><span class='symbol'>WriteLine</span><span class='operator'>(</span>
				<span class='string'>@"Imprimindo páginas {0} até {1}"</span><span class='operator'>,</span>
				<span class='operator'>(</span><span class='symbol'>valor</span> <span class='keyword'>as</span> <span class='type'>IEnumerable&lt;int&gt;</span><span class='operator'>)</span><span class='operator'>.</span><span class='symbol'>First</span><span class='operator'>(</span><span class='operator'>)</span><span class='operator'>,</span>
				<span class='operator'>(</span><span class='symbol'>valor</span> <span class='keyword'>as</span> <span class='type'>IEnumerable&lt;int&gt;</span><span class='operator'>)</span><span class='operator'>.</span><span class='symbol'>Last</span><span class='operator'>(</span><span class='operator'>)</span>
			<span class='operator'>)</span><span class='operator'>;</span>
		<span class='operator'>}</span> <strong><span class='keyword'>else</span></strong> <span class='operator'>{</span>
			<span class='symbol'>System</span><span class='operator'>.</span><span class='symbol'>Console</span><span class='operator'>.</span><span class='symbol'>WriteLine</span><span class='operator'>(</span><span class='string'>@"Imprimindo outra coisa"</span><span class='operator'>)</span><span class='operator'>;</span>
		<span class='operator'>}</span>
	<span class='operator'>}</span>
<span class='operator'>}</span>

<span class='symbol'>Imprimir</span><span class='operator'>(</span><span class='string'>@"resumo"</span><span class='operator'>,</span> <span class='number'>1</span><span class='operator'>,</span> <span class='symbol'>Enumerable</span><span class='operator'>.</span><span class='symbol'>Range</span><span class='operator'>(</span><span class='number'>2</span><span class='operator'>,</span> <span class='number'>4</span><span class='operator'>)</span><span class='operator'>,</span> <span class='string'>@"capítulo 2"</span><span class='operator'>)</span><span class='operator'>;</span></code
>
</div>

<div class='codeblock'>
<p>funções variádicas em Java</p>
<code class='generic'
><span class='comment lineComment'>// métodos variádicos em Java</span>
<span class='comment lineComment'>// algumas coisas foram omitidas propositalmente como main</span>

<strong class='comment'><span class='comment lineComment'>// argumentos do mesmo tipo</span></strong>

<strong><span class='keyword'>void</span> <span class='symbol'>imprimirSimples</span><span class='operator'>(</span></strong><span class='type'>String</span> <span class='symbol'>titulo</span><span class='operator'>,</span> <strong><span class='type'>int</span><span class='operator'>...</span> <span class='symbol'>paginas</span><span class='operator'>)</span> <span class='operator'>{</span></strong>
	<strong><span class='keyword'>for</span> <span class='operator'>(</span><span class='type'>int</span> <span class='symbol'>pagina</span> <span class='operator'>:</span> <span class='symbol'>paginas</span><span class='operator'>)</span> <span class='operator'>{</span></strong>
		<span class='symbol'>System</span><span class='operator'>.</span><span class='symbol'>out</span><span class='operator'>.</span><span class='symbol'>println</span><span class='operator'>(</span><span class='symbol'>String</span><span class='operator'>.</span><span class='symbol'>format</span><span class='operator'>(</span><span class='string'>"Imprimindo página %1"</span><span class='operator'>,</span> <span class='symbol'>pagina</span><span class='operator'>)</span><span class='operator'>)</span><span class='operator'>;</span>
	<strong><span class='operator'>}</span></strong>
<strong><span class='operator'>}</span></strong>

<span class='symbol'>imprimirSimples</span><span class='operator'>(</span><span class='string'>"resumo"</span><span class='operator'>,</span> <span class='number'>1</span><span class='operator'>,</span> <span class='number'>2</span><span class='operator'>,</span> <span class='number'>5</span><span class='operator'>)</span><span class='operator'>;</span>

<strong class='comment'><span class='comment lineComment'>// argumentos de todos os tipos</span></strong>

<span class='keyword'>void</span> <span class='symbol'>imprimir</span><span class='operator'>(</span><span class='type'>String</span> <span class='symbol'>titulo</span><span class='operator'>,</span> <strong><span class='type'>Object</span><span class='operator'>...</span> <span class='symbol'>paginas</span></strong><span class='operator'>)</span> <span class='operator'>{</span>
	<span class='keyword'>for</span> <span class='operator'>(</span><span class='type'>Object</span> <span class='symbol'>valor</span> <span class='operator'>:</span> <span class='symbol'>paginas</span><span class='operator'>)</span> <span class='operator'>{</span>
		<strong><span class='keyword'>if</span></strong> <span class='operator'>(</span><span class='symbol'>valor</span> <strong><span class='keyword'>instanceof</span> <span class='type'>Integer</span></strong><span class='operator'>)</span> <span class='operator'>{</span>
			<span class='symbol'>System</span><span class='operator'>.</span><span class='symbol'>out</span><span class='operator'>.</span><span class='symbol'>println</span><span class='operator'>(</span><span class='symbol'>String</span><span class='operator'>.</span><span class='symbol'>format</span><span class='operator'>(</span><span class='string'>"Imprimindo página %d"</span><span class='operator'>,</span> <span class='symbol'>valor</span><span class='operator'>)</span><span class='operator'>)</span><span class='operator'>;</span>
		<span class='operator'>}</span> <span class='keyword'>else</span> <strong><span class='keyword'>if</span></strong> <span class='operator'>(</span><span class='symbol'>valor</span> <strong><span class='keyword'>instanceof</span> <span class='type'>Range&lt;Integer&gt;</span></strong><span class='operator'>)</span> <span class='operator'>{</span>
			<span class='symbol'>System</span><span class='operator'>.</span><span class='symbol'>out</span><span class='operator'>.</span><span class='symbol'>println</span><span class='operator'>(</span><span class='symbol'>String</span><span class='operator'>.</span><span class='symbol'>format</span><span class='operator'>(</span>
				<span class='string'>"Imprimindo páginas %d até %d"</span><span class='operator'>,</span>
				<span class='operator'>((</span><span class='symbol'>Range</span><span class='operator'>&lt;</span><span class='symbol'>Integer</span><span class='operator'>&gt;</span><span class='operator'>)</span><span class='symbol'>valor</span><span class='operator'>)</span><span class='operator'>.</span><span class='symbol'>getMinimum</span><span class='operator'>()</span><span class='operator'>,</span>
				<span class='operator'>((</span><span class='symbol'>Range</span><span class='operator'>&lt;</span><span class='symbol'>Integer</span><span class='operator'>&gt;</span><span class='operator'>)</span><span class='symbol'>valor</span><span class='operator'>)</span><span class='operator'>.</span><span class='symbol'>getMaximum</span><span class='operator'>()</span>
			<span class='operator'>));</span>
		<span class='operator'>}</span> <strong><span class='keyword'>else</span></strong> <span class='operator'>{</span>
			<span class='symbol'>System</span><span class='operator'>.</span><span class='symbol'>out</span><span class='operator'>.</span><span class='symbol'>println</span><span class='operator'>(</span><span class='string'>"Imprimindo outra coisa"</span><span class='operator'>);</span>
		<span class='operator'>}</span>
	<span class='operator'>}</span>
<span class='operator'>}</span>

<span class='symbol'>imprimir</span><span class='operator'>(</span><span class='string'>"resumo"</span><span class='operator'>,</span> <span class='number'>1</span><span class='operator'>,</span> <span class='symbol'>Range</span><span class='operator'>.</span><span class='symbol'>between</span><span class='operator'>(</span><span class='number'>2</span><span class='operator'>,</span> <span class='number'>5</span><span class='operator'>)</span><span class='operator'>,</span> <span class='string'>"capítulo 2"</span><span class='operator'>)</span><span class='operator'>;</span></code
>
</div>

<div class='codeblock'>
<p>funções variádicas em PHP 5.6+</p>
<code class='generic'
><span class='comment lineComment'>// funções variádicas em PHP</span>

<strong class='comment'><span class='comment lineComment'>// argumentos do mesmo tipo</span></strong>

<strong><span class='keyword'>function</span> <span class='symbol'>imprimirSimples</span><span class='operator'>(</span></strong><span class='type'>string</span> <span class='symbol'>$titulo</span><span class='operator'>,</span> <strong><span class='type'>int</span> <span class='operator'>...</span><span class='symbol'>$paginas</span><span class='operator'>)</span> <span class='operator'>{</span></strong>
	<strong><span class='keyword'>foreach</span> <span class='operator'>(</span><span class='symbol'>$paginas</span> <span class='keyword'>as</span> <span class='symbol'>$pagina</span><span class='operator'>)</span> <span class='operator'>{</span></strong>
		<span class='keyword'>echo</span> <span class='string'>"Imprimindo página $pagina\n"</span><span class='operator'>;</span>
	<strong><span class='operator'>}</span></strong>
<strong><span class='operator'>}</span></strong>

<span class='symbol'>imprimirSimples</span><span class='operator'>(</span><span class='string'>"resumo"</span><span class='operator'>,</span> <span class='number'>1</span><span class='operator'>,</span> <span class='number'>2</span><span class='operator'>,</span> <span class='number'>5</span><span class='operator'>)</span><span class='operator'>;</span>

<strong class='comment'><span class='comment lineComment'>// argumentos de todos os tipos</span></strong>

<span class='keyword'>function</span> <span class='symbol'>imprimir</span><span class='operator'>(</span><span class='type'>string</span> <span class='symbol'>$titulo</span><span class='operator'>,</span> <strong><span class='operator'>...</span><span class='symbol'>$valores</span></strong><span class='operator'>)</span> <span class='operator'>{</span>
	<span class='keyword'>foreach</span> <span class='operator'>(</span><span class='symbol'>$valores</span> <span class='keyword'>as</span> <span class='symbol'>$valor</span><span class='operator'>)</span> <span class='operator'>{</span>
		<strong><span class='keyword'>if</span></strong> <span class='operator'>(</span><strong><span class='symbol'>is_int</span><span class='operator'>(</span><span class='symbol'>$valor</span><span class='operator'>)</span></strong><span class='operator'>)</span> <span class='operator'>{</span>
			<span class='keyword'>echo</span> <span class='string'>"Imprimindo página $valor\n"</span><span class='operator'>;</span>
		<span class='operator'>}</span> <span class='keyword'>else</span> <strong><span class='keyword'>if</span></strong> <span class='operator'>(</span><strong><span class='symbol'>is_array</span><span class='operator'>(</span><span class='symbol'>$valor</span><span class='operator'>)</span></strong><span class='operator'>)</span> <span class='operator'>{</span>
			<span class='keyword'>echo</span> <span class='string'>'Imprimindo páginas'</span> <span class='operator'>.</span> <span class='symbol'>$valor</span><span class='operator'>[</span><span class='number'>0</span><span class='operator'>]</span> <span class='operator'>.</span> <span class='string'>' até '</span> <span class='operator'>.</span> <span class='symbol'>$valor</span><span class='operator'>[</span><span class='symbol'>count</span><span class='operator'>(</span><span class='symbol'>$valor</span><span class='operator'>)</span> <span class='operator'>-</span> <span class='number'>1</span><span class='operator'>]</span> <span class='operator'>.</span> <span class='string'>"\n"</span><span class='operator'>;</span>
		<span class='operator'>}</span> <strong><span class='keyword'>else</span></strong> <span class='operator'>{</span>
			<span class='keyword'>echo</span> <span class='string'>"Imprimindo outra coisa\n"</span><span class='operator'>;</span>
		<span class='operator'>}</span>
	<span class='operator'>}</span>
<span class='operator'>}</span>

<span class='symbol'>imprimir</span><span class='operator'>(</span><span class='string'>"resumo"</span><span class='operator'>,</span> <span class='number'>1</span><span class='operator'>,</span> <span class='symbol'>range</span><span class='operator'>(</span><span class='number'>2</span><span class='operator'>,</span> <span class='number'>5</span><span class='operator'>)</span><span class='operator'>,</span> <span class='string'>"capítulo 2"</span><span class='operator'>)</span><span class='operator'>;</span></code
>
</div>

<div class='codeblock'>
<p>funções variádicas em C++</p>
<code class='generic'
><span class='comment lineComment'>// funções variádicas em C++</span>

<strong class='comment'><span class='comment lineComment'>// argumentos do mesmo tipo</span></strong>

<span class='directive'>#include &lt;iostream&gt;</span>

<strong><span class='keyword'>template</span><span class='operator'>&lt;</span><span class='keyword'>typename</span><span class='operator'>...</span> <span class='type'>Tipos</span><span class='operator'>&gt;</span></strong>
<strong><span class='keyword'>void</span> <span class='symbol'>imprimirSimples</span><span class='operator'>(</span></strong><span class='type'>std::string</span> <span class='symbol'>titulo</span><span class='operator'>,</span> <strong><span class='type'>Tipos</span><span class='operator'>...</span> <span class='symbol'>paginas</span><span class='operator'>)</span> <span class='operator'>{</span></strong>

	<span class='keyword'>const</span> <span class='type'>unsigned short int</span> <span class='symbol'>quantidadeDeParametros</span> <span class='operator'>{</span><span class='symbol'>sizeof...</span><span class='operator'>(</span><span class='symbol'>paginas</span><span class='operator'>)</span><span class='operator'>}</span><span class='operator'>;</span>

	<span class='comment lineComment'>// não pode criar uma array com 0 elementos</span>
	<span class='keyword'>if</span> <span class='operator'>(</span><span class='symbol'>quantidadeDeParametros</span> <span class='operator'>==</span> <span class='number'>0</span><span class='operator'>)</span> <span class='operator'>{</span>
		<span class='keyword'>return</span><span class='operator'>;</span>
	<span class='operator'>}</span>

	<span class='comment lineComment'>// expande os argumentos</span>
	<strong><span class='type'>int</span> <span class='symbol'>paginasArray</span><span class='operator'>[</span><span class='symbol'>quantidadeDeParametros</span><span class='operator'>]</span> <span class='operator'>{</span><span class='symbol'>paginas</span><span class='operator'>...</span><span class='operator'>}</span><span class='operator'>;</span></strong>

	<strong><span class='keyword'>for</span> <span class='operator'>(</span><span class='keyword'>auto</span> <span class='symbol'>pagina</span> <span class='operator'>:</span> <span class='symbol'>paginasArray</span><span class='operator'>)</span> <span class='operator'>{</span></strong>
		<span class='symbol'>std</span><span class='operator'>::</span><span class='symbol'>cout</span> <span class='operator'>&lt;&lt;</span> <span class='string'>"Imprimindo página "</span> <span class='operator'>&lt;&lt;</span> <span class='symbol'>pagina</span> <span class='operator'>&lt;&lt;</span> <span class='symbol'>std</span><span class='operator'>::</span><span class='symbol'>endl</span><span class='operator'>;</span>
	<strong><span class='operator'>}</span></strong>

<strong><span class='operator'>}</span></strong>

<span class='symbol'>imprimirSimples</span><span class='operator'>(</span><span class='number'>1</span><span class='operator'>,</span> <span class='number'>2</span><span class='operator'>,</span> <span class='number'>5</span><span class='operator'>)</span><span class='operator'>;</span>

<span class='comment lineComment'>// ou com macros não seguras estilo C</span>
<span class='comment lineComment'>// Objective-C tem que fazer igual</span>

<span class='directive'>#include &lt;iostream&gt;</span>
<strong><span class='directive'>#include &lt;cstdarg&gt;</span></strong>

<strong><span class='keyword'>void</span> <span class='symbol'>imprimirSimplesMacro</span><span class='operator'>(</span></strong><span class='keyword'>const</span> <span class='type'>std::string</span> <span class='symbol'>titulo</span><span class='operator'>,</span> <strong><span class='operator'>...</span><span class='operator'>)</span> <span class='operator'>{</span></strong>

	<span class='comment lineComment'>// va_list argumentos recebe o que vir depois do parâmetro titulo</span>
	<strong><span class='type'>va_list</span> <span class='symbol'>argumentos</span><span class='operator'>;</span></strong>
	<strong><span class='symbol'>va_start</span><span class='operator'>(</span><span class='symbol'>argumentos</span><span class='operator'>,</span> <span class='symbol'>titulo</span><span class='operator'>)</span><span class='operator'>;</span></strong>

	<span class='type'>int</span> <span class='symbol'>pagina</span><span class='operator'>;</span>
	<strong><span class='keyword'>while</span> <span class='operator'>(</span><span class='keyword'>true</span><span class='operator'>)</span> <span class='operator'>{</span></strong>
		<strong><span class='symbol'>pagina</span> <span class='operator'>=</span> <span class='symbol'>va_arg</span><span class='operator'>(</span><span class='symbol'>argumentos</span><span class='operator'>,</span> <span class='type'>int</span><span class='operator'>)</span><span class='operator'>;</span></strong>
		<span class='keyword'>if</span> <span class='operator'>(</span><span class='symbol'>pagina</span> <span class='operator'>==</span> <span class='number'>-1</span><span class='operator'>)</span> <span class='operator'>{</span>
			<span class='keyword'>break</span><span class='operator'>;</span>
		<span class='operator'>}</span>
		<span class='symbol'>std</span><span class='operator'>::</span><span class='symbol'>cout</span> <span class='operator'>&lt;&lt;</span> <span class='string'>"Imprimindo "</span> <span class='operator'>&lt;&lt;</span> <span class='symbol'>pagina</span> <span class='operator'>&lt;&lt;</span> <span class='symbol'>std</span><span class='operator'>::</span><span class='symbol'>endl</span><span class='operator'>;</span>
	<strong><span class='operator'>}</span></strong>

	<strong><span class='symbol'>va_end</span><span class='operator'>(</span><span class='symbol'>argumentos</span><span class='operator'>)</span><span class='operator'>;</span></strong>

<strong><span class='operator'>}</span></strong>

<span class='comment lineComment'>// preciso sempre passar -1 no final como terminador</span>
<span class='comment lineComment'>// se não dá overflow e lê pedaço de memória além do que deveria</span>
<span class='symbol'>imprimirSimplesMacro</span><span class='operator'>(</span><span class='string'>"resumo"</span><span class='operator'>,</span> <span class='number'>1</span><span class='operator'>,</span> <span class='number'>2</span><span class='operator'>,</span> <span class='number'>5</span><span class='operator'>,</span> <span class='number'>-1</span><span class='operator'>)</span><span class='operator'>;</span>

<strong class='comment'><span class='comment lineComment'>// argumentos de todos os tipos</span></strong>

<span class='directive'>#include &lt;iostream&gt;</span>
<span class='directive'>#include &lt;boost/range/irange.hpp&gt;</span>

<span class='comment lineComment'>/// imprimirHelper template genérico</span>
<span class='keyword'>template</span><span class='operator'>&lt;</span><span class='keyword'>typename</span> <span class='type'>T</span><span class='operator'>&gt;</span>
<span class='keyword'>void</span> <span class='symbol'>imprimirHelper</span><span class='operator'>(</span><span class='type'>T</span> <span class='symbol'>pagina</span><span class='operator'>)</span> <span class='operator'>{</span>
	<span class='comment lineComment'>// poderia usar a linha abaixo para descobrir o tipo de T</span>
	<span class='comment lineComment'>// porém, melhor usar o template especializado</span>
	<span class='comment lineComment'>// if (std::is_same&lt;T, int&gt;::value) { /* ... */ }  // optimizable...</span>
	<span class='symbol'>std</span><span class='operator'>::</span><span class='symbol'>cout</span> <span class='operator'>&lt;&lt;</span> <span class='string'>"Imprimindo outra coisa"</span> <span class='operator'>&lt;&lt;</span> <span class='symbol'>std</span><span class='operator'>::</span><span class='symbol'>endl</span><span class='operator'>;</span>
<span class='operator'>}</span>

<span class='comment lineComment'>/// imprimirHelper template especializado para int</span>
<span class='keyword'>template</span><span class='operator'>&lt;&gt;</span>
<span class='keyword'>void</span> <span class='symbol'>imprimirHelper</span><span class='operator'>&lt;</span><span class='type'>int</span><span class='operator'>&gt;</span><span class='operator'>(</span><span class='type'>int</span> <span class='symbol'>pagina</span><span class='operator'>)</span> <span class='operator'>{</span>
	<span class='symbol'>std</span><span class='operator'>::</span><span class='symbol'>cout</span> <span class='operator'>&lt;&lt;</span> <span class='string'>"Imprimindo página "</span> <span class='operator'>&lt;&lt;</span> <span class='symbol'>pagina</span> <span class='operator'>&lt;&lt;</span> <span class='symbol'>std</span><span class='operator'>::</span><span class='symbol'>endl</span><span class='operator'>;</span>
<span class='operator'>}</span>

<span class='comment lineComment'>/// imprimirHelper template especializado para boost::irange</span>
<span class='keyword'>template</span><span class='operator'>&lt;&gt;</span>
<span class='keyword'>void</span> <span class='symbol'>imprimirHelper</span><span class='operator'>&lt;</span><span class='type'>boost::irange</span><span class='operator'>&gt;</span><span class='operator'>(</span><span class='type'>boost::irange</span> <span class='symbol'>faixa</span><span class='operator'>)</span> <span class='operator'>{</span>
	<span class='symbol'>std</span><span class='operator'>::</span><span class='symbol'>cout</span> <span class='operator'>&lt;&lt;</span> <span class='string'>"Imprimindo página "</span> <span class='operator'>&lt;&lt;</span> <span class='symbol'>std</span><span class='operator'>::</span><span class='symbol'>begin</span><span class='operator'>(</span><span class='symbol'>faixa</span><span class='operator'>)</span> <span class='operator'>&lt;&lt;</span> <span class='string'>" até "</span> <span class='operator'>&lt;&lt;</span> <span class='symbol'>std</span><span class='operator'>::</span><span class='symbol'>end</span><span class='operator'>(</span><span class='symbol'>faixa</span><span class='operator'>)</span> <span class='operator'>&lt;&lt;</span> <span class='symbol'>std</span><span class='operator'>::</span><span class='symbol'>endl</span><span class='operator'>;</span>
<span class='operator'>}</span>


<span class='comment lineComment'>// foward declaration imprimir template?? Não estou certo da função disso :/</span>
<span class='keyword'>void</span> <span class='symbol'>imprimir</span><span class='operator'>(</span><span class='type'>std::string</span> <span class='symbol'>titulo</span><span class='operator'>)</span> <span class='operator'>{}</span>

<span class='comment lineComment'>// implementação imprimir template</span>
<strong><span class='keyword'>template</span><span class='operator'>&lt;</span><span class='keyword'>typename</span> <span class='type'>Tipo</span><span class='operator'>,</span> <span class='keyword'>typename</span><span class='operator'>...</span> <span class='type'>Tipos</span><span class='operator'>&gt;</span></strong>
<strong class='small'><span class='keyword'>void</span> <span class='symbol'>imprimir</span><span class='operator'>(</span></strong><span class='type'>std::string</span> <span class='symbol'>titulo</span><span class='operator'>,</span> <strong class='small'><span class='type'>Tipo</span> <span class='symbol'>pagina</span><span class='operator'>,</span> <span class='type'>Tipos</span><span class='operator'>...</span> <span class='symbol'>paginas</span><span class='operator'>)</span> <span class='operator'>{</span></strong>
	<strong class='comment'><span class='comment lineComment'>// executa o helper especializado e chama recursivamente a si mesmo</span></strong>
	<span class='symbol'>imprimirHelper</span><span class='operator'>(</span><span class='symbol'>pagina</span><span class='operator'>)</span><span class='operator'>;</span>
	<span class='symbol'>imprimir</span><span class='operator'>(</span><span class='symbol'>titulo</span><span class='operator'>,</span> <span class='symbol'>paginas</span><span class='operator'>...</span><span class='operator'>)</span><span class='operator'>;</span>
<strong><span class='operator'>}</span></strong>

<span class='symbol'>imprimir</span><span class='operator'>&lt;</span><span class='type'>int</span><span class='operator'>,</span> <span class='type'>boost::irange</span><span class='operator'>,</span> <span class='type'>std::string</span><span class='operator'>&gt;</span><span class='operator'>(</span><span class='string'>"resumo"</span><span class='operator'>,</span> <span class='number'>1</span><span class='operator'>,</span> <span class='symbol'>boost::irange</span><span class='operator'>(</span><span class='number'>2</span><span class='operator'>,</span> <span class='number'>5</span><span class='operator'>)</span><span class='operator'>,</span> <span class='string'>"capítulo 2"</span><span class='operator'>)</span><span class='operator'>;</span></code
>
</div>

<p>A forma em JavaScript é bastante parecida com a maioria. Note que não existe nenhum auxilio nativo para criar ranges, como nos outros exemplos. Optei por usar um objeto simples apenas para demonstrar a sintaxe.</p>

<div class='codeblock'>
<p>funções variádicas em JavaScript com operador rest operator</p>
<code class='javascript'
>'use strict';

// funções variádicas em JavaScript com operador rest

<strong>// argumentos do mesmo tipo</strong>

<strong>function imprimirSimples(</strong>titulo, <strong>...paginas) {</strong>
	<strong>for (let pagina of paginas) {</strong>
		console.log(`Imprimindo página ${pagina}`);
	<strong>}</strong>
<strong>}</strong>

imprimirSimples("resumo", 1, 2, 5);

<strong>// argumentos de todos os tipos</strong>

function imprimir(titulo, <strong>...valores</strong>) {
	for (let valor of valores) {
		<strong>if</strong> (<strong>Number.isInteger(valor)</strong>) {
			console.log(`Imprimindo página ${valor}`);
		} else <strong>if</strong> (<strong>(valor.begin || valor.begin === 0)</strong>
			<strong>&amp;&amp; valor.end</strong>
			) {
			console.log(`Imprimindo páginas ${valor.begin} até ${valor.end}`);
		} <strong>else</strong> {
			console.log('Imprimindo outra coisa');
		}
	}
}

imprimir("resumo", 1, {begin: 2, end: 5}, "capítulo 2");</code
>
</div>

<p>O operador rest também é útil quando utilizado em conjunto com <em>template strings,</em> permitindo recursos mais avançados na manipulação do <em>template</em>.</p>

<div class='codeblock'>
<p>misturando funções, template strings e arrays</p>
<code class='javascript'
>'use strict';

function template(strings, ...values) {

	// as strings são recebidas nornalmente através do primeiro argumento
	strings[0]; // a soma de
	strings[1]; // com
	strings[2]; // resulta em
	strings[3]; // .

	// os valores são agrupados numa array através do operador rest
	values[0]; // 1
	values[1]; // 2
	values[2]; // 3, que é a soma de valor1 e valor2

	// é possível retornar qualquer coisa, string, função, objeto, etc.

}

const valor1 = 1;
const valor2 = 2;

template<span style='display: none;'>+</span> `a soma de ${valor1} com ${valor2} resulta em ${valor1 + valor2}.`;</code
>
</div>

</section>



<section>

<h2 id='objetos'>Como declarar objetos <span>Se vc já achou as variáveis confusas...</span></h2>

<p>Foram feitas várias tentativas até chegarmos a sintaxe atual para declararmos objetos. Espero que não adicionem nenhuma nova sinceramente. Se vc precisar, incluo também as antigas como referência.</p>

<h3 id='object'>Object</h3>

<p>Já estivemos utilizando o objeto <code class='javascript'>console</code>, que o navegador nos fornece. Além disso, os tipos de variáveis que vimos também são objetos, pois conseguimos chamar métodos deles como <code class='javascript'>toFixed</code> ou <code class='javascript'>filter</code>. Ou seja, estivemos escrevendo JavaScript orientado à objeto desde o começo! Mais um motivo pra não usar <code class='javascript'>alert</code>.</p>

<div class='codeblock'>
<p>código</p>
<code class='javascript'
>console.log('console é um objeto. log é um método');</code
>
</div>

<p>JavaScript é bastante diferente de outras linguagens quanto à criação de objetos novos. <strong>Vamos nos ater ao básico por enquanto. Declaramos um objeto usando <code class='javascript'>{}</code>. Sim, um objeto literal. Não é necessário criarmos uma definição de objeto de antemão</strong> (como uma <code class='generic'><span class='keyword'>class</span></code> ou <code class='generic'><span class='keyword'>struct</span></code>), criamos o objeto diretamente.</p>
<p>Acessamos as propriedades e métodos usando ponto, como fazemos com <code class='javascript'>console</code>. Por conveniência, também existe a possibilidade de acessá-las usando a <strong>notação de <code class='javascript'>Array</code>.</strong> Esta notação é útil quando queremos passar o <strong>nome do campo dinamicamente.</strong></p>

<p>Propriedades pode ter atributosr <em>writable, enumerable</em> e <em>configurable</em>, indicando que podem ser escritas, que são mostradas em laços <code class='javascript'>for in</code> e seus atributos podem ser modificados ou não, respectivamente.</p>

<p>Da maneira abaixo, todas as propriedades e métodos são públicos. Se você mal pode esperar pra saber <a href='#proxyNativo'>como definir campos privados,</a> fique à vontade para ir e voltar.</p>

<div class='codeblock'>
<p>declaração de objetos com propriedades e métodos públicos</p>
<code class='javascript'
>'use strict';

let objetoVazio = {};

const retangulo = {

	// define os métodos do objeto
	area() { // nas versões ES5- tinha que escrever area: function() {
		return this.largura * this.altura;
	},

	// define as propriedades e valores padrão
	largura: 1,
	altura: 1

};

// o objeto já está construído
// já podemos chamar seus métodos e especificar valores para suas propriedades
// todas as propriedades são writable, configurable e enumerable

retangulo.largura = 2;
console.log(retangulo.altura); // mostra 1
console.log(retangulo['altura']); // notação de Array, mostra 1
let propriedade = 'largura';
console.log(retangulo[propriedade]); // notação de Array, mostra 2
console.log(retangulo.area()); // mostra 2

{}.hasOwnProperty('prototype'); // retorna true</code
>
</div>

<p>Existe também uma <strong>sintaxe mais parecida</strong> com a de outras linguagens, utilizando a palavra-chave <code class='javascript'>class</code>, para facilitar a criação de objetos similares. Notem que é uma tentativa de mostrar um ambiente mais familiar a programadores de outras linguagens, uma vez que <strong>JavaScript não possui classes</strong> de verdade, seu <strong>modelo de herança é baseado em protótipos,</strong> onde um objeto herda diretamente de outro objeto. Explico mais detalhadamente os <a href='#herancaprototipo'>problemas que isso pode trazer</a> na parte de OOP.</p>
<p>Note novamente que no exemplo abaixo os campos e métodos <strong>continuam sendo todos públicos.</strong></p>

<div class='codeblock'>
<p>declaração de objetos com getters e setters</p>
<code class='javascript'
>'use strict';

class Retangulo {

	// construtor

	constructor(largura, altura) {

		// define as propriedades e seus valores iniciais
		// defineProperties nos dá controle sobre os atributos writable, configurable e enumerable
		// se não especificados, o padrão é false
		Object.defineProperties(this, {
			_largura: {value: largura, writable: true},
			_altura: {value: altura, writable: true}
		});

		Object.seal(this); // mais sobre isso na parte de OOP

	}

	// métodos
	// diferente da sintaxe de objeto, os métodos aqui não são enumerable por padrão

	area() {
		return this.largura * this.altura;
	}

	// getters e setters

	get largura() {
		return this._largura;
	}

	set largura(largura) {
		this._largura = largura;
	}

	get altura() {
		return this._altura;
	}

	set altura(largura) {
		this._altura = altura;
	}

}

// cria um objeto que herda de Retangulo
const retangulo = new Retangulo(10, 20);
console.log(retangulo.largura); // mostra 10
console.log(retangulo.area()); // mostra 200
console.log(retangulo['largura']); // mostra 10</code
>
</div>


<h3 id='legacyobject'>Objetos antigos</h3>

<p>Como mencionei, JavaScript teve <strong>outras sintaxes</strong> para criar objetos, que ainda são suportadas até hoje, porém <strong>não mais recomendadas.</strong> A alternativa vigente antes da sintaxe de classes utilizava o método <code class='javascript'>Object.create</code>. Esta maneira de criar objetos expunha o método de herança que JavaScript usa, baseado em protótipos.</p>

<div class='codeblock'>
<p>declaração de objetos com getters e setters</p>
<code class='javascript'
>'use strict';

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

// cria um objeto que herda de Object para servir como base
const retangulo = Object.create(Object.prototype, {

	// método qualquer usado para inicializar o objeto
	// a prática comum é chamà-lo de init
	// é quase como um construtor, mas esta sintaxe não necessita de construtores
	// o objeto já é usável antes de chamar init
	init: {
		value: function(largura, altura) {
			this.largura = largura;
			this.altura = altura;
		},
		writable: false
	},

	<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

	// define os métodos
	area: {
		value: function() {
			return this.largura * this.altura;
		},
		writable: false
	},

	<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

	// define os getters e setters

	largura: {
		get: function() {
			return this._largura;
		},
		set: function(largura) {
			this._largura = largura;
		}
	},

	<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

	altura: {
		get: function() {
			return this._altura;
		},
		set: function(altura) {
			this._altura = altura;
		}
	},

	<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

	// define as propriedades

	largura: {
		value: 0,
		writable: true
	},

	altura: {
		value: 0,
		writable: true
	},

});

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

// cria uma instância de retangulo
const meuRetangulo = Object.create(retangulo);
meuRetangulo.init(10, 20);
Object.seal(meuRetangulo);

// cria outra instância de retangulo
const outroRetangulo = Object.create(retangulo);
outroRetangulo.init(15, 17);
Object.seal(outroRetangulo);

console.log(outroRetangulo.largura); // mostra 15
console.log(outroRetangulo.area()); // mostra 255
console.log(outroRetangulo['largura']); // mostra 17</code
>
</div>

<p>Existe <strong>ainda outra sintaxe</strong> para criar objetos, que foi a <strong>primeira disponibilizada.</strong> Ela utiliza funções e a palavra-chave <code class='javascript'>new</code>. Assim como com <code class='javascript'>class</code>, foi uma tentativa de não causar estranheza aos programadores vindos de outras linguagens, <strong>simulando</strong> o comportamento que eles já estavam acostumados nas linguagens baseadas em classes. Novamente, isso <strong>escondia o verdadeiro funcionamento</strong> dos objetos em JavaScript. <a rel='external nofollow' href='http://javascript.crockford.com/'>Douglas Crockford</a>, que é um guru e um dos redatores da linguagem <strong>não recomenda</strong> a utilização desta sintaxe antiga. Vou mostrar apenas a título de curiosidade uma das variantes da sintaxe antiga.</p>

<p>Outra desvantagem deste método é ter que se lembrar de declarar os métodos no protótipo do objeto, sendo que as propriedades são declaradas diretamente dentro do construtor. As sintaxes mais novas são mais uniformes quanto à isso.</p>

<div class='codeblock'>
<p>declaração de objetos com sintaxe antiga, não use!</p>
<code class='javascript'
>'use strict';

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

const objetoVazio = new Object();

// define o objeto base
function Retangulo(largura, altura) {
	// define as propriedades e valores padrão
	this.largura = largura;
	this.altura = altura;
}

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

// define os métodos do objeto
Retangulo.prototype.area = function() {
	return this.largura * this.altura;
};

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

// cria uma instância de retangulo
const meuRetangulo = new Retangulo(10, 20);

// cria outra instância de retangulo
const outroRetangulo = new Retangulo(15, 17);

console.log(outroRetangulo.largura); // mostra 15
console.log(outroRetangulo.area()); // mostra 255
console.log(outroRetangulo['largura']); // mostra 17</code
>
</div>

<h3 id='for'>Os muitos laços for</h3>

<p>Além do laço <code class='javascript'>for</code> clássico presente em outras linguagens, existem duas outras formas de iteração rápida pelas propriedades de um objeto. A mais recente delas, <code class='javascript'>for of</code> funciona de maneira similar ao <code class='generic'><span class='keyword'>foreach</span></code> ou <code class='generic'><span class='keyword'>for</span> <span class='operator'>:</span></code> de outras linguagens. Ele irá iterar pelos índices de uma <code>Array</code> ou pelas propriedades expostas por um objeto que implemente <code class='javascript'>[Symbol.iterator]</code>.Estas são as duas maneiras recomendadas de realizar este tipo de iteração.</p>

<div class='codeblock'>
<p>tipos de laços for</p>
<code class='javascript'
>'use strict';

const lala = [1, 2, 486];

// nova, também suporta <a href='#generator'>iterators</a>
<strong>for</strong> (let propriedade <strong>of</strong> lala) {
	// 1, 2, 486
}

// clássica manual
<strong>for</strong> (<strong>let i = 0; i &lt; lala.length; i++</strong>) {
	// 1, 2, 486
}</code
>
</div>

<p>A outra forma, intermediária, possui comportamento mais complexo e inconsistente, e portanto não se tornou muito popular. Ela itera não só pelos índices da <code class='javascript'>Array</code>, mas também pelas propriedades dela e de seus protótipos. Para evitar este comportamento indesejado, é necessário incluir uma verificacão extra dentro do laço. Porém, a ordem de iteração não é garantida, e não há meios de reparar isso.</p>

<div class='codeblock'>
<p>tipos de laços for</p>
<code class='javascript'
>'use strict';

const lala = [1, 2, 486];

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!</strong>

// zoada
<strong>for</strong> (let propriedade <strong>in</strong> lala) {
	<strong>if</strong> (lala<strong>.hasOwnProperty</strong>(propriedade)) {
		// qualquer ordem é válida segundo a especificação
	}
}</code
>
</div>

<p>As <em>arrays</em> contam ainda com mais uma opção, que é o método <code class='javascript'>forEach</code>, e que pode estar presente mesmo em navegadores que não suportam <code class='javascript'>for of</code>. A desvantagem dessa abordagem é que a iteração não pode ser interrompida pela instrução <code class='javascript'>break</code>.</p>

<div class='codeblock'>
<p>tipos de laços for</p>
<code class='javascript'
>'use strict';

const lala = [1, 2, 486];

lala<strong>.forEach((currentValue, index, array) => {</strong>
	// 1, 2, 486
	// sem a possibilidade de usar break :(
<strong>});</strong></code
>
</div>

</section>



<section>

<h2>Ado, a ado, cada um no seu quadrado</h2>

<p>Quando eu escrevi esse título originalmente, era começo de 2014 e essa música era menos trash, mas não muito :P</p>

<h3 id='escopo'>Escopo das variáveis</h3>

<p>Lá no começo disse que haviam duas maneiras de declarar uma variável, a mais recente, usando <code class='javascript'>let</code> e a mais antiga usando <code class='javascript'>var</code>. Agora é o momento de vermos suas diferenças, as pegadinhas e boas práticas.</p>

<p><strong>Dependendo da palavra-chave</strong> que você utiliza, a variável obedecerá <strong>regras de escopo diferentes</strong>. Não conheço nenhuma outra linguagem que tenha essa característica. O motivo disto ter sido feito desta maneira em JavaScript é que a introdução de <code class='javascript'>let</code> foi um puxadinho feito depois na linguagem, para não quebrar a compatibilidade com códigos já existentes que utilizavam <code class='javascript'>var</code>.

<p>Primeiro, o comportamento de <code class='javascript'>let</code>.</p>

<div class='codeblock'>
<p>escopo de variáveis let</p>
<code class='javascript'
>'use strict';

let todosVe = '\o/';
let i = 0;

for (i = 0; i &lt; 5; i++) {
	//
}

console.log(i); // 5

<strong>for (let dentroDoFor</strong> = 0; dentroDoFor &lt; 7; dentroDoFor++<strong>)</strong> {
	//
}

console.<strong>log(dentroDoFor);</strong> <strong>// ReferenceError, dentroDoFor não está definido</strong>

<strong>if</strong> (i &gt; 0) <strong>{</strong>
	<strong>let dentroDoIf</strong> = true;
<strong>}</strong>

console.<strong>log(dentroDoIf);</strong> <strong>// ReferenceError, dentroDoIf não está definido</strong></code
>
</div>

<p>Nada de muito extraordinário aqui certo? O comportamento é <strong>similar ao de outras linguagens.</strong> Mas <code class='javascript'>let</code> <strong>nem sempre esteve disponível</strong> nos navegadores, então precisamos ver a alternativa legada.</p>

<p>Para <code class='javascript'>var</code>, o <strong>único</strong> delimitador de escopo é a função. Variáveis fora de funções estão no espaço global, e variáveis declaradas em <strong>blocos <code class='javascript'>script</code> ou arquivos diferentes compartilham o mesmo espaço global.</strong> Isso foi feito assim porque o programador original da linguagem não tinha tempo de fazer um <em>linker</em>.</p>

<div class='codeblock'>
<p>escopo de variáveis var</p>
<code class='javascript'
>'use strict';

var todosVe = '\o/';
var i = 0;

for (i = 0; i &lt; 5; i++) {
	//
}

console.log(i); // 5

<strong>for (var dentroDoFor</strong> = 0; dentroDoFor &lt; 7; dentroDoFor++<strong>)</strong> {
	//
}

console.<strong>log(dentroDoFor);</strong> <strong>// 7. Surpresa. dentroDoFor foi declarado no espaço global.</strong>

<strong>if</strong> (i &gt; 0) <strong>{</strong>
	<strong>var dentroDoIf</strong> = true;
<strong>}</strong>

console.<strong>log(dentroDoIf);</strong> <strong>// true. Mais surpresa.</strong></code
>
</div>

<p>Este é <strong>um dos motivos</strong> pelos quais declaramos todas as varíaveis no <strong>topo do arquivo ou no começo da função.</strong> De qualquer maneira, vamos ver como resolver parte desse problema quando abordarmos <a href='#closures'><em>closures</em></a>.</p>

<h3 id='hoisting'>Variable Hoisting</h3>

<p>Outro motivo para se <strong>declarar as variáveis no começo do escopo</strong> é uma característica do compilador JavaScript, chamada <em>variable hoisting</em>.</p>
<p>O que isso significa é que, <strong>apenas para variáveis declaradas com <code class='javascript'>var</code></strong>,<strong>independente</strong> de onde você declarar sua variável, o compilador vai <strong>mover a declaração de forma transparente</strong> para o topo do escopo e deixá-la com valor <code class='javascript'>undefined</code>. A linha onde um valor é atribuído à variável não é afetada. Isso pode causar problemas se o código depender de uma verificação da existência da variável. Isso não ocorre para variáveis declaradas com <code class='javascript'>let</code>.</p>

<div class='codeblock'>
<p>variable hoisting</p>
<code class='javascript'
>'use strict';

// o que vc escreveu

console.log(estranha); // mostra undefined e continua normalmente
var estranha = 11;
console.log(estranha); // mostra 11</code
>
</div>

<p>Ou seja, o que o compilador vai fazer de modo transparente é:</p>

<div class='codeblock'>
<p>variable hoisting explicado</p>
<code class='javascript'
>'use strict';

// o que o compilador vê

var estranha; // o compilador moveu a declaracão que usa var (let não é afetado), para o topo do arquivo
console.log(estranha);
estranha = 11; // e manteve a atribução do valor na mesma linha
console.log(estranha);</code
>
</div>

<h3 id='funcaoanonimaescopo'>Módulos simples</h3>

<p>Se quisermos evitar poluir o espaço global, temos que usar uma <strong>função anônima (lambda) autoexecutável</strong>. Projetos de aplicativos windows 8 escritos em JavaScript já utilizam por padrão esse procedimento.</p>

<p>Vamos ver primeiramente um exemplo em que nada entra nem sai do escopo, pois é mais simples de entender.</p>

<div class='codeblock'>
<p>função anônima autoexecutável definindo escopo</p>
<code class='javascript'
>(() =&gt; {
	var segredo = '******';
})();
console.log(segredo); // lança exceção

// ou

(function(){
	var segredo = '******';
})();
console.log(segredo); // undefined em navegadores mais antigos ou lança exceção se modo estrito ou em navegadores novos</code
>
</div>

<p>Para memorizar isso eu geralmente escrevo assim:</p>

<p>Declaro a função.</p>
<div class='codeblock'>
<code class='javascript'
><strong>() =&gt; {</strong> /**/ <strong>}</strong>
// ou
<strong>function(){</strong> /**/ <strong>}</strong></code
>
</div>

<p>Transformo ela em expressão como vimos lá na parte sobre funções.</p>
<div class='codeblock'>
<code class='javascript'
><strong>(</strong> () =&gt; { /**/ } <strong>)</strong>;
// ou
<strong>(</strong> function(){ /**/ } <strong>)</strong>;</code
>
</div>

<p>Executo ela.</p>
<div class='codeblock'>
<code class='javascript'
>(() =&gt; { /**/ })<strong>();</strong>
// ou
(function(){ /**/ })<strong>();</strong></code
>
</div>

<h3 id='closures'>Closures</h3>

<p>Resumidamente, uma <em>closure</em> é uma função mais seu contexto, isto é, as variáveis que ela consegue acessar (ou captura se você preferir) presentes no escopo em que ela foi criada. Essa definição não diz muito sobre as consequências dessa funcionalidade, então vamos desenvolver essa ideia em código em algumas etapas.</p>

<h4>Colocando coisas dentro do escopo e <em>type aliasing</em></h4>

<p>Estamos prontos para complicar um pouquinho mais os exemplos de módulos simples acima, <strong>passando valores para dentro do escopo.</strong> É bem comum fazer isso em conjunto com jQuery. Note que esse padrão também permite que nós habilitemos o modo estrito num determinado escopo.</p>

<p>Mas para não no embolarmos na sintaxe necessária para isso, que quase lembra Lisp, vamos fazer antes um pequeno exercício mental antes sobre funções e nomes de parâmetros.</p>

<div class='codeblock'>
<p>nomes de parâmetros</p>
<code class='javascript'
>'use strict';

// a função "mostrar" não conhece os nomes das variáveis que são passadas para ela
// tudo o que ela sabe é que ela pode acessá-los genericamente chamando-os de "numero"
function mostrar(numero) {
	console.log(numero);
}

const um = 1;
const dois = 2;
const tres = 3;

// ou seja, as variáveis "um", "dois" e "tres" são referenciadas temporariamente
// como "numero" na execução da função, como consequência do funcionamento normal
// da programação que escrevemos
mostrar(um);
mostrar(dois);
mostrar(tres);</code
>
</div>

<p>Este ocorrido da mudança de nomes possui um segundo uso menos frequente, que é o de podermos atribuir <em>aliases</em> (outros nomes) às nossas variáveis. De maneira genérica, temos:</p>

<div class='codeblock'>
<p>nomes de parâmetros</p>
<code class='javascript'
>'use strict';

function cabineTelefonica(superHomem) {
	// superHomem é o nome que damos ao parâmetro passado para esta função
	// se chamarmos esta função passando clarkKent como parâmetro
	// dentro dela podemos chamar clarkKent pelo nome de superHomem
	// referenciamos o mesmo objeto por dois nomes distintos
}

let clarkKent = '\o/';

cabineTelefonica(clarkKent);</code
>
</div>

<p>Estamos acostumados a fazer isso frequentemente quando programamos com a sintaxe acima. Outra maneira seria usando a sintaxe de flecha.</p>

<div class='codeblock'>
<p>nomes de parâmetros</p>
<code class='javascript'
>'use strict';

const cabineTelefonica = (superHomem) => {
	// mesma coisa que o exemplo acima, porém usando a sintaxe de flecha
};

let clarkKent = '\o/';

cabineTelefonica(clarkKent);</code
>
</div>

<p>E finalmente, usando uma função anônima autoexecutável.</p>

<div class='codeblock'>
<p>nomes de parâmetros</p>
<code class='javascript'
>'use strict';

let clarkKent = '\o/';

((superHomem) => {
	// mesma coisa que os exemplos anteriores
	// chamamos esta função passando clarkKent como parâmetro
	// e chamamos esse parâmetro de superHomem enquanto estivermos dentro do escopo da função
})(clarkKent);</code
>
</div>

<p>Vejamos então o exemplo completo envolvendo jQuery.</p>

<div class='codeblock'>
<p>função anônima autoexecutável com parâmetros</p>
<code class='javascript'
><strong>// noConflict() determina que não vamos usar jQuery com $ globalmente</strong>
<strong>// vamos referenciá-los apenas por jQuery para evitar colisões com outras</strong>
<strong>// bibliotecas que eventualmente usem $ também</strong>
<strong class='small'>jQuery.noConflict();</strong>

// criamos um escopo através de um lambda
// indicamos que esse lambda vai receber um parâmetro, e que vamos chamá-lo de $
(($) =&gt; {
	'use strict'; // habilita modo estrito só para este escopo

	// podemos usar jQuery como $ aqui dentro sem interferir com o espaço global que continua usando jQuery
	$('body').html('&lt;p&gt;padrão para plug-ins jQuery&lt;/p&gt;');

})(jQuery); // executamos o lambda, passando jQuery como parâmetro

console.log($); // ReferenceError, $ está definido apenas dentro do escopo definido pelo lambda</code
>
</div>

<div class='codeblock'>
<p>função anônima autoexecutável com parâmetros</p>
<code class='javascript'
>// noConflict() determina que não vamos usar jQuery com $ globalmente
// vamos referenciá-los apenas por jQuery para evitar colisões com outras
// bibliotecas que eventualmente usem $ também
jQuery.noConflict();

<strong>// criamos um escopo através de um lambda</strong>
<strong>// indicamos que esse lambda vai receber um parâmetro, e que vamos chamá-lo de $</strong>
<strong class='small'>(($) =&gt; {</strong>
	'use strict'; // habilita modo estrito só para este escopo

	// podemos usar jQuery como $ aqui dentro sem interferir com o espaço global que continua usando jQuery
	$('body').html('&lt;p&gt;padrão para plug-ins jQuery&lt;/p&gt;');

<strong>})</strong>(jQuery); // executamos o lambda, passando jQuery como parâmetro

console.log($); // ReferenceError, $ está definido apenas dentro do escopo definido pelo lambda</code
>
</div>

<div class='codeblock'>
<p>função anônima autoexecutável com parâmetros</p>
<code class='javascript'
>// noConflict() determina que não vamos usar jQuery com $ globalmente
// vamos referenciá-los apenas por jQuery para evitar colisões com outras
// bibliotecas que eventualmente usem $ também
jQuery.noConflict();

// criamos um escopo através de um lambda
// indicamos que esse lambda vai receber um parâmetro, e que vamos chamá-lo de $
(($) =&gt; {
	'use strict'; // habilita modo estrito só para este escopo

	// podemos usar jQuery como $ aqui dentro sem interferir com o espaço global que continua usando jQuery
	$('body').html('&lt;p&gt;padrão para plug-ins jQuery&lt;/p&gt;');

})<strong>(jQuery);</strong> <strong>// executamos o lambda, passando jQuery como parâmetro</strong>

console.log($); // ReferenceError, $ está definido apenas dentro do escopo definido pelo lambda</code
>
</div>

<div class='codeblock'>
<p>função anônima autoexecutável com parâmetros</p>
<code class='javascript'
>// noConflict() determina que não vamos usar jQuery com $ globalmente
// vamos referenciá-los apenas por jQuery para evitar colisões com outras
// bibliotecas que eventualmente usem $ também
jQuery.noConflict();

// criamos um escopo através de um lambda
// indicamos que esse lambda vai receber um parâmetro, e que vamos chamá-lo de $
(<strong>($)</strong> =&gt; {
	'use strict'; // habilita modo estrito só para este escopo

	<strong>// podemos usar jQuery como $ aqui dentro sem interferir com o espaço global que continua usando jQuery</strong>
	<strong class='small'>$('body').html('&lt;p&gt;padrão para plug-ins jQuery&lt;/p&gt;');</strong>

})<strong>(jQuery);</strong> // executamos o lambda, passando jQuery como parâmetro

console.log($); // ReferenceError, $ está definido apenas dentro do escopo definido pelo lambda</code
>
</div>

<div class='codeblock'>
<p>função anônima autoexecutável com parâmetros</p>
<code class='javascript'
>// noConflict() determina que não vamos usar jQuery com $ globalmente
// vamos referenciá-los apenas por jQuery para evitar colisões com outras
// bibliotecas que eventualmente usem $ também
jQuery.noConflict();

// criamos um escopo através de um lambda
// indicamos que esse lambda vai receber um parâmetro, e que vamos chamá-lo de $
(($) =&gt; {
	'use strict'; // habilita modo estrito só para este escopo

	// podemos usar jQuery como $ aqui dentro sem interferir com o espaço global que continua usando jQuery
	$('body').html('&lt;p&gt;padrão para plug-ins jQuery&lt;/p&gt;');

})(jQuery); // executamos o lambda, passando jQuery como parâmetro

<strong>console.log($);</strong> <strong>// ReferenceError, $ está definido apenas dentro do escopo definido pelo lambda</strong></code
>
</div>

<h4 id='forclosure'>Resolvendo var e corrigindo closures</h4>

<p>Quando passamos objetos para as funções que queremos executar funções, estes objetos são passados por referência. Se passarmos tipos simples como <code class='javascript'>Boolean</code> e <code class='javascript'>Number</code>, eles serão <strong>passados por valor.</strong> Isto é, teremos uma <strong>cópia do valor passado.</strong></p>

<p>Este comportamento costuma ser usado para <strong>resolver problemas que o comportamento de <code class='javascript'>var</code> causa em laços</strong> e outras situações. Por exemplo, vamos revisitar este trecho problemático de código:</p>

<div class='codeblock'>
<p>escopo de variáveis var</p>
<code class='javascript'
>'use strict';

for (var dentroDoFor = 0; dentroDoFor &lt; 7; dentroDoFor++) {
	// executa console.log daqui 100 milissegundos, depois que o laço terminou
	setTimeout(() => { console.log(dentroDoFor); }, 100); // sempre vai ser 7. dentroDoFor foi declarado no espaço global
}

console.log(dentroDoFor); // 7. Surpresa. dentroDoFor foi declarado no espaço global.</code
>
</div>

<p>Neste caso, <strong>criamos inadvertidamente uma <em>closure</em>.</strong> O lambda que passamos para a função <code class='javascript'>setTimeout</code> também é uma função, e seu contexto de criação é tudo o que está no espaço global. Portanto ela captura a variável global <code class='javascript'>dentroDoFor</code>, e a encherga com seu valor atual 7 quando executada.</p>

<p>Caso estejamos num navegador em que seja possível usar <code class='javascript'>let</code>, a correção é bastante simples, pois o uso desta palavra-chave restringe  o escopo de <code class='javascript'>dentroDoFor</code> para cada iteração do laço.</p>

<div class='codeblock'>
<p>escopo de variáveis var</p>
<code class='javascript'
>'use strict';

for (<strong>let dentroDoFor = 0;</strong> dentroDoFor &lt; 7; dentroDoFor++) {
	// executa console.log daqui 100 milissegundos, depois que o laço terminou
	<strong>setTimeout(() => { console.log(dentroDoFor); }, 100);</strong> <strong>// 0, 1, 2... 6 como desejado</strong>
}

console.log(dentroDoFor); // 7. Surpresa. dentroDoFor foi declarado no espaço global.</code
>
</div>

<p>Caso o navegador seja mais antigo e não seja possível o uso de <code class='javascript'>let</code>, ainda podemos corrigir o comportamento indesejado por meio de uma <em>closure</em> da seguinte maneira:</p>

<div class='codeblock'>
<p>resolvendo problemas de escopo de var com closures</p>
<code class='javascript'
>'use strict';

<strong>// dentroDoFor é passado por valor para o escopo que a função forBody cria</strong>
<strong>// ou seja, o escopo recebe uma cópia no momento em que a função foi chamada dentro do laço</strong>
<strong>// dentroDoFor local ofusca dentroDoFor global</strong>
<strong class='small'>function forBody(dentroDoFor) {</strong>
	// executa console.log daqui 100 milissegundos, depois que o laço terminou
	<strong>setTimeout(() => { console.log(dentroDoFor); }, 100);</strong> <strong>// 0, 1, 2... 6 como desejado</strong>
<strong>}</strong>

var i = 0;

<strong>for (</strong>i = 0; i &lt; 8; i++<strong>) {</strong>
	<strong>forBody(i);</strong>
<strong>}</strong>

console.log(i); // ainda é 7, pois i foi declarado no espaço global.
console.log(dentroDoFor); // ReferenceError, dentroDoFor só existe dentro da função forBody</code
>
</div>

<p>O lambda <strong>continua sendo uma closure, mas agora encherga apenas a cópia local da variável <code class='javascript'>dentroDoFor</code>, pois a <strong>variável global foi obfuscada</strong> por utilizar o mesmo nome da local, que tem maior prioridade.</strong> A variável local nunca é incrementada, e o lambda então, se comporta como o esperado.</p>

<p>Não é necessário ofuscar a variável global utilizando o mesmo nome para a variável local. Poderíamos utilizar um nome distinto, desde que garantíssemos que sempre referenciar a variável local pelo nome distinto que escolhemos. Porém, usar o mesmo ajuda a evitar erros.</p>

<h4>Tirando coisas de dentro do escopo</h4>

<p>Agora que vimos o que são closures, vamos aprender mais uma coisa sobre elas. <strong>Se elas forem movidas para fora do seu contexto de criação, permanecem com a habilidade de acessar as variáveis e funções do escopo original.</strong></p>

<div class='codeblock'>
<p>closures</p>
<code class='javascript'
>'use strict';

// cria um escopo
function externa() {

	let informacao = 'wikileaks';

	let interna = function() {
		console.log('vazou ' + informacao);
	}

	return interna; // expõe a função para fora do escopo

}

let dedoDuroInterno = externa(); // dedoDuroInterno é igual à função retornada do escopo, é um alias para ela
dedoDuroInterno(); // expões os segredos dentro do escopo!</code
>
</div>

<p>Essa sintaxe é ótima para ser utilizada com o padrão <em>facade</em>. Ou seja:</p>

<div class='codeblock'>
<p>padrão de projeto facade</p>
<code class='javascript'
>'use strict';

function facade() {
	// criar tudo o que não deve ser acessado diretamente de fora do escopo aqui
	// retornar o objeto ou função que tem permissão para acessar o escopo
	return function() {
		//
	};
}

let acesso = facade();</code
>
</div>

<p>E mais resumidamente, usando o módulo simples que vimos anteriormente:</p>

<div class='codeblock'>
<p>padrão de projeto facade</p>
<code class='javascript'
>'use strict';

let acesso = (function() {
	// criamos tudo o que não deve ser acessado diretamente de fora do escopo aqui
	// retornamos o objeto ou função que tem permissão para acessar o escopo
	// sim, funções anônimas autoexecutáveis podem retornar valores!
	return {};
})();

// ou

let acesso = (() => {
	// mesma coisa que a alternativa acima ;)
	return {};
})();</code
>
</div>

<p>Recapitulando, uma <em>closure</em> é uma função mais o contexto em que foi criada, isto é, as variáveis que ela consegue acessar (ou capturar se você preferir). No caso do problema com o laço <code class='javascript'>for</code>, criamos uma <em>closure</em> sem querer, e então precisamos adicionar uma função a mais para resolver o problema que a <em>closure</em> criou. No caso padrão <em>facade</em> criamos uma <em>closure</em> propositalmente e movemos ela para fora do seu contexto, mantendo o restande dele  privado, podendo ser acessado apenas através da <em>closure</em>.</p>

<h3>Os <q>módulos</q> do jQuery</h3>

<p>O framework jQuery mistura vários dos conceitos apresentados aqui. Ainda não apresentei o conceito de eventos para entendermos todas as partes do jQuery, mas podemos identificar os já vistos no código abaixo.</p>

<div class='codeblock'>
<p>uso simples de jQuery</p>
<code class='javascript'
>'use strict';

jQuery(document).ready((evento) => {
	// escopo isolado, não polui o espaço global
});</code
>
</div>

<p>O primeiro dos conceitos utilizados é que jQuery é uma função. Por isso podemos chamá-la utilizando <code class='javascript'>jQuery()</code>. Esta função sempre retorna uma referência para ela mesma, ou seja, sempre retorna <code class='javascript'>jQuery</code>. Esta organização de código se chama interface fluida. O método recebe como parâmetro um seletor <abbr title='Cascading Style Sheets'>CSS</abbr> ou objeto do <abbr title='Document Object Model'>DOM</abbr>, neste caso o objeto <code class='javascript'>document</code>.</p>

<div class='codeblock'>
<code class='javascript'
><strong>jQuery(document)</strong>.ready((evento) => {
	// escopo isolado, não polui o espaço global
});</code
>
</div>

<p>A seguir temos o método <code class='javascript'>ready</code>, que é chamado quando o evento correspondente é disparado. Por enquanto basta saber que este método só será chamado quando a página estiver pronta para manipulação por JavaScript. Nem tudo que usamos em JavaScript precisa ser colocado dentro deste método. Apenas a parte que irá interagir imediatamente com o DOM. Por exemplo, podemos definir nossas bibliotecas anteriormente num outro local, e só chamá-las dentro de <code class='javascript'>ready</code> quando elas precisarem interagir com o DOM. O motivo disso é performance.</p>

<div class='codeblock'>
<code class='javascript'
>jQuery(document)<strong>.ready(</strong>(evento) => {
	// escopo isolado, não polui o espaço global
}<strong>);</strong></code
>
</div>

<p>Mas se <code class='javascript'>jQuery()</code> sempre retorna outra função <code class='javascript'>jQuery</code>, como acessamos o método <code class='javascript'>ready</code>? Lembre-se em JavaScript funções são objetos, e portanto podem ter propriedades e outros métodos, como o <code class='javascript'>ready</code>.</p>

<p>Por último, passamos ao método <code class='javascript'>ready</code> uma <strong>função anônima</strong> que contém o código que queremos executar. Esta sintaxe <strong>reduz</strong> a quantidade de variáveis e métodos no <strong>espaço global.</strong></p>

<div class='codeblock'>
<code class='javascript'
>jQuery(document).ready(<strong class='small'>(evento) => {</strong>
	<strong>// escopo isolado, não polui o espaço global</strong>
<strong>}</strong>);</code
>
</div>

<h3 id='amd'>Módulos avançados - Padrão AMD</h3>

<p>Como JavaScript escrito sem cuidado pode poluir rapidamente o espaço global, devemos procurar maneiras de evitar a sobrescrita de variáveis. O framework <strong>jQuery pode não ser uma boa alternativa</strong> para uma quantidade maior de código, uma vez que <strong>sempre carrega todos seus <em>plug-ins</em> na memória,</strong> mesmo o que não estiver usando.</p>

<p>Vimos que <strong>funções podem ser usadas para criar escopos nomeados e anônimos,</strong> como nos exemplos de expressões de função e do laço e <code class='javascript'>var</code>, e que essas <strong><q>funções escopo</q> podem receber e retornar valores.</strong> Essas são as bases para chegarmos ao que queremos.</p>

<p>Como os <strong>recursos da linguagem são poucos</strong> para uma organização mais efetiva do código, foi criado um <strong>padrão mais bem acabadinho, amplamente utilizado, inclusive em diversos frameworks, chamado <abbr title='Asynchronous Module Definition'>AMD</abbr>.</strong> Caso você não esteja usando um framework que já possua suporte (como Angular ou Ember), é possível baixar uma biblioteca exclusivamente para isso, chamada <a href='http://requirejs.org/' rel='external nofollow'>RequireJS</a>. Esse padrão é utilizado através de uma função, chamada <code class='javascript'>define</code>, que pode ser utilizada da seguinte maneira:</p>

<div class='codeblock'>
<p>Padrão AMD para definição de escopo</p>
<code class='javascript'
>'use strict';

define('nomeDoModulo', () =&gt; {
	// escopo isolado, não polui o espaço global
	// retornar aqui o valor do módulo
	// isto é, a classe, objeto, função etc.
	// que poderá ser acessada pelo identificador 'nomeDoModulo'
});

define('nomeOpcional', ['nomeDoModulo', 'dependencia2', 'etc'], (nomeDoModulo, dependencia2, etc) =&gt; {
	// escopo isolado, não polui o espaço global
	// podemos utilizar as dependências importadas
});</code
>
</div>

<p>Ou seja, se quisermos criar objetos que possam ser reaproveitados apenas em determinados escopos, fazemos da seguinte maneira:</p>

<div class='codeblock'>
<p>Isolando dependências com AMD</p>
<code class='javascript'
>'use strict';

// cria a classe num escopo isolado
define('MinhaClasse', () =&gt; {

	const MinhaClasse = class MinhaClasse() {
		constructor() { /**/ }
	}

	// lembre-se de sempre retornar um valor do módulo, para que ele seja associado ao identificador
	return MinhaClasse;

});

// cria a função num escopo isolado
define('minhaFuncao', () => {
	const minhaFuncao = function() { /**/ };
	return minhaFuncao;
});

// utiliza a classe importada, optei por não nomear esse módulo
define(['MinhaClasse'], (MinhaClasse) => {
	const meuObjeto = new MinhaClasse(); // Ok
	minhaFuncao(); // Erro, pois não importamos minhaFunção
});</code
>
</div>

<p>A primeira vista isso tudo pode assustar, então vamos ver passo a passo. O método <code class='javascript'>define</code> associa escopos com identificadores.</p>

<div class='codeblock'>
<p>Isolando dependências com AMD</p>
<code class='javascript'
>'use strict';

// cria a classe num escopo isolado
<strong>define('MinhaClasse', () =&gt; {</strong>

	const MinhaClasse = class MinhaClasse() {
		constructor() { /**/ }
	}

	// lembre-se de sempre retornar um valor do módulo, para que ele seja associado ao identificador
	return MinhaClasse;

<strong>});</strong>

// cria a função num escopo isolado
<strong>define('minhaFuncao', () => {</strong>
	const minhaFuncao = function() { /**/ };
	return minhaFuncao;
<strong>});</strong>

// utiliza a classe importada, optei por não nomear esse módulo
define(['MinhaClasse'], (MinhaClasse) => {
	const meuObjeto = new MinhaClasse(); // Ok
	minhaFuncao(); // Erro, pois não importamos minhaFunção
});</code
>
</div>

<p>Retornando valores dentro destes escopos, podemos associá-los ao identificador do escopo.</p>

<div class='codeblock'>
<p>Isolando dependências com AMD</p>
<code class='javascript'
>'use strict';

// cria a classe num escopo isolado
define('MinhaClasse', <strong>() =&gt; {</strong>

	const MinhaClasse = class MinhaClasse() {
		constructor() { /**/ }
	}

	// lembre-se de sempre retornar um valor do módulo, para que ele seja associado ao identificador
	<strong>return MinhaClasse;</strong>

<strong>}</strong>);

// cria a função num escopo isolado
define('minhaFuncao', <strong>() => {</strong>
	const minhaFuncao = function() { /**/ };
	<strong>return minhaFuncao;</strong>
<strong>}</strong>);

// utiliza a classe importada, optei por não nomear esse módulo
define(['MinhaClasse'], (MinhaClasse) => {
	const meuObjeto = new MinhaClasse(); // Ok
	minhaFuncao(); // Erro, pois não importamos minhaFunção
});</code
>
</div>

<p>E então podemos importar estes valores através dos identificadores.</p>

<div class='codeblock'>
<p>Isolando dependências com AMD</p>
<code class='javascript'
>'use strict';

// cria a classe num escopo isolado
define('MinhaClasse', () =&gt; {

	const MinhaClasse = class MinhaClasse() {
		constructor() { /**/ }
	}

	// lembre-se de sempre retornar um valor do módulo, para que ele seja associado ao identificador
	return MinhaClasse;

});

// cria a função num escopo isolado
define('minhaFuncao', () => {
	const minhaFuncao = function() { /**/ };
	return minhaFuncao;
});

// utiliza a classe importada, optei por não nomear esse módulo
<strong>define(['MinhaClasse'], (MinhaClasse) => {</strong>
	const meuObjeto = <strong>new MinhaClasse();</strong>// Ok
	minhaFuncao(); // Erro, pois não importamos minhaFunção
<strong>});</strong></code
>
</div>

<p>O padrão <abbr title='Asynchronous Module Definition'>AMD</abbr> foi formulado para suportar minificação do código fonte, e portanto acaba sendo um pouco redundante.</p>

</section>



<section>

<h2 id='dom'><abbr title='Document Object Model'>DOM</abbr> - El Poderoso Jefón</h2>

<p>Se você leu o capítulo anterior (e deveria), pode ter visto que o IE10- lançou um erro em nosso exemplo simples, quando as ferramentas de desenvolvimento não estavam abertas. Isso ocorre porque nestes navegadores, o objeto <code class='javascript'>console</code>, pertencente ao DOM, não é acessível pelo JavaScript enquanto as ferramentas não estiverem abertas. Vou mostrar mais adiante como corrigir esta <q>funcionalidade</q> do IE10-.</p>

<p>Embora por caminhos tortos, isso nos ensina um conceito importante. O conceito de que <strong>JavaScript e o <abbr title='Document Object Model'>DOM</abbr> são mundos diferentes,</strong> e nem sempre JavaScript consegue acessar tudo do <abbr title='Document Object Model'>DOM</abbr> a toda a hora. Existem <strong>momentos específicos em que isso pode ser feito.</strong></p>

<p>Vamos ver isso e outros conceitos com um segundo exemplo mais complexo.</p>

<div class='codeblock'>
<p>seosoquenao.htm</p>
<code class='html'
>&lt;!DOCTYPE html&gt;
&lt;html
	xmlns='http://www.w3.org/1999/xhtml'
	lang='pt-BR'
	xml:lang='pt-br'
	&gt;

<strong>&lt;head&gt;</strong>
	&lt;title&gt;Google está olhando&lt;/title&gt;
	&lt;meta charset='utf-8' /&gt;
	<strong>&lt;!-- script interrompe a leitura da página e executa imediatamente --&gt;</strong>
	<strong class='small'>&lt;script src='seosoquenao.js'&gt;&lt;/script&gt;</strong>
<strong>&lt;/head&gt;</strong>

<strong>&lt;body&gt;</strong>

	<strong>&lt;h1 id='tagTitulo'&gt;</strong>Acessibilidade e SEO<strong>&lt;/h1&gt;</strong>

	<strong>&lt;p id='tagParagrafo'&gt;</strong>
		Sim pequeno gafanhoto, html tem mais de &lt;strong&gt;100 tags&lt;/strong&gt;
		diferentes além de table e div.
	<strong>&lt;/p&gt;</strong>

<strong>&lt;/body&gt;</strong>

&lt;/html&gt;</code
>
</div>

<div class='codeblock'>
<p>seosoquenao.js</p>
<code class='javascript'
>'use strict';

<strong>// tenta pegar elementos da página Html pela id</strong>
<strong>// e os tornar manipuláveis dentro do JavaScript</strong>
let titulo = document<strong class='small'>.getElementById('tagTitulo');</strong>
let paragrafo = document<strong>.getElementById('tagParagrafo');</strong>

<strong>// titulo e paragrafo são null?!</strong>

titulo.innerHTML = 'Black hat SEO'; //erro
paragrafo.attributes.add('style', 'display: none'); // erro</code
>
</div>

<p>Ao abrir este arquivo diretamente do seu computador, com o console aberto, talvez você note mais erros. Ao abrir este arquivo através de um servidor, mesmo que local, com certeza você notará mais erros.</p>

<p>Porém a programação acima está perfeitamente correta, e o arquivo .htm também. <strong>O problema que ocorre</strong> neste caso não existe em linguagens C e similares, e <strong>se dá quando combinamos os arquivos .htm e .js de uma determinada maneira</strong> que provoca uma interação inadequada entre o JavaScript e o <abbr title='Document Object Model'>DOM</abbr> (Notou a elegância da frase? Ela é ótima para impressionar seu chefe quando vc tiver que explicar pq aquele site está funcionando perfeitamente no seu pc mas quando vc publicou pipocaram erros em todo o lugar).</p>

<p>Lembre-se que JavaScript não possui o conceito de único ponto de entrada (método <code class='c'>main</code>). Quando o navegador encontra uma tag <code class='html'>&lt;script&gt;</code> na página, ele pára de processar o restante do documento, baixa o arquivo js, roda seu conteúdo, e só depois continua o processamento normalmente. Em nosso exemplo, como a tag <code class='html'>&lt;script&gt;</code> está antes do conteúdo, <strong>o navegador carrega e roda a programação antes de tomar ciência do resto do documento.</strong> Nas primeiras linhas de nosso código, estamos pedindo para o navegador pegar determinados elementos na página, mas ele ainda não sabe que esses elementos existem. Isso talvez não ocorra sempre ao abrir o arquivo local devido diferenças que existem ao ler o arquivo diretamente do hd, porém sempre irá acontecer através de um servidor http.</p>

<p>E porque não tivemos esse problema no primeiro exemplo? Porque lá não estávamos acessando nenhum elemento da página. Nunca saímos do mundinho JavaScript para o mundo <abbr title='Document Object Model'>DOM</abbr>.</p>

<p><strong>Podemos corrigir nosso problema de três maneiras pelo menos.</strong></p>

<ol>
	<li>Mover nossa tag <code class='html'>&lt;script&gt;</code> para o final da página, após o conteúdo;</li>
	<li>Pedir para o navegador só executar nossa programação após o carregamento da página, na própria tag;</li>
	<li>Fazer a mesma coisa que a alternativa anterior, mas dentro do código JavaScript.</li>
</ol>

<p>A terceira eu vou deixar pra mais adiante, pois precisaríamos saber o que são eventos. Vamos ver os 2 primeiros casos e explicar o que acontece.</p>

<h3>Solução 1 - Movendo a tag script</h3>

<div class='codeblock'>
<p>seosoquenaoS1.htm</p>
<code class='html'
>&lt;!DOCTYPE html&gt;
&lt;html
	xmlns='http://www.w3.org/1999/xhtml'
	lang='pt-BR'
	xml:lang='pt-br'
	&gt;

&lt;head&gt;
	&lt;title&gt;Google está olhando&lt;/title&gt;
	&lt;meta charset='utf-8' /&gt;
&lt;/head&gt;

<strong>&lt;body&gt;</strong>

	<strong>&lt;h1 id='tagTitulo'&gt;</strong>Acessibilidade e SEO<strong>&lt;/h1&gt;</strong>

	<strong>&lt;p id='tagParagrafo'&gt;</strong>
		Sim pequeno gafanhoto, html tem mais de 100 tags
		diferentes além de table e div.
	<strong>&lt;/p&gt;</strong>

	<strong>&lt;!-- script executa depois que o corpo de body foi lido --&gt;</strong>
	<strong class='small'>&lt;script src='seosoquenao.js'&gt;&lt;/script&gt;</strong>

	<strong>&lt;!--</strong>
	<strong class='comment'>Segura a empolgação, a especificação não permite colocar mais nada</strong>
	<strong class='comment'>depois de &lt;/body&gt; e &lt;/html&gt;. Mas isso nunca é necessário.</strong>
	<strong class='comment'>--&gt;</strong>

<strong>&lt;/body&gt;</strong>

&lt;/html&gt;</code
>
</div>

<p>Essa solução talvez seja a mais simples. Quando o navegador rodar o JavaScript, já vai ter lido todos os elementos da página, e pode pegar qualquer um deles sem problema. A desvantagem deste método é que o navegador não poderá otimizar o download dos arquivos que a página irá usar (baixando em paralelo por exemplo), pois ele só vai saber que precisará deles no final do documento.</p>

<h3 id='defer'>Solução 2 - Postergando a execução na tag</h3>

<div class='codeblock'>
<p>seosoquenaoS2.htm</p>
<code class='html'
>&lt;!DOCTYPE html&gt;
&lt;html
	xmlns='http://www.w3.org/1999/xhtml'
	lang='pt-BR'
	xml:lang='pt-br'
	&gt;

<strong>&lt;head&gt;</strong>
	&lt;title&gt;Google está olhando&lt;/title&gt;
	&lt;meta charset='utf-8' /&gt;
	<strong>&lt;!-- defer faz o script executar depois que toda a página foi lida --&gt;</strong>
	<strong class='small'>&lt;script</strong> src='seosoquenao.js' <strong class='small'>defer&gt;</strong>&lt;/script&gt;
<strong>&lt;/head&gt;</strong>

<strong>&lt;body&gt;</strong>

	<strong>&lt;h1 id='tagTitulo'&gt;</strong>Acessibilidade e SEO<strong>&lt;/h1&gt;</strong>

	<strong>&lt;p id='tagParagrafo'&gt;</strong>
		Sim pequeno gafanhoto, html tem mais de 100 tags
		diferentes além de table e div.
	<strong>&lt;/p&gt;</strong>

<strong>&lt;/body&gt;</strong>

&lt;/html&gt;</code
>
</div>

<p>Essa solução é bastante elegante, porém não é suportada nos IEs mais antigos. Além disso, ela só funciona para arquivos .js externos. Não é possível utilizá-la quando colocamos a programação entre as tags <code class='html'>&lt;script&gt;</code> e <code class='html'>&lt;/script&gt;</code>. Através do atributo <code class='html'>defer</code> da tag, indicamos nosso desejo de executar a programação dentro dela só após o carregamento da página.</p>

<h3>Se familiarizando com a <em>Cosa Nostra</em></h3>

<p>Utilizamos o método <code class='javascript'>document.getElementById</code> para trazer o elemento da página para dentro do nosso código. Esta solução não é a mais antiga para fazermos tal coisa, porém é a <strong>recomendada pela performance e compatibilidade</strong> com os navegadores.</p>

<p>Mas e se precisamos pegar elementos que não possuem id? A API disponibiliza outros métodos que retornam valores diferentes dependendo da sua necessidade, sendo que o último deles, <code class='javascript'>document.querySelectorAll</code> foi inspirado após o surgimento do jQuery.</p>

<div class='codeblock'>
<p>cosanostra.htm</p>
<code class='html'
>&lt;!DOCTYPE html&gt;
&lt;html
	xmlns='http://www.w3.org/1999/xhtml'
	lang='pt-BR'
	xml:lang='pt-br'
	&gt;
&lt;head&gt;
	&lt;title&gt;1001 maneiras de falar com o DOM&lt;/title&gt;
	&lt;meta charset='utf-8' /&gt;
&lt;/head&gt;
<strong>&lt;body&gt;</strong>
	&lt;header&gt;
		&lt;nav&gt;
			<strong>&lt;ul&gt;</strong>
				&lt;li&gt;<strong>&lt;a href='pag1'&gt;link 1&lt;/a&gt;</strong>&lt;/li&gt;
				&lt;li&gt;<strong>&lt;a href='pag2'&gt;link 2&lt;/a&gt;</strong>&lt;/li&gt;
				&lt;li&gt;<strong>&lt;a href='pag3'&gt;link 3&lt;/a&gt;</strong>&lt;/li&gt;
				&lt;li&gt;<strong>&lt;a href='pag4'&gt;link 4&lt;/a&gt;</strong>&lt;/li&gt;
			<strong>&lt;/ul&gt;</strong>
		&lt;/nav&gt;
	&lt;/header&gt;
	...
	&lt;footer&gt;
		&lt;div&gt;Ir para o <strong>&lt;a href='#'&gt;topo&lt;/a&gt;</strong>&lt;/div&gt;
	&lt;/footer&gt;
	<strong>&lt;script src='cosanostra.js'&gt;&lt;/script&gt;</strong>
<strong>&lt;/body&gt;</strong>
&lt;/html&gt;</code
>
</div>

<div class='codeblock'>
<p>cosanostra.js</p>
<code class='javascript'
>'use strict';

<strong>// retorna os links do menu e o ir para o topo</strong>
let links = document<strong class='small'>.getElementsByTagName('a');</strong>

// filtra os links fora da lista
let linksFiltrados = [];
let nodeName;
for (let link of links) {
	nodeName = link.parentNode.nodeName.toLowerCase();
	if (nodeName === 'li') {
		linksFiltrados.push(link);
	}
}

<strong>// retorna os links do menu apenas. ñ funciona em IE8-</strong>
let linksMenu = document<strong class='small'>.querySelectorAll('ul a');</strong>

<strong>// retorna os links do menu apenas.</strong>
<strong>// versões do jQuery 1.10.x funcionam em todos os navegadores</strong>
let linksMenuJ = <strong class='small'>jQuery('ul a');</strong></code
>
</div>

<p>Notem que cada chamada de método para trazer um elemento do <abbr title='Document Object Model'>DOM</abbr> para dentro do JavaScript leva um certo tempo para realizar esta operação. Por motivos de <strong>performance,</strong> devemos sempre que possível <strong>guardar a referência</strong> para estes elementos e reutilizá-la, ao invés de chamar continuamente métodos que busquem no <abbr title='Document Object Model'>DOM</abbr>. Vejam por exemplo este trecho da própria documentação do jQuery UI (<a rel='external nofollow' href='http://jqueryui.com/datepicker/#date-formats'>http://jqueryui.com/datepicker/#date-formats</a>):</p>

<div class='codeblock'>
<p>interação pobre com o DOM</p>
<code class='javascript'
>'use strict';

<strong>// busca o mesmo item 2x desnecessariamente</strong>
<strong>// buscar coisas no DOM é uma operação despendiosa</strong>
$(function() {
	<strong>$('#datepicker')</strong>.datepicker();
	$('#format').change(function() {
		<strong>$('#datepicker')</strong>.datepicker('option', 'dateFormat', $(this).val());
	});
});</code
>
</div>

<p>Note que o mesmo elemento foi buscado <strong>duas vezes denecessariamente.</strong> Se quisermos deixar o código mais performático, podemos fazer a seguinte alteração:</p>

<div class='codeblock'>
<p>interação correta com o DOM</p>
<code class='javascript'
>'use strict';

$(function() {
	<strong>// salvamos a referência ao elemento na variável</strong>
	<strong class='small'>let meuDatePicker = $('#datepicker');</strong>

	<strong>// e usamos quantas vezes quisermos sem sermos penalizados</strong>

	<strong class='small'>meuDatePicker</strong>.datepicker();
	$('#format').change(function() {
		<strong>meuDatePicker</strong>.datepicker('option', 'dateFormat', $(this).val());
	});
});</code
>
</div>

<h3 id='seo'>Google - O Grande Irmão</h3>

<p>Acabamos de aprender como alterar html através de JavaScript. Igualmente importante é sabermos quando não devemos fazer isso. Via de regra, Google e outros bots <strong>não indexam conteúdo criado ou alterado por javascript.</strong> Porém, pode penalizar você se ele achar que você está tentando trapacear, mostrando um conteúdo muito diferente do que foi indexado. Para aplicativos web isso talvez não seja um problema, mas para páginas de internet com conteúdo com certeza é. Aqui vale o bom senso. Podemos fazer um ou outro dropdown, mas se abusarmos deste recursos, escondermos coisas sem um método de mostrá-las novamente, podemos ser <strong>punidos pelo Google</strong> com posições mais baixas nos resultados, e até mesmo banimento temporário.</p>

<p>O fato de bots não rodarem javascript em sua maioria também pode ser usado em nossa <strong>vantagem.</strong> É possível por exemplo proteger endereços de emails ou evitar envio automático de formulários alterando certas propriedades por JavaScript.</p>

<div class='codeblock'>
<p>semcaptcha.htm</p>
<code class='html'
>&lt;!DOCTYPE html&gt;
&lt;html
	xmlns='http://www.w3.org/1999/xhtml'
	lang='pt-BR'
	xml:lang='pt-br'
	&gt;
&lt;head&gt;
	&lt;title&gt;Google está olhando&lt;/title&gt;
	&lt;meta charset='utf-8' /&gt;
&lt;/head&gt;
<strong>&lt;body&gt;</strong>
	<strong>&lt;form action='#'&gt;</strong>
		&lt;dl&gt;
			&lt;dt&gt;&lt;label for='nome'&gt;nome&lt;/label&gt;&lt;/dt&gt;
			&lt;dd&gt;&lt;input id='nome' type='text' /&gt;&lt;/dd&gt;
		&lt;/dl&gt;
		&lt;p&gt;&lt;input type='submit' /&gt;&lt;/p&gt;
	<strong>&lt;/form&gt;</strong>
	<strong>&lt;script src='semcaptcha.js'&gt;&lt;/script&gt;</strong>
<strong>&lt;/body&gt;</strong>
&lt;/html&gt;</code
>
</div>

<div class='codeblock'>
<p>semcaptcha.js</p>
<code class='javascript'
>'use strict';

let formulario = document.getElementsByTagName('form')[0];
<strong>formulario.action = 'cadastrar.cgi';</strong> <strong>// não vai ser lido pela maioria dos bots</strong></code
>
</div>

<h3 id='serverside'>Desacoplando JavaScript das linguagens server-side</h3>

<p>Se estruturarmos nossa programação de modo que as bibliotecas com os objetos estejam em arquivos externos, podemos apenas chamar os <q>construtores</q> de nossos objetos nas páginas com programação <em>server-side</em>, passando os parâmetros com valores dinâmicos.</p>

<div class='codeblock'>
<p>serverside.php</p>
<code class='html'
>&lt;!DOCTYPE html&gt;
&lt;html
	xmlns='http://www.w3.org/1999/xhtml'
	lang='pt-BR'
	xml:lang='pt-br'
	&gt;
&lt;head&gt;
	&lt;title&gt;Html mínimo aceitável&lt;/title&gt;
	&lt;meta charset='utf-8' /&gt;
	<strong>&lt;script src='dropdown.js'&gt;&lt;/script&gt;</strong>
	&lt;script&gt;
		(function() {
			'use strict';

			dropdown.init(<strong>&lt;%= // valor calculado server side %&gt;</strong>);
		})();
	&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;</code
>
</div>

<div class='codeblock'>
<p>dropdown.js</p>
<code class='javascript'
>'use strict';

let dropdown = {

	init: function(idConteiner) {
		this.idConteiner = idConteiner;
		this.conteiner = document.getElementById(this.idConteiner);
		this.rotulo = this.conteiner.querySelector('button');
		this.lista = this.conteiner.querySelector('ul');
		this.rotulo.addEventListener('click', this.clickHandler.bind(this));
	},

	clickHandler: function(evento) {
		this.visivel = !this.visivel;
		this.atualizar();
	},

	atualizar: function() {
		if (this.visible) {
			this.lista.style.display = 'block';
			return;
		}
		this.lista.style.display = 'none';
	},

	idConteiner: null,

	conteiner: null

	rotulo: null,

	lista: null,

	visivel: false

};</code
>
</div>

</section>



<section>

<h2 id='oop'>This doesn't makes sense - <abbr title='Object Oriented Programming'>OOP</abbr> <span>Ou WTF is this??? :P</span></h2>

<p>Já vimos acima como declarar objetos simples, utilizando literais de objeto <code class='javascript'>{}</code>. Estes objetos são dinâmicos, não possuindo uma noção de classe como em outras linguagens. Relembrando que de fato <strong>não existem classes em JavaScript</strong>, apenas recursos da linguagem para camuflar a implementação real. Esta característica, associada ao fato de que JavaScript não é fortemente tipado, permite que objetos tenham propriedades e métodos inseridos ou removidos dinamicamente, em tempo de execução.</p>

<p><strong>Mesmo no modo estrito, podemos adicionar e remover propriedades</strong>. Note que isso não é muito bom para performance. Assim como acontece com os tipos de variáveis, se evitarmos mudar o objeto após sua criação, o compilador não consegue efetuar otimizações para tipos específicos.</p>
<p>Adicionalmente, JavaScript possui o operador <code class='javascript'>delete</code> para remover propriedades, que é lento. Preferencialmente atribuímos o valor <code class='javascript'>null</code> para a propriedade que desejamos remover. A versão ES5 adicionou um método chamado <code class='javascript'>Object.seal</code>, que previne modificação dinâmica do objeto.</p>

<div class='codeblock'>
<p>adicão e remoção dinâmica de propriedades</p>
<code class='javascript'
>'use strict';

let escravoDeJo = {
	jogar: function() {
		//
	}
};

escravoDeJo.jogar = null; // tira a propriedade - use o valor null ao invés de delete
escravoDeJo.som = 'zig zig za'; // bota a propriedade

console.log(escravoDeJo); // note a mudança das propriedades

Object.seal(escravoDeJo); // "corpo fechado" - previne mudanças no objeto

// Lança exceção. Não é possível mudar um objeto selado
escravoDeJo.fazer = function() {
	//
}</code
>
</div>

<p>Lembra que eu disse que JavaScript não possui classes de verdade, certo? Veja as consequências disso nesse pedaço de código.</p>

<div class='codeblock'>
<p>adicão e remoção dinâmica de propriedades</p>
<code class='javascript'
>'use strict';

class Estranha {
	seraQueTemMesmo() {
		console.log('tem!');
	}
}

const estranho = new Estranha();
const diferente = new Estranha();

diferente.seraQueTemMesmo = null; // válido, mesmo com const. ver explicação abaixo

estranho.seraQueTemMesmo(); // Ok
diferente.seraQueTemMesmo(); // Erro! O objeto diferente não possui esse método</code
>
</div>

<p>Ué? Objetos da mesma classe podem ser diferentes? E <code class='javascript'>const</code> não salvou o dia e botou um pouco de ordem nisso? Infelizmente a primeira resposta é sim, e a segunda é não. Ao contrário de outras linguagens, que não permitem que um objeto declarado com <code class='javascript'>const</code> mude de maneira nenhuma, JavaScript apenas proíbe que a constante referencia um objeto diferente do inicial.</p>

<p><strong>Se não tomarmos cuidado, nunca podemos garantir que dois objetos de uma mesma classe sejam parecidos.</strong> Porém, nem tudo está perdido, uma vez que possuímos um método que é capaz de fazer o que você deseja, chamado <code>Object.freeze</code>.</p>

<div class='codeblock'>
<p>adicão e remoção dinâmica de propriedades</p>
<code class='javascript'
>'use strict';

class Estranha {
	constructor() {
		Object.defineProperty(this, propriedade, {
			value: 1,
			writable: true
		});
	}
	seraQueTemMesmo() {
		console.log('tem!');
	}
}

const estranho = new Estranha();
const diferente = new Estranha();

estranho = new Estranha(); // Erro! não é possível atribuir um novo valor à const

<strong>Object.freeze(estranho);</strong>
<strong>Object.freeze(diferente);</strong>

<strong>diferente.seraQueTemMesmo = null;</strong> <strong>// Erro! Não é possível modificar um objeto congelado</strong>

<strong>estranho.propriedade = 2;</strong> <strong>// Erro! Não é possível modificar um objeto congelado</strong>

estranho.seraQueTemMesmo(); // Ok se chegasse aqui
diferente.seraQueTemMesmo(); // Ok se chegasse aqui</code
>
</div>

<p>Caso congelar um objeto seja uma medida muito extrema, existe um intermediário, que apenas proibe a alteração dos métodos, mas não das propriedades, chamado <code class='javascript'>Object.seal</code>.</p>

<div class='codeblock'>
<p>adicão e remoção dinâmica de propriedades</p>
<code class='javascript'
>'use strict';

class Estranha {
	<strong>constructor() {</strong>
		Object.defineProperty(this, propriedade, {
			value: 1,
			writable: true
		});
		<strong>Object.seal(this);</strong>
	<strong>}</strong>
	seraQueTemMesmo() {
		console.log('tem!');
	}
}

const estranho = new Estranha();
const diferente = new Estranha();

<strong>diferente.propriedade = 2;</strong> <strong>// Ok, seal permite modificar propriedades</strong>

<strong>diferente.seraQueTemMesmo = null;</strong> <strong>// Erro, seal não deixa redefinir métodos</strong>

estranho.seraQueTemMesmo(); // Ok se chegasse aqui
diferente.seraQueTemMesmo(); // Ok se chegasse aqui</code
>
</div>

<p></p>

<p>Para acomodar toda esta flexibilidade, JavaScript possui mais uma diferença, desta vez em relação à palavra-chave <code class='javascript'>this</code>. Se podemos inserir funções dinamicamente nos objetos, o que acontece quando uma destas funções utiliza <code class='javascript'>this</code>?</p>

<div class='codeblock'>
<p>significado de this</p>
<code class='javascript'
>'use strict';

const modeloCumprimentar = function() {
	console.log('Olá, menu nome é ' + this.nome); // WTF is this?
}

const diretorSuspense = {
	nome: 'Alfred';
};

const diretorAlternativo = {
	nome: 'Tim';
};

diretorSuspense.cumprimentar = modeloCumprimentar;
diretorAlternativo.cumprimentar = modeloCumprimentar;

diretorSuspense.cumprimentar(); // mostra Olá, menu nome é Alfred
diretorAlternativo.cumprimentar(); // mostra Olá, menu nome é Tim</code
>
</div>

<p><strong>Resumindo, <code class='javascript'>this</code> em JavaScript muda de significado de acordo com o contexto.</strong> Mais precisamente, <code class='javascript'>this</code> aponta sempre para o objeto que está executando a função atualmente. Isso traz mais problemas do que vantagens geralmente. Isto permite que as funções funcionem um pouco como <em>traits</em> presentes em outras linguagens, que permitem compor um objeto sem usar herança diretamente.</p>

<p>Métodos que podem receber uma função como parâmetro, também aceitam métodos de objetos. Nesses casos, o significado de <code class='javascript'>this</code> sempre irá mudar. Métodos nativos como <code class='javascript'>setTimeout</code> e <code class='javascript'>addEventListener</code> possuem esse comportamento. Vejamos um outro exemplo disso:</p>

<div class='codeblock'>
<p>mudanças indesejadas do contexto de execução, this</p>
<code class='javascript'
>'use strict';

let frutas = [
	{ nome: 'banana', peso: 100 },
	{ nome: 'maçã', peso: 80 },
	{ nome: 'abacaxi', peso: 3500 } // um abacaxi enorme!
];

<strong>let ordenador = {</strong>

	ordenarPor: 'nome',

	<strong>ordenar: function(arrayOriginal) {</strong>
		<strong>arrayOriginal.sort(this.comparador);</strong> <strong>// sort muda o contexto de execução</strong>
	<strong>},</strong>

	<strong>comparador: function(a, b) {</strong>

		<strong>// this aponta para o quê aqui?? Possivelmente para window.</strong>
		// note também o uso da notação [] para acessar campos dinamicamente

		if (typeof a[<strong>this</strong>.ordenarPor] === 'number'
			&amp;&amp; typeof b[<strong>this</strong>.ordenarPor] === 'number'
			) {

			return a[<strong>this</strong>.ordenarPor] - b[<strong>this</strong>.ordenarPor];
		}

		if (a[<strong>this</strong>.ordenarPor] &gt; b[<strong>this</strong>.ordenarPor]) {
			return 1;
		} else if (a[<strong>this</strong>.ordenarPor] &lt; b[<strong>this</strong>.ordenarPor]) {
			return -1;
		} else if (a[<strong>this</strong>.ordenarPor] == b[<strong>this</strong>.ordenarPor]) {
			return 0;
		}

	<strong>}</strong>

<strong>};</strong>

ordenador.ordenarPor = 'nome';
ordenador.ordenar(frutas);
for (let fruta of frutas) {
	console.log(fruta);
}

ordenador.ordenarPor = 'peso';
ordenador.ordenar(frutas);
for (let fruta of frutas) {
	console.log(fruta);
}

// PS: logar a array inteira de uma vez pode causar confusão
// pois a ordem mostrada dos campos vai ser sempre o estado final da referência
// por isso usamos for nos valores</code
>
</div>

<p>A referência <code class='javascript'>this</code> parece apontar para o objeto <code class='javascript'>ordenador</code>, mas isso não é sempre verdade. Quando passamos o método para <code class='javascript'>arrayOriginal.sort</code>, nosso comparador vai executar num contexto diferente. Assim o <code class='javascript'>this</code> referenciado não é o que esperávamos. Tentamos usar a propriedade <code class='javascript'>ordenarPor</code> que não está mais acessível e isso causa uma exceção.</p>

<h3 id='bindthis'>Deixando as coisas mais previsíveis</h3>

<p>Não estamos desamparados para resolver os problemas de mudança de contexto (amém!). De fato, <strong>as funções em JavaScript possuem diversos métodos para controlar essa mudança.</strong> Vamos ver a seguir dois deles.</p>


<p>Lembrando que em JavaScript funções são objetos, em navegadores recentes as funções possuem um método chamado <code class='javascript'>bind</code>, que retorna uma <strong>cópia da função com o <code class='javascript'>this</code> fixo.</strong></p>

<div class='codeblock'>
<p>controlando contexto com bind</p>
<code class='javascript'
>'use strict';

arrayOriginal.sort(this.comparador<strong>.bind(this)</strong>); <strong>// ES3, só IE9+ suporta</strong></code
>
</div>

<p>Para navegadores mais antigos temos outras duas alternativas. A concentualmente mais simples é utilizar <code class='javascript'>jQuery.proxy</code>, que funciona de <strong>maneira similar ao <code class='javascript'>bind</code>.</strong></p>

<div class='codeblock'>
<p>controlando contexto com jQuery.proxy</p>
<code class='javascript'
>'use strict';

arrayOriginal.sort(<strong>jQuery.proxy(</strong>this.comparador, <strong>this)</strong>); <strong>// todos os navegadores</strong></code
>
</div>

<p>Note que <code class='javascript'>jQuery.proxy</code> permite passar parâmetros para a função na seguinte forma:</p>

<div class='codeblock'>
<p>passando parâmetros com jQuery.proxy</p>
<code class='javascript'
>'use strict';

jQuery.proxy(this.comparador, this, var1, var2, var3);</code
>
</div>

<p>Internamente <code class='javascript'>jQuery.proxy</code> utiliza um outro método pertencente às funções, que também altera o valor de <code class='javascript'>this</code>, chamado <code class='javascript'>apply</code>. Na verdade, não é difícil fazermos uma versão simplificada de <code class='javascript'>bind</code>, ou <code class='javascript'>jQuery.proxy</code> com <code class='javascript'>apply</code>, evitando ser necessário uma biblioteca inteira apenas para essa funcionalidade.</p>

<p>A terceira alternativa é a mais manual e complexa. Possui porém a vantagem de cobrir todos os casos que o <code class='javascript'>bind</code> nativo cobre. Ela utiliza o conceito de <a href='#closures'>closures</a>.</p>

<h3>Revisitando nosso abacaxi</h3>

<p>Esta solução do nosso problema consiste em  <strong>simplesmente não utilizar a palavra <code class='javascript'>this</code>.</strong> Apenas a palavra <code class='javascript'>this</code> muda de significado, se conseguirmos <strong>referenciar nosso objeto original por outro nome,</strong> como demonstramos com <a href='#closures'>aliases</a> e a <code class='javascript'>cabineTelefonica</code>, podemos acessá-lo sempre que precisarmos sem ter medo de uma crise de identidade. Para fazermos isso usamos uma <em>closure</em>. A primeira forma de utilizá-la, é fazendo-a conter a função completa de comparação.</p>


<div class='codeblock'>
<p>resolvendo mudanças de contexto com closures</p>
<code class='javascript'
>'use strict';

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!! USE BIND SE POSSÍVEL.</strong>

let frutas = [
	{ nome: 'banana', peso: 100 },
	{ nome: 'maçã', peso: 80 },
	{ nome: 'abacaxi', peso: 3500 } // um abacaxi enorme!
];

let ordenador = {

	ordenarPor: 'nome',

	<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!! USE BIND SE POSSÍVEL.</strong>

	// init irá executar a closure, que salva a referência para this com um nome diferente
	// este nome não sofre do mesmo mal que this, e aponta sempre para a mesma referência
	init: function() {
		this.comparador = this.closureComparador(this);
	},

	ordenar: function(arrayOriginal) {
		arrayOriginal.sort(this.comparador);
	},

	<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!! USE BIND SE POSSÍVEL.</strong>

	closureComparador: function (contexto) {

		return function(a, b) {

			// contexto sempre apontará para o objeto ordenador

			if (typeof a[contexto.ordenarPor] === 'number'
				&amp;&amp; typeof b[contexto.ordenarPor] === 'number'
				) {

				return a[contexto.ordenarPor] - b[contexto.ordenarPor];
			}

			if (a[contexto.ordenarPor] &gt; b[contexto.ordenarPor]) {
				return 1;
			} else if (a[contexto.ordenarPor] &lt; b[contexto.ordenarPor]) {
				return -1;
			} else if (a[contexto.ordenarPor] == b[contexto.ordenarPor]) {
				return 0;
			}

		}

	},

	<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!! USE BIND SE POSSÍVEL.</strong>

	comparador: null

};

ordenador.init();

ordenador.ordenarPor = 'nome';
ordenador.ordenar(frutas);
for (let fruta of frutas) {
	console.log(fruta);
}

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!! USE BIND SE POSSÍVEL.</strong>

ordenador.ordenarPor = 'peso';
ordenador.ordenar(frutas);
for (let fruta of frutas) {
	console.log(fruta);
}

// PS: logar a array inteira de uma vez pode causar confusão
// pois a ordem mostrada dos campos vai ser sempre o estado final da referência
// por isso usamos for nos valores</code
>
</div>

<p>Note que precisamos ser bastante cuidadosos para sempre escrever <code class='javascript'>contexto</code> ao invés de <code class='javascript'>this</code>. Existe uma <strong>segunda forma dessa solução,</strong> que utiliza a closure para simplesmente passar o contexto correto ao método executado.</p>

<div class='codeblock'>
<p>resolvendo mudanças de contexto com closures - solução alternativa</p>
<code class='javascript'
>'use strict';

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!! USE BIND SE POSSÍVEL.</strong>

let frutas = [
	{ nome: 'banana', peso: 100 },
	{ nome: 'maçã', peso: 80 },
	{ nome: 'abacaxi', peso: 3500 } // um abacaxi enorme!
];

let ordenador = {

	ordenarPor: 'nome',

	<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!! USE BIND SE POSSÍVEL.</strong>

	// init irá executar a closure, que salva a referência para this com um nome diferente
	// este nome não sofre do mesmo mal que this, e aponta sempre para a mesma referência
	init: function() {
		this.comparador = this.closureComparador(this);
	},

	ordenar: function(arrayOriginal) {
		arrayOriginal.sort(this.comparador);
	},

	<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!! USE BIND SE POSSÍVEL.</strong>

	closureComparador: function (contexto) {
		return function(a, b) {

			// ao invés de escrever o corpo da função diretamente aqui, como no outro exemplo
			// simplesmente chamamos a função comparar definida no objeto
			// como comparar está sendo chamada indiretamente dentro da closure, através de "contexto"
			// o "this" dentro de "comparar" apontará para "contexto", que é o objeto ordenador, como queremos
			// ao contrário do problema original, onde "comparar" era chamada diretamente através de array.sort
			// e portanto seu "this" apontava para window
			return contexto.comparar(a, b);

		}
	},

	comparador: null,

	<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!! USE BIND SE POSSÍVEL.</strong>

	comparar: function(a, b) {

		// a closure se encarrega de executar este método com o contexto correto
		// por isso podemos utilizar this sem preocupações

		if (typeof a[this.ordenarPor] === 'number'
			&amp;&amp; typeof b[this.ordenarPor] === 'number'
			) {

			return a[this.ordenarPor] - b[this.ordenarPor];
		}

		if (a[this.ordenarPor] &gt; b[this.ordenarPor]) {
			return 1;
		} else if (a[this.ordenarPor] &lt; b[this.ordenarPor]) {
			return -1;
		} else if (a[this.ordenarPor] == b[this.ordenarPor]) {
			return 0;
		}

	}

	<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!! USE BIND SE POSSÍVEL.</strong>

};

ordenador.init();

ordenador.ordenarPor = 'nome';
ordenador.ordenar(frutas);
for (let fruta of frutas) {
	console.log(fruta);
}

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!! USE BIND SE POSSÍVEL.</strong>

ordenador.ordenarPor = 'peso';
ordenador.ordenar(frutas);
for (let fruta of frutas) {
	console.log(fruta);
}

// PS: logar a array inteira de uma vez pode causar confusão
// pois a ordem mostrada dos campos vai ser sempre o estado final da referência
// por isso usamos for nos valores</code
>
</div>

<p>Vale a pena reforçar que, <strong>a diferença entre o problema original e esta última solução,</strong> é que no código original, passávamos uma <strong>referência direta</strong> para o método do objeto, fazendo com que ele fosse <strong>chamado diretamente,</strong> ao passo que nesta última solução, passamos uma <strong>referência indireta</strong> ao método, fazendo com que ele seja <strong>chamado através do objeto ao qual pertence.</strong></p>

</section>



<section>

<h2 id='heranca'>É tanta herança que vou ficar rico <span>de conhecimento ;)</span></h2>

<p>JavaScript suporta pelo menos 3 maneiras diferentes de criarmos uma hierarquia com heranças.</p>

<h3>Herança com pouca classe</h3>

<p>Já vimos que herança em JavaScript é <strong>baseada em protótipos.</strong> Um objeto herda diretamente de outro objeto. Embora possamos declarar uma herança como se estivéssemos usando classes, não é o que efetivamente acontece por baixo dos panos. Se nos atermos ao uso básico dos objetos, não quebraremos a ilusão de estarmos trabalhando com classes. Para saber efetivamente em que momentos esta <a href='#herancaprototipo'>ilusão é quebrada</a>, continue lendo mais abaixo.</p>

<div class='codeblock'>
<p>herança com polimorfismo</p>
<code class='javascript'
>'use strict';

class ObjetoPai {

	constructor() {
		Object.defineProperty(this, 'propriedade', {value: []});
		this.propriedade.push(valor);
	}

	metodo() {
		console.log(this.propriedade);
	}

}

// herança
class ObjetoFilho extends ObjetoPai {

	constructor() {
		super();
		Object.seal(this);
	}

	// sobrescrita do método
	metodo() {
		super.metodo();
	}

}

// construtores
objetoPai = new ObjetoPai(3);
objetoFilho = new ObjetoFilho(3);

objetoPai.propriedade.push('pai');
objetoFilho.propriedade.push('filho');

objetoPai.metodo();
objetoFilho.metodo();</code
>
</div>

<h3 id='legacyheranca'>Herança antiga com Object.create</h3>

<p>Utilizamos o método <code class='javascript'>Object.create</code>. Já vimos isso rapidamente quando definimos um objeto com getters e setters utilizando descritores de propriedades. Vamos ver agora um exemplo com polimorfismo. Se precisarmos acessar o objeto base de dentro do objeto filho, chamamos o método <code class='javascript'>Object.getPrototypeOf</code>, que retorna um objeto acima da cadeia de herança.</p>

<p>Note que estamos tratando de <strong>objetos concretos</strong>, e não de definições de objetos como são as classes em outras linguagens. Isso significa que, quando acessarmos o objeto base, estaremos <strong>acessando</strong> não só as definições de métodos mas também os <strong>valores das propriedades dele.</strong> Devemos portanto tomar o cuidado de, ao chamar estes métodos base, indicar que queremos <strong>executá-los no contexto do objeto filho.</strong></p>

<p>Outro cuidado que devemos tomar, é o de atribuir valores aos objetos num método separado, que o inicializa. Se atribuirmos valores diretamente na definição do objeto, e estes valores forem tipos de referência como arrays, eles serão compartilhados pelos subobjetos ao invés de cada um ter sua própria cópia.</p>

<div class='codeblock'>
<p>herança com polimorfismo</p>
<code class='javascript'
>'use strict';

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

var objetoPai = {

	init: function() {
		this.propriedade = []; // inicializar valores das propriedades só aqui! Muito importante!
		this.propriedade.push(valor);
	},

	metodo: function() {
		console.log(this.propriedade);
	},

	<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

	propriedade: null

};

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

// herança
var objetoFilho = Object.create(objetoPai);

// sobrescrita do método
objetoFilho.metodo = function() {
	Object.getPrototypeOf(this).metodo.call(this);
}

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

objetoPai.init(3);
objetoFilho.init(3);

objetoPai.propriedade.push('pai');
objetoFilho.propriedade.push('filho');

objetoPai.metodo();
objetoFilho.metodo();</code
>
</div>

<p>Se não precisarmos de compatibilidade com navegadores antigos, podemos usar descritores de propriedade, que nos dão mais controle sobre a definição do objeto.</p>

<div class='codeblock'>
<p>herança com polimorfismo ES5</p>
<code class='javascript'
>'use strict';

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

var objetoPai = Object.create(Object.prototype, {

	init: {
		value: function() {
			this.propriedade = []; // inicializar valores das propriedades só aqui! Muito importante!
			this.propriedade.push(valor);
		}
	},

	metodo: {
		value: function() {
			console.log(this.propriedade);
		},
		writable: true
	},

	<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

	propriedade: {
		value: null,
		writable: true
	}

});

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

// herança
var objetoFilho = Object.create(objetoPai, {

	// sobrescrita do método
	metodo: {
		value: function() {
			Object.getPrototypeOf(this).metodo.call(this);
		}
	}


});

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

objetoPai.init(3);
objetoFilho.init(3);

objetoPai.propriedade.push('pai');
objetoFilho.propriedade.push('filho');

objetoPai.metodo();
objetoFilho.metodo();</code
>
</div>

<h3 id='deprecatedheranca'>Herança arcaica com function</h3>

<p>Mostro também um exemplo de herança com a sintaxe antiga. Note que a sintaxe é mais confusa e <strong>propensa a erros</strong>, pois possui <strong>etapas manuais</strong> que devem ser lembradas toda a vez. Além disso, existem as questões comentadas anteriormente sobre misturar definições de coisas no construtor e no protótipo, e dar a ilusão que JavaScript possui classes, o que não é verdade.</p>

<div class='codeblock'>
<p>herança com polimorfismo com sintaxe antiga, não use!</p>
<code class='javascript'
>'use strict';

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

function ObjetoPai(valor) {
	// definir e inicializar valores aqui
	this.propriedade = [];
	this.propriedade.push(valor);
}

ObjetoPai.prototype.metodo = function() {
	console.log(this.propriedade);
};

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

// herança
function ObjetoFilho() {
	ObjetoPai.apply(this, Array.prototype.slice.call(arguments)); // "super()"
}
ObjetoFilho.prototype = new ObjetoPai(); // especificar manualmente qual o protótipo para herdar
ObjetoFilho.prototype.constructor = ObjetoFilho; // sobrescrever manualmente o construtor

// sobrescrita do método
ObjetoFilho.prototype.metodo = function() {
	ObjetoPai.prototype.metodo.call(this); // nome do objeto base é hardcoded e não muda automaticamente de acordo com a herança
};

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

var objetoPai = new ObjetoPai('pai');
var objetoFilho = new ObjetoFilho('filho');

objetoPai.metodo();
objetoFilho.metodo();</code
>
</div>

<p>Vamos ver um exemplo mais completo.</p>

<div class='codeblock'>
<p>polimorfismo, exemplo completo</p>
<code class='javascript'
>'use strict';

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

// define o objeto base
var ampulheta = {

	init: function(tempo) {
		// define os valores padrão das propriedades
		this.tempoTotal = tempo;
		this.tempoAtual = this.tempoTotal;
	},

	<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

	contar: function() {
		if (this.tempoAtual &gt; 0) {
			this.tempoAtual--;
		}
	},

	girar: function() {
		this.tempoAtual = this.tempoTotal - this.tempoAtual;
	},

	<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

	tempoTotal: null,

	tempoAtual: null

};

// herança
var ampulhetaAutomatica = Object.create(ampulheta); // "ampulhetaAutomatica extends ampulheta"

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

// define os métodos do objeto derivado
ampulhetaAutomatica.contar = function() {

	if (this.tempoAtual &lt;= 0) {
		this.girar();
	} else {

		// chamar o método da maneira abaixo o executaria no contexto do objeto pai, ampulheta
		// Object.getPrototypeOf(this).contar();

		// por isso usando o método call da função para mudar o contexto novamente para ampulhetaAutomática
		Object.getPrototypeOf(this).contar.call(this);

	}

}

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

ampulheta.init(3);
ampulhetaAutomatica.init(3);

ampulheta.contar(); // 2
ampulheta.contar(); // 1
ampulheta.contar(); // 0
ampulheta.girar(); // 3

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

ampulhetaAutomatica.contar(); // 2
ampulhetaAutomatica.contar(); // 1
ampulhetaAutomatica.contar(); // 0
ampulhetaAutomatica.contar(); // 3</code
>
</div>

<p>Mostrar properties</p>

<div class='codeblock'>
<p>polimorfismo, exemplo completo com sintaxe antiga, não use!</p>
<code class='javascript'
>'use strict';

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

// define o objeto base
function Ampulheta(tempo) {
	// define as propriedades e valores padrão
	this.tempoTotal = tempo;
	this.tempoAtual = this.tempoTotal;
}

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

// define os métodos do objeto base

Ampulheta.prototype.contar = function() {
	if (this.tempoAtual &gt; 0) {
		this.tempoAtual--;
	}
};

Ampulheta.prototype.girar = function() {
	this.tempoAtual = this.tempoTotal - this.tempoAtual;
};

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

// define o objeto derivado
function AmpulhetaAutomatica() {
	Ampulheta.apply(this, Array.prototype.slice.call(arguments)); // "super()"
}

// herança
AmpulhetaAutomatica.prototype = new Ampulheta(); // "AmpulhetaAutomatica extends Ampulheta"
AmpulhetaAutomatica.prototype.constructor = AmpulhetaAutomatica; // "conserta" o construtor

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

// define os métodos do objeto derivado
AmpulhetaAutomatica.prototype.contar = function() {
	if (this.tempoAtual &lt;= 0) {
		this.girar();
	} else {

		// chamar o método da maneira abaixo o executaria no contexto do objeto pai, ampulheta
		// Ampulheta.prototype.contar();

		// por isso usando o método call da função para mudar o contexto novamente para ampulhetaAutomatica
		Ampulheta.prototype.contar.call(this);
	}
};

<strong>// NÃO COPIE!!! SINTAXE ANTIGA!!!!</strong>

// simulação de sintaxe de outras linguagens
var contador = new Ampulheta(3);
var contadorAutomatico = new AmpulhetaAutomatica(3);

contador.contar(); // 2
contador.contar(); // 1
contador.contar(); // 0
contador.girar();  // 3

contadorAutomatico.contar(); // 2
contadorAutomatico.contar(); // 1
contadorAutomatico.contar(); // 0
contadorAutomatico.contar(); // 3</code
>
</div>

<h3 id='herancaprototipo'>Beware, here there be dragons</h3>

<p>Vale lembrar também que as várias formas de declarar objetos e heranças descritas anteriormente podem coexistir ao mesmo tempo, sem necessariamente gerarem cadeias de herança 100% idênticas. Algumas utilizam funções objetos, outras objetos puros. Vou me ater à última maneira de herança, mais moderna e que parece ser a mais compacta, e mais parecida com a de outras linguagens, e portanto, mais propensa a erros de analogia.</p>

<p>Seja Javascript não possui classes verdadeiras, o que então é criado quando digitamos <code class='javascript'>class</code>? Uma função. E como toda função em JavaScript é um objeto dinâmico, é possível fazer, deliberadamente ou inadvertidamente toda sorte de coisas malucas.</p>

<div class='codeblock'>
<p>hic sunt dracones</p>
<code class='javascript'
>'use strict';

<strong>// NÃO COPIE!!! APENAS PARA DEMONSTRAÇÃO!!!!</strong>

class Ha {
	constructor() {
		// se não retornarmos nada explicitamente
		// this é retornado implicitamente
		return 'outra coisa';
	}
}

const ha = new Ha(); // string "outra coisa" ao invés de "instância" de Ha

class Bla {
	static fazer() { /**/ }
}

console.log(Bla); // tipo function

// adicionar propriedades estáticas dinamicamente à "classe" (função)
Bla.propriedade = 2;
Bla.propriedadeCompartilhada = { tipo: 'referência' };


<strong>// NÃO COPIE!!! APENAS PARA DEMONSTRAÇÃO!!!!</strong>


// remover métodos estáticos dinamicamente
Bla.fazer = null;

// misturar maneiras diferentes de heranças
let blo = Object.create(Bla);


<strong>// NÃO COPIE!!! APENAS PARA DEMONSTRAÇÃO!!!!</strong>


console.log(blo.propriedade); // 2. Era estática mas virou de instância
console.log(blo.propriedadeCompartilhada); // { tipo: 'referência' }. Era estática mas virou de instância

// referência é a mesma da propriedade estática
blo.propriedadeCompartilhada.tipo = 'mudou';
console.log(Bla.propriedadeCompartilhada); // { tipo: 'mudou' }

// Herança maldita ;)</code
>
</div>

<h3 id='proxyNativo'>Controle de visibilidade com Proxy Nativo</h3>

<p>Todas as opções de declaração de objetos que vimos até agora possuem apenas propriedades e métodos públicos, sem a o possibilidade de um controle mais preciso de sua visibilidade. JavaScript <strong>não possui uma maneira</strong> de criar tais permissões de acesso através de palavras-chave como <code class='generic'><span class='keyword'>private</span></code>, <code class='generic'><span class='keyword'>protected</span></code> e <code class='generic'><span class='keyword'>public</span></code>, e portanto precisamos recorrer a padrões de projeto para conseguir o que queremos. <strong>Nenhuma das soluções possíveis é capaz de satifazer completamente a falta dessa funcionalidade.</strong></p>

<p>A partir da versão ES6 da linguagem, temos acesso à <em>proxies</em> nativos, que tornam a tarefa de controle de visibilidade um pouco menos difícil, permitindo uma melhor mistura entre visibilidade, herança e uso de memória do que é possível através de outras maneiras. Ainda assim, deixam muito a desejar, uma vez que não foram criados com isso em mente. Seu motivo de existência parece ser a de efeitos colaterais como logs e notificações.</p>

<p><em>Proxies</em> nativos são capazes de interceptar chamadas de métodos, acesso à propriedades, e ações através dos operadores <code class='javascript'>new</code>, <code class='javascript'>delete</code>, <code class='javascript'>in</code>, e métodos de <code class='javascript'>Object</code> como <code class='javascript'>Object.getPrototypeOf</code>, <code class='javascript'>Object.create</code>, etc. Não vou abordar a <a rel='external nofollow' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy'>lista completa de capacidades</a>, apenas as pertinentes ao controle de visibilidade.</p>

<p>Estes <em>proxies</em> necessitam de um objeto que especifica o comportamento da intercepção para cada caso. Para simular campos protegidos e privados, temos que interceptar o acesso às propriedades e métodos, através dos métodos <code class='javascript'>get</code> e <code class='javascript'>set</code> da definição do <code class='javascript'>Proxy</code>. Por enquanto vou esconder alguns detalhes da implementação (mais especificamente <code class='javascript'>_hasAccess</code>) pra digerirmos tudo aos poucos.</p>

<div class='codeblock'>
<p>padrão proxy</p>
<code class='javascript'
>'use strict';

const _hasAccess = (alvo, propriedade) =&gt; { /* omitido por enquanto, vamos aos poucos ;) */ };

// define o comportamento do proxy
const proxyHandler = {

	/** intercepta leitura dos valores de propriedades e métodos */
	get(alvo, propriedade, receiver) {

		// se existe
		if (!(propriedade in alvo)) {
			throw new Error('Não existe ou é privado');
		}

		// se é visível
		if (!_hasAccess(alvo, propriedade)) {
			throw new Error('Não existe ou é privado');
		}

		return Reflect.get(alvo, propriedade, receiver);// Reflect.get encaminha a operação para o alvo
	},

	/** intercepta escrita dos valores de propriedades */
	set(alvo, propriedade, valor, receiver) {

		// se é visível
		if (!_hasAccess(alvo, propriedade)) {
			throw new Error('Não existe ou é privado');
		}

		return Reflect.set(alvo, propriedade, valor, receiver); // Reflect.set encaminha a operação para o alvo
	}

};

// define a classe
class Cupcake {
	constructor() {
		this.cobertura = null;
	}
}

// cria uma instância
const cupcake = new Cupcake();
const cupcakeProxy = new Proxy(cupcake, proxyHandler);
cupcakeProxy.cobertura = 'doce de leite com cereja'; // vai ser interceptado por proxyHandler.set
console.log(cupcakeProxy.cobertura); // vai ser interceptado por proxyHandler.get</code
>
</div>

<p>O comportamento de <code class='javascript'>get</code> e <code class='javascript'>set</code> é <strong>determinado por algumas invariantes</strong> definidas na <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler' real='external nofollow'>especificação</a> ES6, na qual o JavaScript é baseado. Essas invariantes garantem que o objeto <code class='javascript'>Proxy</code> seja consistente com o objeto interceptado, podendo substituí-lo de maneira transparente. Infelizmente como efeito colateral, a flexibilidade do <code class='javascript'>Proxy</code> é reduzida. Por exemplo, <strong>devemos obrigatoriamente mostrar todas as propriedades não configuráveis.</strong> Se selarmos o objeto com <code class='javascript'>Object.seal</code>, todas as propriedades se tornarão não configuráveis como consequência, e portanto devemos mostrá-las. Também devemos retornar o mesmo valor que o objeto retornaria para propriedades somente leitura não configuráveis, e por aí vai.</p>

<p>Vamos passar para a implementação de <code class='javascript'>_hasAccess</code>.</p>

<div class='codeblock'>
<p>padrão proxy</p>
<code class='javascript'
>'use strict';

const _hasAccess = (alvo, propriedade) =&gt; {
	if (propriedade.toString().startsWith('_')) {
		return false;
	}
	return true;
}</code
>
</div>

<p>Nesse caso, <strong>optei</strong> por identificar o controle de visibilidade através de uma <strong>convenção de nomes</strong> das propriedades. Notem que esta <strong>não é a única alternativa para identificação do controle de visibilidade,</strong> embora talvez seja a mais simples. Sinta-se à vontade para bolar sua própria alternativa.</p>

<p>Se as propriedades começarem pelo caractere <q>_</q> (<em>underscore</em>), o <code class='javascript'>Proxy</code> impedirá seu acesso. Porém, ele não funciona tão intuitivamente quanto poderia. Vamos ver alguns dos possíveis casos.</p>

<div class='codeblock'>
<p>problemas de proxy</p>
<code class='javascript'
>'use strict';

// define o comportamento do proxy
const proxyHandler = { /* omitido pra ficar mais curto */ };

// define a classe
class Cupcake {

	constructor() {
		Object.defineProperties(this, {
			_cobertura, {value: null, writable: true}, // privado, pois começa com _
			_recheioCk, {value: null, writable: true} // privado, pois começa com _
		});
	}

	<strong>// getters e setters  implícitos</strong>
	<strong class='small'>get cobertura() { return this._cobertura; }</strong>
	set cobertura(valor) { this._cobertura = valor; }
	get recheio() { return this._recheioCk; }
	set _recheio(valor) { this._recheioCk = valor; } // privado, pois começa com _

	<strong>// métodos</strong>
	<strong class='small'>usarCobertura() { console.log(this._cobertura); }</strong>

}

// cria uma instância
const cupcake = new Cupcake();
const cupcakeProxy = new Proxy(cupcake, proxyHandler);

// getters e setters implícitos
// seus acessos são interceptados pelo proxy
// mas os acesso feitos dentro do corpo deles não é vigiado
cupcakeProxy.cobertura = 'creme com suspiro';
<strong>console.log(cupcakeProxy.cobertura);</strong> <strong>// ok. this._cobertura é acessível dentro do getter implícito</strong>
console.log(cupcakeProxy.recheio);
cupcake._recheio = 'creme'; // erro, set _recheio é private como esperado

// chamada de método normal
// proxy age diferente nesse caso, interceptando os acessos dentro do corpo do método também
<strong>cupcakeProxy.usarCobertura();</strong> <strong>// erro! não consegue acessar this._cobertura de dentro do método!</strong></code
>
</div>

<p>Devido à essa inconsistência no comportamento do <code class='javascript'>Proxy</code>, temos que acessar algumas coisas através do objeto original. Infelizmente a especificação torna isso muito difícil propositalmente. Não existe maneira de saber quem está acessando as propriedades. Sendo assim, precisamos dar um jeito de manter o objeto original à mão.</p>

<div class='codeblock'>
<p>encapsulamento com proxies</p>
<code class='javascript'
>'use strict';

// define o comportamento do proxy
const proxyHandler = { /* omitido pra ficar mais curto */ };

// define a classe
class Cupcake {

	constructor() {
		Object.defineProperties(<strong>this</strong>, { <strong>// o construtor deve continuar usando this</strong>
			_cobertura, {value: null, writable: true}, // privado, pois começa com _
			_recheioCk, {value: null, writable: true} // privado, pois começa com _
		});
	}

	<strong>// getters e setters  implícitos</strong>
	get cobertura() { return <strong class='small'>self</strong>._cobertura; }
	set cobertura(valor) { self._cobertura = valor; }
	get recheio() { return self._recheioCk; }
	set _recheio(valor) { self._recheioCk = valor; } // privado, pois começa com _

	<strong>// métodos</strong>
	usarCobertura() { console.log(<strong>self</strong>._cobertura); }

}

// cria uma instância
<strong>const self = new Cupcake();</strong>
const cupcakeProxy = new Proxy(self, proxyHandler);

// getters e setters implícitos
// seus acessos são interceptados pelo proxy
// mas os acesso feitos dentro do corpo deles não é vigiado
cupcakeProxy.cobertura = 'creme com suspiro';
<strong>console.log(cupcakeProxy.cobertura);</strong> <strong>// ok, usa self internamente, que é a referência original sem proxy</strong>
console.log(cupcakeProxy.recheio);
cupcake._recheio = 'creme'; // erro, set _recheio é private como esperado

// chamada de método normal
// proxy age diferente nesse caso, interceptando os acessos dentro do corpo do método também
<strong>cupcakeProxy.usarCobertura();</strong> <strong>// ok, usa self internamente, que é a referência original sem proxy</strong></code
>
</div>

<p>Resta ainda facilitarmos o uso desse padrão. Fazendo alguns malabarismos com um <code class='javascript'>Proxy</code> a mais, permitimos que os objetos sejam instanciados de maneira transparente. O resultado final é bastante difícil de compreender para iniciantes em JavaScript, pois utiliza recursos idiomáticos da linguagem. Felizmente seu uso é bem mais simples.</p>

<div class='codeblock'>
<p>encapsulamento com proxies e factory</p>
<code class='javascript'
>'use strict';

// define o comportamento do proxy
const proxyHandler = { /* omitido pra ficar mais curto */ };

const proxyFactory = (Classe, proxyHandler) => {

	// este proxy extra serve apenas para permitir que instanciemos
	// nosso objeto e o proxy juntos de maneira transparente, com o operador new
	const proxy = new Proxy(class {}, {

		/** intercepta a construção de novos objetos */
		construct(alvo, parametros) {

			// salva o objeto original como self na closure do construtor
			const self = new Classe();

			// faz o contrutor retornar o proxy do objeto ao invés do objeto original
			const proxy = new Proxy(self, proxyHandler);
			return proxy;

		}

	});

	return proxy;

};

// define a classe tendo o cuidado de usar self, com exceção do construtor
// note que não é possível instanciá-la diretamente, pois self só existirá
// quando passarmos ela pela proxyFactory
class CupcakeDefinicao {
	constructor() { this._recheio = null; }
	usarRecheio() { console.log(self._recheio); }
}

// define classes filhas, seguindo os mesmos cuidados
class CupcakeCobertoDefinicao extends CupcakeDefinicao {
	constructor() {
		super();
		this._cobertura = null;
	}
	usarCobertura() { console.log(self._cobertura); }
}

// criar helpers para instanciar as classes com proxy
// são estes helpers que expomos para uso geral
const Cupcake = proxyFactory(CupcakeDefinicao, proxyHandler);
const CupcakeCoberto = proxyFactory(CupcakeCobertoDefinicao, proxyHandler);

// instancia e usa as classes de maneira fácil e transparente
// pelo menos essa parte é simples

const cupcakeDeChocolate = new Cupcake();
cupcakeDeChocolate.usarRecheio();

const cupcakeFlorestaNegra = new CupcakeCoberto();
cupcakeFlorestaNegra.usarRecheio();
cupcakeFlorestaNegra.usarCobertura();</code
>
</div>

<p>Não sei quanto a você, mas até alguém aparecer com uma maneira mais simples de controlar a visibilidade com <code class='javascript'>Proxy</code>, eu vou continuar deixando tudo público...</p>

<h3>Object.observe</h3>

<p>Caso você escute por aí sobre <code class='javascript'>Object.observe</code> nativo, saiba que era uma adição na <abbr>API</abbr> que o Google estava fazendo <em>lobbing</em> a favor por causa de seu<em>framework</em> Angular, mas que foi embora mesmo antes de entrar oficialmente. Sua funcionalidade pode ser <a href='https://github.com/anywhichway/proxy-observe' rel=external nofollow>replicada usando proxies</a>.</p>

<!--
<h3 id='proxyManual'>Controle de visibilidade com Proxy NÃO nativo</h3>

<p>Embora o <code class='javascript'>Proxy</code> nativo seja mais transparente do que uma alternativa <q>manual</q>, escrita em JavaScript, a alternativa posterior nos dá a vantagem de podermos decidir sobre as funcionalidades presentes em sua implementação. Isso nos permite por exemplo que o corpo dos métodos de nosso objeto não seja interceptado pelo proxy.</p>

<div class='codeblock'>
<p>encapsulamento com proxy e factory</p>
<code class='javascript'
>'use strict';

// TODO
class ProxyVisibilidade {
	constructor(Classe) {
		// copiar os métodos públicos
		// acessar as propriedades públicas através de getters e setters
	}
}
</code
>
</div>
-->

<h3>Controle de visibilidade com closures</h3>

<p>A classe <code class='javascript'>Proxy</code> pode nos ajudar com o controle de visibilidade das propriedades. Para casos mais simples, ou para ambientes onde ela não está disponível, podemos usar <em>closures</em> para simular esta funcionalidade, como vimos em <q>tirando coisas do escopo</q>. Primeiro <strong>criamos um escopo</strong> usando <abbr>AMD</abbr>, ou uma função anônima autoexecutável, ou uma função construtora, e <q>vazamos</q> desse escopo a parte que queremos usar como interface de nosso objeto. Este objeto será usado de maneira transparente, sem ninguém precisar saber que sua funcionalidade está fragmentada internamente. O exemplo abaixo mostra o essencial deste procedimento.</p>

<div class='codeblock'>
<p>encapsulamento com proxy e factory</p>
<code class='javascript'
>'use strict';

<strong>// estilo AMD</strong>
<strong class='small'>define('objeto', () => {</strong>

	const publico = {
		// acessar privado aqui dentro
	};

	const privado = {
		// se necessário, pode acessar publico
	};

	<strong>return publico;</strong> <strong>// expõe apenas a interface pública</strong>

<strong>});</strong>

<strong>// ou estilo função anônima autoexecutável</strong>
<strong class='small'>const objeto = (() => {</strong>

	const publico = {
		// acessar privado aqui dentro
	};

	const privado = {
		// se necessário, pode acessar publico
	};

	<strong>return publico;</strong> <strong>// expõe apenas a interface pública</strong>

<strong>})();</strong></code
>
</div>

<p>Um exemplo mais completo.</p>

<div class='codeblock'>
<p>encapsulamento com closures</p>
<code class='javascript'
>'use strict';

const matador = (function() {

	const publico = {

		matarACobra() {
			privado.matar();
		},

		get pau() {
			return privado.pau;
		}

	};

	const privado = {

		matar: function() {
			this.pau = 'quebrou';
		},

		pau: 'é feito de madeira!'

	};

	return publico;

})();

matador.matarACobra();
console.log(matador.pau); // mostra o pau ;)</code
>
</div>

<p><strong>Este padrão não é compatível com herança,</strong> pois a <em>closure</em> é compartilhada com todos os objetos do mesmo tipo e seus subobjetos.</p>

<div class='codeblock'>
<p>encapsulamento com closures e factory</p>
<code class='javascript'
>'use strict';

<strong>// NÃO COPIE!!! APENAS PARA DEMONSTRAÇÃO!!!!</strong>

const matador = algumMetodoQueUsaClosurePraSimularPrivate();

// não vai fazer o quê você espera!
const matador1 = Object.create(matador);
const matador2 = Object.create(matador);

matador1.matarACobra();
console.log(matador2.pau); // erro, pois matarACobra alterou a propriedade dos dois matadores</code
>
</div>

<p>É possível criar <strong>cópias da closure</strong> usando um padrão <em>factory</em>. Embora consigamos centralizar a definição da parte <em>private</em>, perdemos o benefício de economizarmos memória mantendo referências dos métodos.</p>

<div class='codeblock'>
<p>encapsulamento com closures e factory</p>
<code class='javascript'
>'use strict';

const matadorFactory = () => {

	const publico = {

		matarACobra() {
			privado.metodoInterno();
		},

		get pau() {
			return privado.propriedadeInterna;
		}

	};

	const privado = {

		metodoInterno: function() {
			console.log('método interno');
		},

		propriedadeInterna: 'é feito de madeira!'

	};

	return publico;

};


const matador1 = matadorFactory();
const matador2 = matadorFactory();
matador1.matarACobra();
console.log(matador2.pau); // ok</code
>
</div>

</section>



<section>

<h2 id='async'>Async <span>Yoda as coisas ordenando pode estar</span></h2>

<p>Código assíncrono, ou <em>async</em>, é uma maneira de evitar esperas longas em chamadas de funções que podem demorar muito para retornarem. Sendo mais técnico, evita que determinadas funções bloqueiem a execução da <em>thread</em> em que estão rodando. Especialmente útil em JavaScript onde o conceito de <em>threads</em> (através de <em>web workers</em>) é relativamente novo, e a maioria do código ainda tende a ser executado na <em>thread</em> da interface gráfica. O exemplo mais comum disso talvez sejam funções que executam requisições http. Código assíncrono permite que o processador fique livre para executar outras instruções como computar as interações do usuário, enquanto espera o retorno da requisição por exemplo.</p>

<p>Muito importante para a compreensão do <em>async</em> em JavaScript é o conceito de <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop' rel='external nofollow'><em>event loop</em></a>. Ele se trata de uma fila de execução de blocos de código. O que define a divisão entre um bloco e outro é o nível de empilhamento das funções executadas. Quando chamamos uma função dentro de outra, esta segunda função é empilhada em cima da primeira. Quando sua execução termina, ela é desempilhada, e o controle da execução volta à primeira função da pilha. Quando esta função por sua vez, termina a execução, todas as funções são desempilhadas e o bloco de código chega ao fim. <strong>O modelo de execução de JavaScript garante que um bloco de código não pode ser interrompido antes de chegar ao fim, eliminando erros de concorrência.</strong> O que as funções assíncronas fazem é executar determinadas linhas <strong>entre os blocos de código</strong> de maneiras variadas.</p>

<p>Outra característica das funções <em>async</em> é que elas tendem a mudar o contexto de execução para a <code class='javascript'>window</code>, e portanto cuidados adicionais devem ser tomados no uso de <code class='javascript'>this</code>.</p>

<p>Vamos ver algumas formas de código assíncrono.</p>

<h3 id='eventos'>Eventos</h3>

<p>Já andamos flertando com eventos em diversos de nossos exemplos. Agora temos conhecimento suficiente para os vermos mais detalhadamente.</p>

<p>Eventos são a implementação nativa do padrão de projeto (<em>design pattern</em>) chamado <a href='https://sourcemaking.com/design_patterns/observer'><em>Observer</em></a>. É usada mais frequentemente na interface gráfica para responder às ações do usuário como cliques do mouse ou scroll da página, e outros eventos como o carregamento completo da página e requisições http. Eventos adicionam um <em>callback</em> na fila do <em>event loop</em> assim que são disparados, e seus observadores são notificados assim que todas as funções sendo atualmente executadas sejam desempilhadas.</p>

<p>Para indicar que estamos interessados num determinado evento, usamos o método <code class='javascript'>addEventListener</code>. <strong>Devemos desregistrar o evento quando não estamos mais interessados</strong> nele, através de <code class='javascript'>removeEventListener</code>, para evitar uso desnecessário de memória e tornar o coletor de lixo mais lento. IE8- utiliza um outro método não padronizado para registrar eventos, e nesses casos é necessário o uso de um <em>fallback</em>.</p>

<div class='codeblock'>
<p>eventos</p>
<code class='javascript'
>'use strict';

// evento de clique num botão, pode acontecer diversas vezes

const botao = document.getElementById('botao');
botao.addEventListener('click', (evento) => {
	// botao guarda esse callback e o executa apenas quando é clicado
	// o callback de addEventListener recebe informações sobre o evento ocorrido
	// tais como qual a tecla pressionada, ou quem disparou o evento através
	// do objeto evento
	evento.target.value = 'clicou'; // muda o texto do botão clicado para clicou
});

// evento de conclusão da requisição http, acontece apenas uma vez

function requisicaoLoad(evento) {
	console.log(requisicao.responseText); // mostra a resposta da requisição
	evento.target.removeEventListener('load', requisicaoLoad); // remove o listener da requisicao e libera memória
}

const requisicao = new XMLHttpRequest();
requisicao.addEventListener('load', requisicaoLoad); // requisicao guarda esse callback e o executa apenas quando receber uma resposta
requisicao.open('GET', 'lista.json');
requisicao.send();</code
>
</div>

<h3>setTimeout, setInterval e requestAnimationFrame</h3>

<p>Estas funções são na verdade métodos do objeto <code class='javascript'>window</code> que faz parte do <abbr title='Document Object Model'>DOM</abbr>. Assim como outros métodos assíncronos, elas adicionam um <em>callback</em> na fila do <em>event loop</em>. O que diferencia essas funções <em>async</em> é que podemos determinar um tempo de espera para a execução do <em>callback</em>. Ou seja, assim que o tempo determinado chegar, o ambiente de execução irá esperar que todas as funções sendo atualmente executadas sejam desempilhadas, e então executará o <em>callback</em>, ficando desbloqueado nesse meio tempo de espera.</p>

<div class='codeblock'>
<p>async e tempos de espera</p>
<code class='javascript'
>'use strict';

const time = 1000; // 1 segundo, ou 1000 milissegundos

const intervalId = setInterval(() => {
	// vai executa aproximadamente a cada 1 segundo
	// cancela com clearInterval(intervalId);
}, time);

const timeoutId = setTimeout((evento) => {
	// vai executar uma única vez em aproximadamente 1 segundo
	// cancela com clearTimeout(timeoutId);
}, time);

setTimeout((evento) => {
	// vai executar quase que imediatamente
	// usado principalmente para prevenir bloqueios muito longos na thread
	// pois o código entra na fila do event loop ao invés de ser empilhado
}, 0);

requestAnimationFrame((timestamp) => {
	// parecido com setTimeout 0, mas
	// vai executar no próximo quadro
});</code
>
</div>

<p><code class='javascript'>setTimeout</code> e <code class='javascript'>requestAnimationFrame</code> têm um outro uso secundário, que é evitar que o navegador <q>coma</q> alguns passos que ele julgar desnecessários.</p>

<div class='codeblock'>
<p>animacao.css</p>
<code class='css bubaloop'
><span class='comment'>/* Indica que a mudança de cor do elemento devem ser animada */</span>
<span class='selector'>#elementoAnimado</span> <span class='punctuation'>{</span>
	<span class='property'>transition</span><span class='punctuation'>:</span> <span class='value'>color 300ms</span><span class='punctuation'>;</span>
<span class='punctuation'>}</span></code
>
</div>

<div class='codeblock'>
<p>animacao.js</p>
<code class='javascript'
>'use strict';

const div = document.getElementById('elementoAnimado');
const preto = '#000000';
const branco = '#ffffff';

div.style.color = preto; // o navegador irá ignorar esta linha por motivos de performance
div.style.color = branco; // pois esta linha já anula a anterior muito rapidamente

// infelizmente o comportamento acima impede que nossa animação seja executada
// a maneira de impedir essa "otimização" é indicar que queremos mudar de cor
// assim que possível, mas não imediatamente, utilizando uma das formas abaixo

div.style.color = preto;

setTimeout(() => {
	div.style.color = branco;
}, 0);

// ou

div.style.color = preto;

requestAnimationFrame((timestamp) => {
	div.style.color = branco;
});</code
>
</div>

<p>Quando desejamos criar animações por programação ou fazermos um laço principal, como em jogos, é mais apropriado utilizar a função <code class='javascript'>requestAnimationFrame</code>, que está disponível à partir do IE10.</p>

<div class='codeblock'>
<p>requestAnimationFrame loop</p>
<code class='javascript'
>'use strict';

// executa a função a cada quadro que o navegador mostrar
// o mais comum é chamá-la numa taxa de 60Hz, ou 16,66ms
// mais isso varia de acordo com o monitor, placa de vídeo, etc.
gameLoop(timestamp) {
	// executar a lógica do quadro aqui
	requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);</code
>
</div>

<h3 id='promise'>Promises nativas</h3>

<p>Surgindo em diversas linguagens nos últimos tempos, JavaScript também tem uma implementação nativa de <em>Promises</em>, que já eram disponíveis através de bibliotecas como <a href='https://github.com/kriskowal/q'>Q</a> (usada no Angular) e <a href='https://github.com/tildeio/rsvp.js/'>RSVP</a> (usada no Ember). <em>Promises</em> em JavaScript adicionam um <em>callback</em> ao <em>event loop</em> assim que são cumpridas.</p>

<div class='codeblock'>
<p>sintaxe nativa de promises</p>
<code class='javascript'
>'use strict';

function algumaCoisaAsync() {

	const promessa = new Promise((resolve, reject) => {
		// fazer alguma coisa demorada e se sucesso:
		resolve(algumValorOpcional);
		// ou se erro
		reject('motivo');
	});

	return promessa;

}

algumaCoisaAsync()
	.then((algumValorOpcional) => {
		// executar algo depois da operação async
	});</code
>
</div>

<p>O propósito de fazer promessas, ao contrário do que dizem as más línguas, não é quebrá-las, mas sim tornar a execução do seu código assíncrono mais linear. Eventos previstos para disparar apenas uma única vez são bons candidatos para a conversão em promessas.</p>

<p>O que antigamente seria escrito como:</p>

<div class='codeblock'>
<p>requisição xml http clássica com eventos e callbacks</p>
<code class='javascript'
>'use strict';

function transferComplete(evento) {
	// fazer algo e então
	evento.target.removeEventListener('load', transferComplete);
}

function transferFailed(evento) {
	// fazer algo e então
	evento.target.removeEventListener('load', transferComplete);
}

let requisicao = new XMLHttpRequest();
requisicao.addEventListener('load', transferComplete);
requisicao.addEventListener('error', transferFailed);
requisicao.open('GET', 'lista.json');
requisicao.send();</code
>
</div>

<p>Agora pode ser escrito como:</p>

<div class='codeblock'>
<p>requisição xml http com promises</p>
<code class='javascript'
>'use strict';

requisicao('GET', 'lista.json')
	.then(
		resposta =&gt; console.log(resposta),
			erro =&gt; console.log(erro)
		);</code
>
</div>

<p>Desde que você escreva um <a href='http://www.html5rocks.com/en/tutorials/es6/promises/#toc-promisifying-xmlhttprequest' rel='external nofollow'><em>wrapper</em> bonitinho</a> ao redor das chamadas para as requisições.</p>

<p>Concordo que o exemplo acima não é muito impressionante. A real força das promessas vem do amor S2. Opa, não não, quero dizer, a real força das promessas pode ser vista quando temos que encadear ou executar em "paralelo" várias chamadas assíncronas. Digo "paralelo" porque paralelismo em JavaScript é um caso à parte. Não vai achar que funciona igual que no C que o seu avô usou pra programar o <a href='https://en.wikipedia.org/wiki/Pong#/media/File:Pong.png' rel='external nofollow'>Pong original</a>, né? Vamos por enquanto só ver exemplos práticos ao que diz respeito às promessas.</p>

<p>Digamos que você queira o endereço e fuso horário de um local qualquer. Uma abordagem ingênua poderia gerar isso:</p>

<div class='codeblock'>
<p>macarrão de requisições e callbacks</p>
<code class='javascript'
>'use strict';

// passo 2
function requisitar(endereco, callback) {
	let requisicao = new XMLHttpRequest();
	requisicao.addEventListener('load', callback);
	requisicao.open('GET', endereco);
	requisicao.send();
}

// passo 3
function localizacaoLoaded(resposta) {
	requisitar('geocode', geocodeLoaded);
	requisitar('fusoHorario', fusoHorarioLoaded);
}

// passos 4 e 5

function geocodeLoaded(resposta) {
	resultados.endereco = resposta;
	resultados.semaforo++;
	pronto();
}

function fusoHorarioLoaded(resposta) {
	resultados.fusoHorario = resposta;
	resultados.semaforo++;
	pronto();
}

// passo 7
function pronto() {
	if (resultados.semaforo === 2) {
		finalmente();
	}
}

// passo 8 (final)
function finalmente() {
	// quer ao sugo, marinara ou alho e óleo?
}

// passo 6
var resultados = {
	semaforo = 0,
	endereco: null,
	fusoHorario = null
};

// passo 1
requisitar('localizacao', localizacaoLoaded);</code
>
</div>

<p>Claro que poderíamos organizar a lógica acima de diversas maneiras, evitando variáveis globais, etc. Porém, notem como promessas fornecem uma solução flexível para o problema em questão, e também reaproveitável para outros padrões de execução assíncronos.</p>

<div class='codeblock'>
<p>requisições organizadas com promises</p>
<code class='javascript'
>'use strict';

requisicao('localizacao')
	.then((resposta) =&gt; {
		const coordenadas = `?lat=${resposta.latitude}&amp;lng=${resposta.longitude}`;
		// executa duas requisições em paralelo, após a
		// requisição original ter concluído
		return Promise.all([
			requisicao('geocode' + coordenadas),
			requisicao('fusoHorario' + coordenadas)
		]);
	})
	.then((respostas) =&gt; {
		const endereco = respostas[0];
		const fusoHorario = respostas[1];
		// exercite sua criatividade aqui ;)
	});</code
>
</div>

<p>Bem melhor não é? O procedimento necessário para encadear várias ações assíncronas é retornar uma nova promessa dentro do then da promessa anterior. No nosso exemplo, Promise.all faz exatamente isso, retorna uma nova promessa que será cumprida assim que todas as requisições completarem. Maios ou menos como uma <a href='https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CyclicBarrier.html' rel='external nofollow'>barreira cíclica</a>, só que com promessas ao invés de <em>threads</em>.</p>

<p>Não por acaso, um tempo atrás li uma conversa (no mesmo link acima do wrapper bonitinho) de que promessas poderiam ser usadas justamente para padronizar várias APIs assíncronas que foram sendo inclusas na linguagem ao longo dos tempos, tais como queries em IndexedDBs, requisições http, acesso à arquivos, etc. É pagar pra ver.</p>

<h3 id='deferred'>Deferreds</h3>

<p>Promises requerem que você já saiba como vão resolvê-las, logo que elas são criadas. Se você não souber, pode implementar um objeto <em>deferred</em>, que permite postergar esta decisão.</p>

<div class='codeblock'>
<p>deferreds</p>
<code class='javascript'
>'use strict';

class Deferred {

	constructor() {

		Object.defineProperties(this, {
			_promise: {writable: true, value: null},
			_resolve: {writable: true, value: null},
			_reject: {writable: true, value: null}
		});

		Object.seal(this);

		this._promise = new Promise(((resolve, reject) =&gt; {
			this._resolve = resolve;
			this._reject = reject;
		}).bind(this));

	}

	resolve(value) {
		return this._resolve(value);
	}

	reject(reason) {
		return this._reject(reason);
	}

	then(callbackAsync) {
		return this._promise.then(callbackAsync);
	}

};

// promises sabem como serão resolvidas no momento da criação obrigatoriamente
const promise = new Promise((resolve, reject) => {
	// se nao definirmos aqui, a promessa nunca será cumprida
	setTimeout(() => {
		resolve();
	}, 1000);
});

// deferreds podem ter seu modo de resolução determinado depois de sua criação
// criamos o objeto sem indicar mais nada
const deferred = new Deferred();

// então podemos passá-lo para métodos
// retorná-lo dentro de funções
// armazenar em arrays
// e só depois decidir quando chamar resolve ou reject neles
setTimeout(() => {
	deferred.resolve();
}, 1000);</code
>
</div>

<h3 id='generator'>Generators</h3>

<p>Tenho sentimentos confusos quanto à utilidade desta funcionalidade (que por si só já é confusa pra c@#$%☠), uma vez que o conceito de <em>generators</em> já existe há tempos em <a href='https://en.wikipedia.org/wiki/Generator_(computer_programming)' rel='external nofollow'>outras linguagens</a> (C++, C#, Java e Python são exemplos) e não vejo pessoas dizendo como isso revolucionou o modo como elas programam. Mas sinto que não é o que está tentando se fazer parecer quanto a <em>generators</em> em JavaScript. Vai entender.</p>

<p>A implementação nativa deste conceito deveria facilitar a criação de <em>generators</em> e iterators. Mas sinceramente não funciona tão bem para todos os casos. De fato, o caso mais simples para o qual eles foram criados parece ser o menos beneficiado pela implementação nativa, e as alternativas escritas utilizando objetos, <a href='https://en.wikipedia.org/wiki/Function_object' rel='external nofollow'>functors ou closures</a> são bastante atraentes. O principal motivo de tanto frisson parece ser o uso não tão óbvio dos <em>generators</em> para mais um modelo de execução assíncrona (quantos nós já temos até agora? Já perdi a conta).</p>

<p>Mas chega de falar e vamos mostrar algum código. Gerar ou percorrer uma coleção de itens em partes, a fim de distribuir o tempo de processamento, parece ser o propósito mais comum. Para tanto, precisamos de um meio de guardar em que pedaço da coleção nós paramos. Vamos comparar as possíveis implementações.</p>

<p>Primeiro usando objetos simples para guardar o estado do processo todo.</p>

<div class='codeblock'>
<p>guardando estado entre chamadas de funções com objetos</p>
<code class='javascript'
>'use strict';

let colecao = {

	// propriedades
	itensPorPagina: 0,
	marcador: 0,
	pagina: null,
	valor: obterArrayMagicamente(),

	// métodos
	paginar: function(itensPorPagina) {
		if (this.marcador &lt; this.valor.length) {
			this.pagina =  this.valor.slice(
				this.marcador,
				this.marcador + itensPorPagina
			);
			this.marcador += itensPorPagina;
		}
		return this.pagina;
	}

};

function clickHandler() {
	colecao.paginar();
	// colecao.pagina contém os resultados
	// mostrar a página
}

colecao.itensPorPagina = 10;
botaoProximo.addEventListener('click', clickHandler);</code
>
</div>

<p>Agora utilizando um estilo funcional, com closures:</p>

<div class='codeblock'>
<p>guardando estado entre chamadas de funções com closures</p>
<code class='javascript'
>'use strict';

function getPaginador(colecao, itensPorPagina) {

	// variáveis capturadas pela closure
	const total = colecao.length;
	let marcador = 0;
	let pagina = null;

	// função da closure
	return function paginar() {

		if (marcador &lt; total) {
			pagina =  colecao.slice(
				marcador,
				marcador + itensPorPagina
			);
			marcador += itensPorPagina;
		}

		return pagina;

	}

}

const colecao = obterArrayMagicamente();
const paginar = getPaginador(colecao, 10);
let pagina = null;

function clickHandler() {
	pagina = paginar();
	// mostrar a página
}

botaoProximo.addEventListener('click', clickHandler);</code
>
</div>

<p>Poderíamos ainda criar uma implementação adicionando as propriedades de estado diretamente nas funções (uma vez que em JavaScript elas são objetos dinâmicos), mas acho que você já deve ter pego o espírito da coisa.</p>

<p>As maneira que as funções generator nativas expõem para guardar as informações de que precisaremos, é permitir sua interrupção e retomada quando nós quisermos, através de instruções específicas e de um iterator. Ela pode ser escrita da seguinte maneira:</p>

<div class='codeblock'>
<p>guardando estado entre chamadas de funções com generators</p>
<code class='javascript'
>'use strict';

// declaramos generators com "function*"
function* paginar(colecao, itensPorPagina) {

	const total = colecao.length;
	let marcador = 0;

	while(marcador &lt; total) {

		// "yield" pausa a execução da função
		// e permite resumi-la depois neste mesmo ponto
		// "yield" também pode retornar um valor, assim
		// como "return", mas sem terminar a função
		yield colecao.slice(marcador, marcador + itensPorPagina);

		marcador += itensPorPagina;

	}

}

let colecao = obterArrayMagicamente();
let paginador = paginar(colecao, 10);
let pagina = null;

function clickHandler() {

	// o método "next" executa a função de onde parou
	// até encontrar uma instrução "yield"
	pagina = paginador.next();

	// além do valor retornado por "yield", "next" também indica
	// se a função terminou definitivamente com um "return"
	// e nesse caso done teria o valor true
	// ou se apenas foi interrompida com "yield", e nesse caso
	// done teria o valor false, e podemos chamar "next" novamente
	if (!pagina.done) {
		// pagina.value contém os resultados
		// mostrar a página
	}

}

botaoProximo.addEventListener('click', clickHandler);</code
>
</div>

<p>Simplificando, uma função normal quando chamada, recebe alguns parâmetros e executa até o fim, retornando um valor. Uma função <em>generator</em> nativa pode ter <q>chamadas parciais</q>, retornando resultados parciais, antes de terminar sua execução completa retornando um valor. Fazemos isso através do método <code class='javascript'>next</code> do iterador que ela retorna e da palavra-chave <code class='javascript'>yield</code>.</p>

<p>Agora, porque foi utilizado o padrão de iteração:</p>

<div class='codeblock'>
<p>iterador estilo JavaScript ES6</p>
<code class='javascript'
>'use strict';

do {
	resultado = iterador.next();
	if (resultado.value) { // verifica antes de usar resultado.value
		// pode usar resultado.value
	}
} while (!resultado.done)</code
>
</div>

<p>Ao invés dos mais conhecidos, e que me parecem ligeiramente mais intuitivos:</p>

<div class='codeblock'>
<p>iterador estilo Java e C#</p>
<code class='javascript'
>'use strict';

while (iterator.hasNext()) {
	resultado = iterator.next(); // use resultado sem medo, ele sempre será válido
}

while (iterator.MoveNext()) {
	resultado = iterator.Current; // use resultado sem medo, ele sempre será válido
}</code
>
</div>

<p>Eu acho que não vou descobrir tão cedo. Quero dizer, não é o iterador que terminou? Então não é ele que deveria dizer isso? Qual o motivo de colocar essa informação no resultado??</p>

<p>De qualquer maneira. As chamadas parciais à função <em>generator</em> também podem receber argumentos. Fazemos isso passando um parâmetro na chamada do <code class='javascript'>next</code>. Para manter os exemplos simples, nosso paginador até agora só foi capaz de avançar. Vou continuar com a demonstração dessa funcionalidade duvidosa, adicionando a possibilidade do paginador também voltar (tipo um revival do passado :P ), passando para <code class='javascript'>next</code> o argumento necessário.</p>

<div class='codeblock'>
<p>paginador usando generators</p>
<code class='javascript'
>'use strict';

const AVANCAR = 1;
const VOLTAR  = -1;

function* paginar(colecao, itensPorPagina) {

	const total = colecao.length;
	let marcador = 0;
	let direcao = yield; // inicia "direcao" antes do loop

	while(marcador &gt;= 0 &amp;&amp; marcador &lt; total) {
		direcao = yield colecao.slice(
			marcador,
			marcador + itensPorPagina
		);
		marcador += itensPorPagina * direcao;
	}

}

let resultados = obterArrayMagicamente();
let paginador = paginar(resultados);

// prepara o paginador para iniciar direcao
paginador.next();

function clickAnteriorHandler() {
	mostrar(VOLTAR);
}

function clickProximoHandler() {
	mostrar(AVANCAR);
}

let result = null;
let pagina = null;

function mostrar(direcao) {
	result = paginador.next(direcao);
	if (!result.done) {
		pagina = result.value;
		// mostrar a página
	}
}

botaoAnterior.addEventListener('click', clickAnteriorHandler);
botaoProximo.addEventListener('click', clickProximoHandler);</code
>
</div>

<p>Se quisermos implementar nosso próprio iterador, que funcione com a sintaxe <code class='javascript'>for of</code>, nossa classe deve implementar um método especial chamado <code class='javascript'>[Symbol.iterator]</code>. Como esse método precisa ser um <em>generator</em>, usamos uma sintaxe especial para indicar isso, precedendo o nome do método com um <code class='javascript'>*</code>.</p>

<div class='codeblock'>
<p>Paginador usando Symbol.iterator</p>
<code class='javascript'
>'use strict';

class Paginador {

	constructor(colecao, itensPorPagina) {

		Object.defineProperties({
			_colecao: {value: colecao},
			_total: {value: colecao.length},
			_itensPorPagina: {value: itensPorPagina, writable: true},
			_marcador: {value: 0, writable: true}
		});

		Object.seal(this);

		this.reset();

	}

	// iterador for of
	*[Symbol.iterator]() {
		if(this._marcador &lt; this._total) {
			yield colecao.slice(
				this._marcador,
				this._marcador + this._itensPorPagina
			);
			this._marcador += this._itensPorPagina;
		}
	}

	reset() {
		this._marcador = 0;
	}

}

let colecao = obterArrayMagicamente();
let paginador = new Paginador(colecao, 10);

for (let paginas of paginador) {
	console.log(paginas);
}</code
>
</div>

<p>Como nada disso me parece novo ou incrivelmente útil, vou logo passar para a outra funcionalidade que comentei lá em cima. A de que <em>generators</em> podem ser usados como mais uma alternativa de modelo de execução assíncrono, muito parecida com o <code class='generic'><span class='keyword'>async</span></code> e <code class='generic'><span class='keyword'>await</span></code> do C#. Essa ideia parece ser forte o suficiente a ponto de ter motivado uma <a href='https://github.com/tc39/ecmascript-asyncawait' rel='external nofollow'>nova proposta</a> ao comitê técnico (TC39, que padroniza a especificação a qual o JavaScript se baseia), bem como a criação da biblioteca <a href='https://github.com/tj/co' rel='external nofollow'>co</a>.Uma vez que temos uma interface padronizada para identificar, pausar e resumir funções, podemos escrever uma função de ordem superior que controle a execução dos <em>generators</em>.</p>

<div class='codeblock'>
<p>simulando async e await do C#</p>
<code class='javascript'
>'use strict';

// função de controle + function* é quase como async
// e yield como await
controle(function*() {
	yield metodoAsync();
	yield outroMetodo();
});</code
>
</div>

<p>Tal função de controle não é tão simples de ser escrita, uma vez que uma implementação simplicista pode não prover toda a fluidez de execução que o modelo assíncrono disponibiliza, causar pilhas de execução muito grandes, etc. já que é necessário conhecimento moderado de como funciona o modelo de execução do JavaScript, o vulgo event loop. Se este é um modelo tão mais prático em JavaScript que do que outras alternativas eu não sei dizer. Certamente preciso escrever vários testes antes de decidir. Apenas gostaria que as pessoas escolhessem um modelo assíncrono e ficassem com ele, ao invés de ficarem adicionando mais e mais alternativas, deixando tudo labirintoso.</p>

<h3>Web Workers (Threads)</h3>

<p>Threads em JavaScript funcionam de maneira diferente das funcionalidades equivalentes em outras linguagens. Elas não compartilham memória. A maneira de se comunicarem é através de troca de mensagens, que possui limitações sobre o tipo de objeto que pode ser enviado. De fato, threads de outras linguagens se parecem mais com o que conseguimos simular com <code class='javascript'>setTimeout</code> e <code class='javascript'>setInterval</code> do que com objetos <code class='javascript'>Worker</code>. Worker threads não conseguem de maneira nenhuma acessar a interface gráfica.</p>

<div class='codeblock'>

<p>JavaScript - main.js</p>
<code class='javascript'
>'use strict';

// cria a worker thread de uso exclusivo
// da main thread
let webWorker = new Worker('worker.js');

// web workers não compartilham memória
// apenas trocam mensagens entre si
// e não podem acessar o DOM

// envia mensagens para a worker thread
webWorker.postMessage(['algum', 'valor']);
webWorker.postMessage([10, 20]);

// callback para recepção de mensagens
// da worker thread
webWorker.onmessage = (event) => {
	console.log(event.data);
};

// mata a thread imediatamente se quiser
// webWorker.terminate();</code
>

<p>JavaScript - worker.js</p>
<code class='javascript'
>'use strict';

// callback para recepção de mensagens
// da main thread (ui thread)
onmessage = (event) => {

	console.log(event.data[0]);
	console.log(event.data[1]);
	let result = event.data.join(' ');

	// envia mensagens para a main thread
	postMessage(result);

	// termina a thread se quiser
	// close();

};</code
>

</div>

<div class='codeblock'>

<p>JavaScript - sharedThread1.js</p>
<code class='javascript'
>'use strict';

<strong>// cria uma worker thread compartilhada</strong>
let <strong class='small'>webWorkerOp1</strong> = new <strong class='small'>SharedWorker(</strong>'worker.js'<strong class='small'>);</strong>

// envia mensagens para a worker thread compartilhada
webWorkerOp1<strong>.port</strong>.postMessage(['algum', 'valor']);
webWorkerOp1<strong>.port</strong>.postMessage([10, 20]);

// callback para recepção de mensagens
// da worker thread
webWorkerOp1<strong>.port</strong>.onmessage = (event) => {
	console.log(event.data);
};</code
>

<p>JavaScript - sharedThread2.js</p>
<code class='javascript'
>'use strict';

// cria uma worker thread compartilhada
let <strong>webWorkerOp2</strong> = new <strong>SharedWorker(</strong>'worker.js'<strong>);</strong>

// envia mensagens para a worker thread compartilhada
webWorkerOp2<strong>.port</strong>.postMessage(['misturar', 2]);
webWorkerOp2<strong>.port</strong>.postMessage([10, 20]);

// callback para recepção de mensagens
// da worker thread
webWorkerOp2<strong>.port</strong>.onmessage = (event) => {
	console.log(event.data);
};</code
>

<p>JavaScript - worker.js</p>
<code class='javascript'
>'use strict';

<strong>onconnect = (event) => {</strong>

	<strong>let port = event.ports[0];</strong>

	// callback para recepção de mensagens
	// da main thread (ui thread)
	<strong>port.</strong>onmessage = (event) => {

		console.log(event.data[0]);
		console.log(event.data[1]);
		let result = event.data.join(' ');

		// envia mensagens para a main thread
		<strong>port.</strong>postMessage(result);

		// termina a thread se quiser
		// close();

	};

<strong>};</strong></code
>

</div>

</div>

</section>



<section>

<h2>Nota final</h2>

<p>Podemos verificar nosso código com ESLint, JSHint ou JSLint, que nos dão dicas para melhorá-lo.</p>

</section>

<section>

<h2>Apêndice</h2>

<p>SOLUÇÃO 3 - Postergar execução na programação</p>

<div class='codeblock'>
<p>seosoquenaoS3.htm</p>
<code class='html'
>&lt;!DOCTYPE html&gt;
&lt;html
	xmlns='http://www.w3.org/1999/xhtml'
	lang='pt-BR'
	xml:lang='pt-br'
	&gt;
<strong>&lt;head&gt;</strong>
	&lt;title&gt;Google está olhando&lt;/title&gt;
	&lt;meta charset='utf-8' /&gt;
	&lt;script src='//code.jquery.com/jquery-1.10.2.min.js'&gt;&lt;/script&gt;
	<strong>&lt;script src='seosoquenaoS3.js'&gt;&lt;/script&gt;</strong>
<strong>&lt;/head&gt;</strong>
&lt;body&gt;
	<strong>&lt;h1 id='tagTitulo'&gt;</strong>Acessibilidade e SEO&lt;/h1&gt;
	<strong>&lt;p id='tagParagrafo'&gt;</strong>
		Sim pequeno gafanhoto, html tem mais de 100 tags
		diferentes além de table e div.
	&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code
>
</div>

<div class='codeblock'>
<p>seosoquenaoS3b.js</p>
<code class='javascript'
>'use strict';

<strong>function init() {</strong>

	// pega elementos da página pela id e os torna manipuláveis dentro do JavaScript
	var titulo = document<strong>.getElementById('tagTitulo');</strong>
	var paragrafo = document<strong>.getElementById('tagParagrafo');</strong>

	titulo.innerHTML = 'Black hat SEO';
	paragrafo.attributes.add('style', 'display: none');

<strong>}</strong>

<strong>// Espera o documento estar pronto para buscar na página</strong>
<strong class='small'>jQuery(document).ready(</strong>function(evento) {
	<strong>init();</strong>
}<strong>);</strong></code
>
</div>

<p>Como citei lá no comecinho, jQuery ganhou fama justamente por esconder as várias incompatibilidades entre os navegadores através de sua API. Este exemplo faz a mesma coisa que o exemplo anterior, porém depende de uma biblioteca externa. Se isso não for um problema pra vc, vai em frente. A sintaxe do jQuery é um pouco diferente do JavaScript convencional, e será abordada mais pra frente.</p>

<div class='codeblock'>
<p>seosoquenaoS3.js</p>
<code class='javascript'
>'use strict';

function init() {

	// pega elementos da página pela id e os torna manipuláveis dentro do JavaScript
	var titulo = document.getElementById('tagTitulo');
	var paragrafo = document.getElementById('tagParagrafo');

	titulo.innerHTML = 'Black hat SEO';
	paragrafo.attributes.add('style', 'display: none');

}

// verifica se o JavaScript rodou após o evento de carregamento completado da página
if (document.readyState === 'interactive'
	|| document.readyState === 'complete'
	|| document.readyState === 'loaded'
	) {

	init();

// se não, se registra para executar no evento
} else {

	// registro do evento para navegadores legais
	if (document.addEventListener) {
		document.addEventListener('DOMContentLoaded', init);

	// registro de evento para IE8-
	} else if (window.attachEvent) {
		window.attachEvent('onload', init);
	}

}</code
>
</div>

<p>Esta solução é a mais compatível. Porém, precisamos adicionar uma verificação meio grande pra tudo funcionar de acordo com o que esperamos. Note que, dependendo do momento em que o JavaScript passa a existir na página, o evento indicando que o processamento do html terminou pode já ter sido disparado. Existe também a questão de compatibilidade com IEs antigos. Claro que podemos refatorar esse código e facilitar o uso deste evento. Mas aqui no ICI fazemos outra coisa. Usamos jQuery.</p>

<p>Ou usando closures.</p>

<div class='codeblock'>
<p>dropdown.js</p>
<code class='javascript'
>'use strict';

let dropdown = (function() {

	let publico = {

		init: function(idConteiner) {
			privado.idConteiner = idConteiner;
			privado.conteiner = document.getElementById(privado.idConteiner);
			privado.rotulo = privado.conteiner.querySelector('button');
			privado.lista = privado.conteiner.querySelector('ul');
			privado.rotulo.addEventListener('click', this.clickHandler.bind(this));
		},

		clickHandler: function(evento) {
			privado.visivel = !privado.visivel;
			privado.atualizar();
		}

	};

	let privado = {

		atualizar: function() {
			if (this.visible) {
				this.lista.style.display = 'block';
				return;
			}
			this.lista.style.display = 'none';
		},

		idConteiner: null,

		conteiner: null

		rotulo: null,

		lista: null,

		visivel: false

	};

	return publico;

})();</code
>
</div>

</section>


</body>
</html>