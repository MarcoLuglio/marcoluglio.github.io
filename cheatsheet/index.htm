<!DOCTYPE html>
<html
	xmlns='http://www.w3.org/1999/xhtml'
	lang='pt-BR'
	xml:lang='pt-br'
	>
<head>
	<title>Cheat Sheet</title>
	<meta charset='utf-8' />
	<link rel='stylesheet' href='css/main.css' />
	<script src='../tutorialjs/js/utils.js'></script>
	<script src='../tutorialjs/js/index.js'></script>
	<script src='../tutorialjs/js/highlighter.js'></script>
	<script src='js/extendedhighlighter.js'></script>
	<script src='js/home.js'></script>
</head>
<body>



<h1>Cheat Sheet <span>para Programadores Mobile</span></h1>

<p><strong>WORK IN PROGRESS ;)</strong></p>

<p>Artigo criado por necessidades pr√°ticas no desenvolvimento de aplicativos para dispositivos m√≥veis. Fui parcialmente inspirado no <a rel='external nofollow' href='http://www.25hoursaday.com/CsharpVsJava.html'>artigo ic√¥nico de Dare Obasanjo comparando C# e Java</a>.</p>
<p>√â quase como um Rust vs C++ vs Objective-c vs Swift vs Kotlin vs Java vs C# vs JavaScript :P</p>

<section>

<h2>√çndice</h2>
<nav id='indice'>
</nav>

</section>



<section>

<h2 id='olamundo'>Ol√° Mundo</h2>

<div class='comparison'>

<div class='codeblock'>
<p>Rust - Ol√° Mundo - mais.rs</p>
<code class='rust'
>// requer uma fun√ß√£o main
fn main() {
	println!("Ol√° Mundo");
}</code
>
</div>

<div class='codeblock'>
<p>C++ - Ol√° Mundo - main.cpp</p>
<code class='cpp'
>// requer uma biblioteca para IO
#include &lt;iostream&gt;

// requer uma fun√ß√£o main na raiz
int main(int argc, const char* argv[]) {
	std::cout &lt;&lt; "Ol√° Mundo";
	// requer um c√≥digo de retorno
	return 0;
}</code
>
</div>

<div class='codeblock'>
<p>Objective-C - Ol√° Mundo - main.m</p>
<code class='objectivec'
>// requer uma biblioteca para IO
#import &lt;Foundation/Foundation.h&gt;

// requer uma fun√ß√£o main
int main(int argc, const char* argv[]) {
	NSLog(@"Ol√° Mundo");
	// requer um c√≥digo de retorno
	return 0;
}</code
>
</div>

<div class='codeblock'>
<p>Swift - Ol√° Mundo - main.swift</p>
<code class='swift'
>print("Ol√° Mundo")</code
>
</div>

<div class='codeblock'>
<p>Kotlin - Ol√° Mundo - main.kt</p>
<code class='kotlin'
>fun main(args: Array&lt;String&gt;) {
	println("Hello, world!")
}</code
></div>

<div class='codeblock'>
<p>Java - Ol√° Mundo - OlaMundo.java</p>
<code class='java'
>public class OlaMundo {
	// requer um m√©todo est√°tico main em uma classe
	public static void main(String[] args) {
		System.out.println("Ol√° Mundo");
	}
}</code
>
</div>

<div class='codeblock'>
<p>C# - Ol√° Mundo - OlaMundo.cs</p>
<code class='cs'
>public class OlaMundo {
	// requer um m√©todo est√°tico main em uma classe
	public static void Main(string[] args) {
		System.Console.WriteLine("Ol√° Mundo");
	}
}</code
>
</div>

<div class='codeblock'>
<p>JavaScript - Ol√° Mundo - main.js</p>
<code class='javascript'
>console.log('Ol√° Mundo')</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr> - Ol√° Mundo - main.bas</p>
<code class='visualbasic'
>Debug.Print "Ol√° Mundo"</code
>
</div>

</div>

<ol>
	<li>Swift</li>
	<li>JavaScript</li>
	<li>Rust</li>
	<li>C# / Java</li>
	<li>C++ / Objective-C</li>
</ol>

<p>Swift √© a mais simples de todas. Nem <code class='swift'>;</code> ela precisa, e seu uso nem √© recomendado.<br />
JavaScript perde por pouco. Tamb√©m n√£o requer <code class='javascript'>;</code> embora ao contr√°rio do que ocorre com Swift, seu uso seja recomendado. Seu <code class='javascript'>console.log</code> tamb√©m √© um pouco maior que o m√©todo <code class='swift'>print</code>.<br />
Rust ainda requer uma fun√ß√£o <code class='rust'>main</code>, mas o retorno dela n√£o precisa ser declarado explicitamente. Diferente das demais linguagens, usa um macro para IO, por isso <code class='rust'>print!</code> leva uma exclama√ß√£o (n√£o, n√£o era porque eu estava entusiasmado quando escrevi o c√≥digo).<br />
C# e Java s√£o id√™nticos, ambos requerendo uma classe que contenha o m√©todo <code class='generic'>main</code>. Sentiu uma leve press√£o para escrever orientado a objeto aqui? Tamb√©m √© recomendado que o nome do arquivo tenha o mesmo nome da classe.<br />
C++ e Objective-C s√£o bastante parecidos pois possuem forte influ√™ncia do C. S√£o os mais verborr√°gicos.</p>

</section>



<section>

<h2 id='comentarios'>Coment√°rios <span>e documenta√ß√£o inline</span></h2>

<h3>Coment√°rios b√°sicos</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// linha

/*
bloco
*/

fn someFunction(/* bloco */ arg1:i32) -&gt; i32 {
	0
}</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// linha

/*
bloco
*/

void someFunction(/* bloco */ int arg) {
	//
}</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// linha

/*
bloco
*/

void someFunction(/* bloco */ int arg) {
	return 0;
}</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// linha

/*
bloco
*/

func someFunction(/* bloco */ arg1:Int) -&gt; Int {
	return 0
}</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>// linha

/*
bloco
*/

// TODO function block

</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// linha

/*
bloco
*/

// TODO function block

</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// linha

/*
bloco
*/

// TODO function block

</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// linha

/*
bloco
*/

// TODO function block

</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
>' linha</code
>
</div>

</div>

<h3>Coment√°rios aninhados</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>/*

bloco

/*
bloco aninhado
*/

bloco

*/</code
>
</div>

<div class='codeblock'>
<p>C++</p>
-
</div>

<div class='codeblock'>
<p>Objective-C</p>
-
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>/*

bloco

/*
bloco aninhado
*/

bloco

*/</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
-
</div>

<div class='codeblock'>
<p>Java</p>
-
</div>

<div class='codeblock'>
<p>C#</p>
-
</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
-
</div>

</div>

<h3>Agrupamentos</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
-
</div>

<div class='codeblock'>
<p>C++</p>
-
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>#pragma mark - XCode section with dash
#pragma mark XCode section</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// MARK: - XCode section with dash
// MARK: XCode section</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>// region idea intellij foldable
// endregion</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// region idea intellij foldable
// endregion</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>#region foldable
#endregion</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
-
</div>

</div>

<h3>Documenta√ß√£o inline</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>/// Rustdoc para o item que segue
/// # Examples
/// let result = someFunction(2);
fn someFunction(arg1:i32) -&gt; i32 {
	0
}

mod foo {
	//! Rustdoc para o cont√™iner externo
}</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>/// &lt;summary&gt;Visual Studio XML Documentation alt 1&lt;/summary&gt;
/// &lt;param&gt;The argument os the function&lt;/param&gt;
/// &lt;returns&gt;The result of the function call&lt;/returns&gt;
/// &lt;example&gt;
/// &lt;code&gt;
/// auto result{someFunction(2)};
/// &lt;/code&gt;
/// &lt;/example&gt;
int someFunction(int arg) {
	return 0;
}

/**
&lt;summary&gt;Visual Studio XML Documentation alt 2&lt;/summary&gt;
&lt;param&gt;The argument os the function&lt;/param&gt;
&lt;returns&gt;The result of the function call&lt;/returns&gt;
&lt;example&gt;
&lt;code&gt;
auto result{someFunction(2)};
&lt;/code&gt;
&lt;/example&gt;
*/
int someFunction(int arg) {
	return 0;
}

/// XCode Doxygen / Header Doc alt 1
/// \param The argument of the function
/// \returns The result of the function call
/// \code
/// auto result{someFunction(2)};
int someFunction(int arg) {
	return 0;
}

//! XCode Doxygen / Header Doc alt 2
//! @param The argument of the function
//! @return The result of the function call
//! @code
//! auto result{someFunction(2)};
int someFunction(int arg) {
	return 0;
}

/**
XCode Doxygen / Header Doc alt 3
\param The argument of the function
\return The result of the function call
\code
auto result{someFunction(2)};
*/
int someFunction(int arg) {
	return 0;
}

/*!
XCode Doxygen / Header Doc alt 4
@param The argument of the function
@returns The result of the function call
@code
auto result{someFunction(2)};
*/
int someFunction(int arg) {
	return 0;
}</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// TODO</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>/**
XCode markdown
- Parameter arg1: The argument of the function
- Returns: The result of the function call
	let result = someFunction(2)
*/
func someFunction(arg1:Int) -&gt; Int {
	return 0
}</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>// TODO javadoc</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>public class SomeClass {

	/**
	JavaDoc
	{@code
		SomeClass someObject = new SomeClass();
		int result = someObject.someMethod();
	}
	@param arg1 The argument of the function
	@return The result of the function call
	*/
	public int someMethod(int arg1) {
		return 0;
	}

}</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>public class SomeClass {

	/// &lt;summary&gt;Visual Studio XML Documentation alt 1&lt;/summary&gt;
	/// &lt;param name="arg1"&gt;The argument of the function&lt;/param&gt;
	/// &lt;returns&gt;The result of the function call&lt;/returns&gt;
	/// &lt;example&gt;
	/// &lt;code&gt;
	/// var someObject = SomeClass();
	/// var result = someObject.SomeMethod(2);
	/// &lt;/code&gt;
	/// &lt;/example&gt;
	public int SomeMethod(int arg1) {
		return 0;
	}

	/**
	&lt;summary&gt;Visual Studio XML Documentation alt 2&lt;/summary&gt;
	&lt;param name="arg1"&gt;The argument of the function&lt;/param&gt;
	&lt;returns&gt;The result of the function call&lt;/returns&gt;
	&lt;example&gt;
	&lt;code&gt;
	var someObject = SomeClass();
	var result = someObject.SomeMethod(2);
	&lt;/code&gt;
	&lt;/example&gt;
	*/
	public int SomeOtherMethod(int arg1) {
		return 0;
	}

}</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>/**
JSDoc
@param {number} arg1 The argument of the function
@returns {number} The result of the function call
@example
let result = someFunction(2);
*/
function someFunction(arg1) {
	return 0;
}

/**
para indicar overloads, usamos uma mistura de tipos
e argumentos opcionais que fica com uma p√©ssima
legibilidade
@param {(number|string)} arg1 n√∫mero ou string
@param {number} [arg2] opcional
@returns {(number|string)} n√∫mero ou string

para cobrir a falta de suporte da linguagem para
certas funcionalidades, podemos usar tamb√©m
@private, @override, @enum etc.
*/


function someFunction(arg1) {
	/// &lt;signature&gt;
	/// &lt;summary&gt;Visual Studio XML Documentation&lt;/summary&gt;
	/// &lt;param name="arg1" type="Number"&gt;The argument of the function&lt;/param&gt;
	/// &lt;returns type="Number"&gt;The result of the function call&lt;/returns&gt;
	/// &lt;/signature&gt;

	return 0;
}

// &lt;signature&gt; √© opcional, e permite separar claramente
// os overloads da fun√ß√£o, pois podemos ter mais de uma signature</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
-
</div>

</div>

<ol>
	<li>Objective-C / Swift / C#</li>
	<li>C++</li>
	<li>Rust / Java</li>
	<li>JavaScript</li>
</ol>

<p>Objective-C, Swift e C# possuem ferramentas padr√£o nas respectivas <abbr title='Integrated Development Environment'>IDE</abbr>s.<br />
C++ n√£o possui uma ferramenta oficial. Varia de acordo com a <abbr title='Integrated Development Environment'>IDE</abbr> ou ferramenta externa e permite a mistura de muitos estilos e palavras alternativas.<br />
Rust possui documenta√ß√£o inline padronizada, mas as possibilidades s√£o bastante simples.<br />
Java usa JavaDoc, que s√≥ permite documenta√ß√£o usando <code class='java'>/** */</code>. Aliado com o fato de que Java n√£o suporta coment√°rios de bloco aninhados, um trecho de c√≥digo devidamente documentado √© imposs√≠vel de se comentar com <code class='java'>/* */</code>.<br />
JavaScript, assim como C++ n√£o possui padr√£o de documenta√ß√£o. Por√©m, o caso do JavaScript √© mais grave pois as sintaxes variam bastante entre si, inclusive quanto ao seu posicionamento no c√≥digo. A ferramenta mais amplamente difundida JSDoc possui sintaxe confusa quanto √† <em>overloads</em>.</p>

</section>



<section>

<h2 id='declaracaodevariaveis'>Declara√ß√£o de Vari√°veis</h2>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>let x = 5; // tipo impl√≠cito
let x:i32 = 5; // tipo expl√≠cito


let mut x = 5; // vari√°vel
let x = 5; // constante</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>auto x{5}; // tipo impl√≠cito
int x{5}; // tipo expl√≠cito
int x(5); // estilo antigo
int x = 5; // estilo c

const int z{5}; // constante
constexpr int x{5}; // express√£o constante

int&amp; referenciaDeInt; // refer√™ncia
int* ponteiroDeInt{&amp;x}; // ponteiro</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>



int x = 5; // vari√°vel
const int x = 5; // constante



int* x; // ponteiro</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>let x = 5 // tipo impl√≠cito
let x:Int = 5 // tipo expl√≠cito


var x = 5 // vari√°vel
let x = 5 // constante</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>val x = 5 // tipo impl√≠cito
val x:Int = 5 // tipo expl√≠cito


var x = 5 // vari√°vel
val x = 5 // constante

// n√£o precisa ser inicializada na declara√ß√£o
val x:Int
x = 5

// constante em tempo de compila√ß√£o
// precisa ser inicializada na declara√ß√£o
const val x = 5</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>



int x = 5; // vari√°vel
final int x = 5; // constante

// n√£o precisa ser inicializada na declara√ß√£o
final int x;
x = 5;</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>var x = 5; // tipo impl√≠cito
int a = 5; // tipo expl√≠cito


var x = 5; // vari√°vel
const int x = 5; // constante

// tipo ignorado em tempo de compila√ß√£o
dynamic x = 5;

unsafe {
	int* ponteiroDeInt = &amp;x; // ponteiro
}</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>'use strict';



let x = 5; // vari√°vel
const x = 5; // constante

let x = 5; // tipo din√¢mico
var x = 5; // estilo antigo

// lan√ßa exce√ß√£o em modo estrito
// mas √© aceito em modo normal
useSemDeclarar = 5;</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
>Option Explicit



Dim x As Integer: x = 5 ' vari√°vel
Const x As Integer = 5 ' constante

Dim x: x = 5 ' tipo din√¢mico
Dim x As Variant: x = 5 ' tipo din√¢mico

' lan√ßa exce√ß√£o com Option Explicit
' caso contr√°rio √© aceito
useSemDeclarar = 5

' Datas tem uma literal especial, em formato americano...
' Podemos digitar no formato #yyyy-mm-dd# e a IDE troca automaticamente para n√≥s
Const dataLimite As Date = #12/30/2017#</code
>
</div>

</div>

<h3>Desestrutura√ß√£o</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>let (x, y) = (1, 2);</code
>
</div>

<div class='codeblock'>
<p>C++</p>
-
</div>

<div class='codeblock'>
<p>Objective-C</p>
-
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>let (x, y) = (1, 2)</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>// TODO</code
>
</div>

<div class='codeblock'>
<p>Java</p>
-
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// TODO  - C# 7+</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>[x, y] = [1, 2];</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
-
</div>

</div>

<h3 id='nomesvalidos'>Nomes V√°lidos</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>let eu1:i32;
let _ = "bem sucinto";
let _123 = "meio confuso";
let _if = "meio confuso";</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>int eu1;
auto _ = "bem sucinto";
auto _123 = "meio confuso";
auto _if = "meio confuso";</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>int eu1;
int _ = "bem sucinto";
int _123 = "meio confuso";
int _if = "meio confuso";</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// TODO

// ignorar a vari√°vel
let _ = 1

let œÄ = 3.14159
let ‰Ω†Â•Ω = "‰Ω†Â•Ω‰∏ñÁïå"
let üê∂üêÆ = "dogcow"
// cannot contain
// whitespace characters
// mathematical symbols
// arrows
// private-use (or invalid)
// Unicode code points
// line- and box-drawing
// cannot begin with a number</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
></code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>int eu1;
int _ = "bem sucinto"; // deprecated
int _123 = "meio confuso";
int _if = "meio confuso";

int $ = "bem sucinto";
int $123 = "meio confuso";
int $if = "meio confuso";

// TODO posso usar $$ ou misturar $?</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>int eu1;
var _ = "bem sucinto";
var _123 = "meio confuso";
var _if = "meio confuso";

// podemos ainda usar @ na frente
// do nome pra evitar colis√µes
// com palavras-chave e tipos
var @if = "muito confuso";
var @int = "muito confuso";

// TODO
// a diferen√ßa de @ ao inv√©s de _
// √© que...</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>let eu1;
let _ = "bem sucinto";
let _123 = "meio confuso";
let _if = "meio confuso";

// TODO misturar _

let $ = "bem sucinto";
let $123 = "meio confuso";
let $if = "meio confuso";

// TODO posso usar $$ ou misturar $?

// muitos frameworks utilizam $
// como nome de seus objetos
// principais
// jQuery deve ser o mais
// famoso</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
></code
>
</div>



</div>

<ol>
	<li>Swift</li>
	<li>Rust</li>
	<li>C#</li>
	<li>JavaScript</li>
	<li>C++</li>
	<li>Java</li>
	<li>Objective-C</li>
</ol>

<p>Quem diria que um t√≥pico t√£o simples seria t√£o diverso entre as linguagens?</p>
<p>Rust e Swift s√£o quase id√™nticos, mudando apenas uma coisa. Swift faz a declara√ß√£o de vari√°veis e constantes serem <q>equivalentes</q>, enquanto Rust faz a declara√ß√£o de vari√°vies mais dif√≠ceis que de constantes. Mas porque Swift utilizou <code class='swift'>let</code> ao inv√©s de <code class='cpp'>const</code>?<br />
JavaScript √© a √∫nica das linguagens comparadas que possibilita mudar os tipos das vari√°veis dinamicamente. Sua sintaxe de desestrutura√ß√£o n√£o permite declarar e atribuir um valor ao mesmo tempo. As vari√°veis j√° devem ser declaradas antes da atribui√ß√£o. JavaScript possui um estilo legado de declarac√£o, que cria vari√°veis com regras de escopo diferentes do que a maioria dos programadores espera, al√©m de possuir um modo estrito para coibir pr√°ticas legadas.<br />
C++ √© o que tem mais legado de coisas que n√£o deram certo, e sua √∫ltima sintaxe pode ter regras mais seguras, mas certamente √© bastante estranha. Tipagem impl√≠cita requer a palavra <code class='cpp'>auto</code>. Para aumentar a performance de nosso c√≥digo, temos o recurso <code class='cpp'>constexpr</code>.<br />
Java parou no tempo e Objective-C tamb√©m (mas c√° entre n√≥s, a Apple pelo menos admite). Por√©m, Objective-c ainda tem tipos ponteiro para deixar as coisas mais confusas.</p>

</section>



<section>

<h2 id='nullnullable'>Null e Nullable</h2>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// n√£o existem tipos nullable
// mas existe um tipo std::Option&lt;T&gt;
// que pode conter None ou Some()

// tipo expl√≠cito
let mut k:Option&lt;i32&gt; = None;
let mut l:Option&lt;AStruct&gt; = None;

// tipo impl√≠cito Option&lt;i32&gt;
let mut m = None::&lt;i32&gt;;
let mut n = Some(10);

// erro, n√£o pode passar um valor diretamente
// tem que usar Some(valor)
let mut o:Option&lt;i32&gt; = 10;

// n√£o possui operador espec√≠fico para Option
let p = match n { // p ser√° do tipo i32
	Some(some) =&gt; some,
	None =&gt; 10,
};

// ok mas panic se for None
let q = n.unwrap(); // q ser√° do tipo i32</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>std::optional&lt;int&gt; k; // C++17
boost::optional&lt;int&gt; l; // boost</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// nil object
// Nil class
// NSNull singleton to represent null</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// optionals devem ter o tipo especificado
// em sua declara√ß√£o
var k:Int? = nil
var l:AClass? = nil
let m = l?.propriedade // m recebe nil
let n = l!.propriedade // lan√ßa erro se l for nil

// nil coalescing operator
let o = k ?? 10 // o ser√° do tipo Int

// ok mas n√£o √© idiom√°tico
let p = k != nil ? k : 10 // p ser√° do tipo Int?

// PS: nullable √© chamado de optional
// e null √© chamado de nil em Swift</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>// nullables devem ter o tipo especificado
// em sua declara√ß√£o
var k:Int? = null
var l:AClass? = null
val m = l?.propriedade // m recebe null
let n = l!!.propriedade // lan√ßa erro se l for null

// null coalescing operator
val o = k ?: 10 // o ser√° do tipo Int</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// tipos primitivos n√£o podem ser nullable
int a = null; // erro

// qualquer tipo de refer√™ncia √© nullable
Integer k = null;
AClass l = null;
Integer m = (l != null) ? l.propriedade : null;

// n√£o possui operador espec√≠fico para null
int n = (k != null) ? k : 10; // n aceita ser do tipo int ou Integer</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// nullable n√£o pode ser usado com var
// um tipo deve ser especificado
int? k = null;
AClass? l = null;
int? m = l?.propriedade; // C# 6
int? m = x?[indice]; // C# 6
int? m = (l != null) ? l.propriedade : null;

// null coalescing operator
var n = k ?? 10; // n ser√° do tipo int

// ok mas n√£o √© idiom√°tico
var o = (k != null) ? k : 10; // o ser√° do tipo int?</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>'use strict';

// qualquer tipo √© sempre nullable
let k = null;
let l = (k &amp;&amp; k.propriedade) ? k.propriedade : null;

// null coalescing operator
let m = k || 10;

// ok mas n√£o √© idiom√°tico
let n = (k || k === 0) ? k : 10;</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
>Option Explicit

' qualquer tipo √© sempre nullable
' mas o Visual Basic usa as palavras Empty e Nothing para tanto
' a palavra null √© reservada para uso com bancos de dados

' Empty √© o valor que uma vari√°vel n√£o inicializada possui
Dim x: x = Empty

' Nothing s√≥ √© usado com objetos TODO confirmar isso</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='tiposboolean'>Tipos Primitivos Boolean</h2>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// tipo bool
let oitoOuOintenta = true;
oitoOuOintenta = false;

// converte para true
oitoOuOitenta = !oitoOuOitenta;

// parse
use std::str::FromStr;

let toParse = "5";
let parsed = i32::from_str(toParse).unwrap();</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// tipo bool
auto oitoOuOitenta = true;
oitoOuOitenta = false;

// converte para true
oitoOuOitenta = !oitoOuOitenta;

// TODO #include &lt;boost/spirit/include/qi_bool.hpp&gt;</code
>
</div>
<!-- http://www.boost.org/doc/libs/1_44_0/libs/spirit/doc/html/spirit/qi/reference/numeric/boolean.html -->

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// tipo NSNumber wrapping BOOL
NSNumber* oitoOuOitenta = @YES;

// tipo BOOL
BOOL oitoOuOitenta = YES;

// tipo C bool
bool oitoOuOitenta = true;</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// tipo Bool
var oitoOuOitenta = true
oitoOuOitenta = false

// converte para true
oitoOuOitenta = !oitoOuOitenta

// Skips initial space characters,
// or optional -/+ sign followed by zeroes.
// Returns YES on encountering one of
// "Y", "y", "T", "t", or a digit 1-9.
// It ignores any trailing characters.
var boolValue:Bool { get }</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>// tipo Boolean
var oitoOuOitenta = true
oitoOuOitenta = false

// converte para true
oitoOuOitenta = !oitoOuOitenta

// TODO parse boolean</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// tipo boolean
boolean oitoOuOitenta = true;
oitoOuOitenta = false;

// converte para true
oitoOuOitenta = !oitoOuOitenta;

// TODO Boolean.parseBoolean</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// tipo bool
var oitoOuOitenta = true;
oitoOuOitenta = false;

// converte para true
oitoOuOitenta = !oitoOuOitenta;

// TODO Boolean.Parse
// Boolean.TryParse tb</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// tipo Boolean
let oitoOuOitenta = true;
oitoOuOitenta = false;

// converte para true
oitoOuOitenta = !oitoOuOitenta;

// TODO falar de falsy e truthy e !!

/*
// falsy
var bZero = new Boolean(0);
var bNull = new Boolean(null);
var bEmptyString = new Boolean('');
var bfalse = new Boolean(false);
// undefined e NaN

// truthy
var btrueString = new Boolean('true');
var bfalseString = new Boolean('false');
var bSuLin = new Boolean('Su Lin');
var bArrayProto = new Boolean([]);
var bObjProto = new Boolean({});*/</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
>Dim oitoOuOitenta: oitoOuOitenta = True
oitoOuOitenta = False

oitoOuOitenta = Not oitoOuOitenta</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section class='tiposprimitivos'>

<h2 id='tiposnumericos'>Tipos Primitivos Num√©ricos</h2>



<h3 id='integer'>Integer</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>i8</td><td>8 bits</td></tr>
		<tr><td>i16</td><td>16 bits</td></tr>
		<tr><td>i32</td><td>32 bits</td></tr>
		<tr><td>i64</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>C++</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>char</td><td>8 bits?</td></tr>
		<tr><td>short</td><td>16 bits ou mais</td></tr>
		<tr><td>int</td><td>16 bits ou mais</td></tr>
		<tr><td>long</td><td>32 bits ou mais</td></tr>
		<tr><td>long long</td><td>64 bits ou mais</td></tr>
	</tbody>
</table>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>int8_t</td><td>8 bits</td></tr>
		<tr><td>int16_t</td><td>16 bits</td></tr>
		<tr><td>int32_t</td><td>32 bits</td></tr>
		<tr><td>int64_t</td><td>64 bits</td></tr>
	</tbody>
</table>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>int_least8_t</td><td>8 bits ou mais</td></tr>
		<tr><td>int_least16_t</td><td>16 bits ou mais</td></tr>
		<tr><td>int_least32_t</td><td>32 bits ou mais</td></tr>
		<tr><td>int_least64_t</td><td>64 bits ou mais</td></tr>
	</tbody>
</table>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>int_fast8_t</td><td>8 bits ou mais</td></tr>
		<tr><td>int_fast16_t</td><td>16 bits ou mais</td></tr>
		<tr><td>int_fast32_t</td><td>32 bits ou mais</td></tr>
		<tr><td>int_fast64_t</td><td>64 bits ou mais</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Objective-C</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>char</td><td>8 bits</td></tr>
		<tr><td>short</td><td>16 bits</td></tr>
		<tr><td>int</td><td>32 bits</td></tr>
		<tr><td>long</td><td>32 ou 64 bits</td></tr>
		<tr><td>long long</td><td>64 bits</td></tr>
	</tbody>
</table>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>int8_t</td><td>8 bits</td></tr>
		<tr><td>int16_t</td><td>16 bits</td></tr>
		<tr><td>int32_t</td><td>32 bits</td></tr>
		<tr><td>int64_t</td><td>64 bits</td></tr>
	</tbody>
</table>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>int_least8_t</td><td>8 bits ou mais</td></tr>
		<tr><td>int_least16_t</td><td>16 bits ou mais</td></tr>
		<tr><td>int_least32_t</td><td>32 bits ou mais</td></tr>
		<tr><td>int_least64_t</td><td>64 bits ou mais</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Swift (Obj-C)</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>CChar</td><td>8 bits</td></tr>
		<tr><td>CShort</td><td>16 bits</td></tr>
		<tr><td>CInt</td><td>16 bits</td></tr>
		<tr><td>CLong</td><td>32 bits</td></tr>
		<tr><td>CLongLong</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Swift</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>Int8</td><td>8 bits</td></tr>
		<tr><td>Int16</td><td>16 bits</td></tr>
		<tr><td>Int32</td><td>32 bits</td></tr>
		<tr><td>Int64</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Kotlin</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>Byte</td><td>8 bits</td></tr>
		<tr><td>Short</td><td>16 bits</td></tr>
		<tr><td>Int</td><td>32 bits</td></tr>
		<tr><td>Long</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Java</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>byte</td><td>8 bits</td></tr>
		<tr><td>short</td><td>16 bits</td></tr>
		<tr><td>int</td><td>32 bits</td></tr>
		<tr><td>long</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>C#</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>sbyte</td><td>8 bits</td></tr>
		<tr><td>short</td><td>16 bits</td></tr>
		<tr><td>int</td><td>32 bits</td></tr>
		<tr><td>long</td><td>64 bits</td></tr>
		<tr><td>decimal</td><td>128 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

</div>



<h3 id='unsignedinteger'>Unsigned Integer</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>u8</td><td>8 bits</td></tr>
		<tr><td>u16</td><td>16 bits</td></tr>
		<tr><td>u32</td><td>32 bits</td></tr>
		<tr><td>u64</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>C++</p>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>char</td><td>8 bits?</td></tr>
		<tr><td>unsigned short</td><td>16 bits ou mais</td></tr>
		<tr><td>unsigned int</td><td>16 bits ou mais</td></tr>
		<tr><td>unsigned long</td><td>32 bits ou mais</td></tr>
		<tr><td>unsigned long long</td><td>64 bits ou mais</td></tr>
	</tbody>
</table>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>uint8_t</td><td>8 bits</td></tr>
		<tr><td>uint16_t</td><td>16 bits</td></tr>
		<tr><td>uint32_t</td><td>32 bits</td></tr>
		<tr><td>uint64_t</td><td>64 bits</td></tr>
	</tbody>
</table>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>uint_least8_t</td><td>8 bits ou mais</td></tr>
		<tr><td>uint_least16_t</td><td>16 bits ou mais</td></tr>
		<tr><td>uint_least32_t</td><td>32 bits ou mais</td></tr>
		<tr><td>uint_least64_t</td><td>64 bits ou mais</td></tr>
	</tbody>
</table>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>uint_fast8_t</td><td>8 bits ou mais</td></tr>
		<tr><td>uint_fast16_t</td><td>16 bits ou mais</td></tr>
		<tr><td>uint_fast32_t</td><td>32 bits ou mais</td></tr>
		<tr><td>uint_fast64_t</td><td>64 bits ou mais</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Objective-C</p>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>unsigned char</td><td>8 bits</td></tr>
		<tr><td>unsigned short</td><td>16 bits</td></tr>
		<tr><td>unsigned int</td><td>32 bits</td></tr>
		<tr><td>unsigned long</td><td>32 ou 64 bits</td></tr>
		<tr><td>unsigned long long</td><td>64 bits</td></tr>
	</tbody>
</table>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>uint8_t</td><td>8 bits</td></tr>
		<tr><td>uint16_t</td><td>16 bits</td></tr>
		<tr><td>uint32_t</td><td>32 bits</td></tr>
		<tr><td>uint64_t</td><td>64 bits</td></tr>
	</tbody>
</table>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>uint_least8_t</td><td>8 bits ou mais</td></tr>
		<tr><td>uint_least16_t</td><td>16 bits ou mais</td></tr>
		<tr><td>uint_least32_t</td><td>32 bits ou mais</td></tr>
		<tr><td>uint_least64_t</td><td>64 bits ou mais</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Swift (Obj-C)</p>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>CUnsignedChar</td><td>8 bits</td></tr>
		<tr><td>CUnsignedShort</td><td>16 bits</td></tr>
		<tr><td>CUnsignedInt</td><td>16 bits</td></tr>
		<tr><td>CUnsignedLong</td><td>32 bits</td></tr>
		<tr><td>CUnsignedLongLong</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Swift</p>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>UInt8</td><td>8 bits</td></tr>
		<tr><td>UInt16</td><td>16 bits</td></tr>
		<tr><td>UInt32</td><td>32 bits</td></tr>
		<tr><td>UInt64</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Kotlin</p>
-
</div>

<div class='codeblock'>
<p>Java</p>
-
</div>

<div class='codeblock'>
<p>C#</p>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>byte</td><td>8 bits</td></tr>
		<tr><td>ushort</td><td>16 bits</td></tr>
		<tr><td>uint</td><td>32 bits</td></tr>
		<tr><td>ulong</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

</div>



<h3 id='pointerinteger'>Pointer Sized Integer</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>

<table>
	<caption>Pointer Sized Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>isize</td><td>Depende do hardware</td></tr>
		<tr><td>usize</td><td>Depende do hardware</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>C++</p>

<table>
	<caption>Pointer Sized Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>intptr_t</td><td>Depende do hardware</td></tr>
		<tr><td>uintptr_t</td><td>Depende do hardware</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Objective-C</p>

<table>
	<caption>Pointer Sized Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>NSInteger</td><td>32 ou 64 bits</td></tr>
		<tr><td>NSUInteger</td><td>32 ou 64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Swift (Obj-C)</p>
-
</div>

<div class='codeblock'>
<p>Swift</p>

<table>
	<caption>Pointer Sized Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>Int</td><td>Depende do Hardware</td></tr>
		<tr><td>UInt</td><td>Depende do Hardware</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Kotlin</p>
-
</div>

<div class='codeblock'>
<p>Java</p>
-
</div>

<div class='codeblock'>
<p>C#</p>
-
</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

</div>



<h3 id='floatingpoint'>Floating Point</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>

<table>
	<caption>Floating Point (IEEE-754)</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>f32</td><td>32 bits</td></tr>
		<tr><td>f64</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>C++</p>

<table>
	<caption>Floating Point</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>float</td><td>32 bits</td></tr>
		<tr><td>double</td><td>64 bits</td></tr>
	</tbody>
</table>

<table>
	<caption>Floating Point</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>long double</td><td>128 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Objective-C</p>

<table>
	<caption>Floating Point</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>float</td><td>32 bits</td></tr>
		<tr><td>double</td><td>64 bits</td></tr>
	</tbody>
</table>

<table>
	<caption>Floating Point</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>long double</td><td>128 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Swift (Obj-C)</p>

<table>
	<caption>Floating Point (IEEE-754)</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>CFloat</td><td>32 bits</td></tr>
		<tr><td>CDouble</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Swift</p>

<table>
	<caption>Floating Point (IEEE-754)</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>Float</td><td>32 bits</td></tr>
		<tr><td>Double</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Kotlin</p>

<table>
	<caption>Floating Point (IEEE 754)</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>float</td><td>32 bits</td></tr>
		<tr><td>double</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Java</p>

<table>
	<caption>Floating Point (IEEE 754)</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>float</td><td>32 bits</td></tr>
		<tr><td>double</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>C#</p>

<table>
	<caption>Floating Point (IEEE 754)</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>float</td><td>32 bits</td></tr>
		<tr><td>double</td><td>64 bits</td></tr>
	</tbody>
</table>

<table>
	<caption>Floating Point</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>decimal</td><td>128 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>JavaScript</p>

<table>
	<caption>Floating Point (IEEE 754)</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>Number</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

</div>



<h2 id='outrostiposnumericos'>Tipos Num√©ricos N√£o Primitivos</h2>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<table>
	<caption>Floating Point</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>num::bigint::BigInt</td><td>?</td></tr>
		<tr><td>num::bigint::BigUint</td><td>?</td></tr>
	</tbody>
</table>
</div>

<div class='codeblock'>
<p>C++</p>
-
</div>

<div class='codeblock'>
<p>Objective-C</p>
<table>
	<caption>Numeric</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>NSNumber</td><td>cluster de tipos</td></tr>
		<tr><td>CGFloat</td><td>32 ou 64 bits</td></tr>
	</tbody>
</table>
</div>

<div class='codeblock'>
<p>Swift (Obj-C)</p>
-
</div>

<div class='codeblock'>
<p>Swift</p>
<table>
	<caption>Floating Point</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>Float80</td><td>80 bits</td></tr>
	</tbody>
</table>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<table>
	<caption>Numeric</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>java.math.BigInteger</td><td>?</td></tr>
		<tr><td>java.math.BigDecimal</td><td>?</td></tr>
	</tbody>
</table>
</div>

<div class='codeblock'>
<p>Java</p>
<table>
	<caption>Numeric</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>BigInteger</td><td>?</td></tr>
		<tr><td>BigDecimal</td><td>?</td></tr>
	</tbody>
</table>
</div>

<div class='codeblock'>
<p>C#</p>
<table>
	<caption>Numeric</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tbody>
		<tr><td>BigInteger</td><td>?</td></tr>
		<tr><td>Complex</td><td>?</td></tr>
	</tbody>
</table>
</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

</div>



<ol>
	<li>Rust</li>
	<li>Swift</li>
	<li>C#</li>
	<li>Java</li>
	<li>C++</li>
	<li>Objective-C</li>
	<li>JavaScript</li>
</ol>

<p>Rust nomeia claramente os tipos num√©ricos que usa, al√©m de usar nomes curtos.<br />
Swift prefere ser um pouco mais conservador e utilizar nomes como <code class='swift'>Int</code> e <code class='swift'>Double</code>. Possui tamb√©m tipos para compatibilidade com as <abbr>API</abbr>s em C e Objective-C.<br />
C# mant√©m os nomes herdados do C (embora seja poss√≠vel criar <em>type aliases</em> por arquivo). Notem a inconsist√™ncia com <code class='cs'>sbyte</code> e <code class='cs'>byte</code> devido a esta decis√£o. C# possui um tipo de 128 bits. Como roda numa m√°quina virtual, n√£o possui tipos com tamanhos de mem√≥ria como Rust e Swift. N√£o sei ao certo como √© feito com <em>Native</em> .NET.<br />
Java n√£o possui tipos sem sinal.<br />
C++ possui uma leve melhoria em rela√ß√£o √† C, mas ainda √© bem extenso.<br />
Objective-C mistura tipos de C e os pr√≥prios, fazendo uma salada s√≥. Os tipos que ele herda de C n√£o possuem tamanho fixo. Existe apenas a garantia de que <code class='objectivec'>short &lt;= int &lt;= long &lt;= long long</code>. Mesma coisa vale para <code class='objectivec'>float &lt;= double &lt;= long double</code>. Ent√£o existem tipos de tamanho fixo criados na especifica√ß√£o C99 e os tipos inclu√≠dos pelo framework da Apple.<br />
JavaScript s√≥ possui um tipo num√©rico.</p>
<p>Notem que existe uma diverg√™ncia entre C++ e Objective-C e as demais linguagens em rela√ß√£o √† nomeclatura. Para as duas linguagens, <code class='cpp'>int</code> e <code class='cpp'>long</code> possuem tamanhos diferentes das demais. Por isso, ponto para as linguagens que indicam explicitamente o tamanho dos tipos no pr√≥prio nome.</p>

</section>



<section class='tiposprimitivos'>

<h2 id='boxtiposnumericos'>Boxing de Tipos Primitivos Num√©ricos</h2>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
-
</div>

<div class='codeblock'>
<p>C++</p>
-
</div>

<div class='codeblock'>
<p>Objective-C</p>
<table>
	<caption>Numeric</caption>
	<thead>
		<tr><th>tipo</th><th>classe</th></tr>
	</thead>
	<tbody>
		<tr><td>?</td><td>NSNumber</td></tr>
	</tbody>
</table>
</div>

<div class='codeblock'>
<p>Swift</p>
-
</div>

<div class='codeblock'>
<p>Kotlin</p>
</div>

<div class='codeblock'>
<p>Java</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>classe</th></tr>
	</thead>
	<tbody>
		<tr><td>byte</td><td>Byte</td></tr>
		<tr><td>short</td><td>Short</td></tr>
		<tr><td>int</td><td>Integer</td></tr>
		<tr><td>long</td><td>Long</td></tr>
	</tbody>
</table>

<table>
	<caption>Floating Point (IEEE 754)</caption>
	<thead>
		<tr><th>tipo</th><th>classe</th></tr>
	</thead>
	<tbody>
		<tr><td>float</td><td>Float</td></tr>
		<tr><td>double</td><td>Double</td></tr>
	</tbody>
</table>
</div>

<div class='codeblock'>
<p>C#</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>struct</th></tr>
	</thead>
	<tbody>
		<tr><td>sbyte</td><td>SByte</td></tr>
		<tr><td>short</td><td>Int16</td></tr>
		<tr><td>int</td><td>Int32</td></tr>
		<tr><td>long</td><td>Int64</td></tr>
		<tr><td>decimal</td><td>Decimal</td></tr>
	</tbody>
</table>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>classe</th></tr>
	</thead>
	<tbody>
		<tr><td>byte</td><td>Byte</td></tr>
		<tr><td>ushort</td><td>UInt16</td></tr>
		<tr><td>uint</td><td>UInt32</td></tr>
		<tr><td>ulong</td><td>UInt64</td></tr>
	</tbody>
</table>

<table>
	<caption>Floating Point (IEEE 754)</caption>
	<thead>
		<tr><th>tipo</th><th>classe</th></tr>
	</thead>
	<tbody>
		<tr><td>float</td><td>Single</td></tr>
		<tr><td>double</td><td>Double</td></tr>
	</tbody>
</table>

<table>
	<caption>Floating Point</caption>
	<thead>
		<tr><th>tipo</th><th>classe</th></tr>
	</thead>
	<tbody>
		<tr><td>decimal</td><td>Decimal</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='literaisnumericas'>Literais Num√©ricas</h2>



<h3 id='literaisdecimaisinteiros'>Decimais Inteiros</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// i8
let i81 = 1_i8;
let i82 = -1i8;

// u8
let u81 = 1_u8;

// i16
let i161 = 1i16;
let i162 = -1_i16;

// u16
let u161 = 1u16;

// i32
let i1 = 1;
let i2 = -1;
let i3 = 1_i32;

// avisa overflow -2147483648
let i4:i32 = 2_147_483_648;
let i5 = 2_147_483_648_i32;
let i6 = 2_147_483_648;

// avisa underflow 2147483647
let i7:i32 = -2_147_483_649;
let i8 = -2_147_483_649_i32;
let i9 = -2_147_483_649;

// u32
let u1 = 2_147_483_648_u32;

// i64
let i641 = 1_i64;
let i642 = -1_i64;

// u64
let u641 = 1_u64;

// pointer size
let isize1 = 1_isize;
let usize1 = 1_usize;        </code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// int32_t (x64 LP64)
auto i1{1};
auto i2{-1};

// uint32_t (x64 LP64)
auto u1{1u};
auto u2{2'147'483'648U};


// int64_t (x64 LP64)
auto l1{2'147'483'648};
auto l2{-2'147'483'649};
auto l3{1l};
auto l4{1L};
auto l5{1ll};
auto l6{1LL};

// uint64_t (x64 LP64)
auto ul1{9'223'372'036'854'775'808};
auto ul2{1ul};
auto ul3{1UL};
auto ul4{1ull};
auto ul5{1ULL};</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// TODO

NSNumber* myBool = @YES;
NSNumber* myBool = [[NSNumber alloc] initWithBOOL:YES];

// int
NSInteger i1 = 42; // NSLog(@"%zd", i1);
NSNumber* i2 = @42; // NSLog(@"%@", i2);
NSNumber* i3 = [[NSNumber alloc] initWithInt:42];

// uint
NSUInteger u1 = 42u; // NSLog(@"%tu", u1);
NSNumber* u2 = @42u; // NSLog(@"%@", u2);
NSNumber* u3 = [[NSNumber alloc] initWithUnsignedInt:42u];

// long
NSNumber* l1 = @42L;
NSNumber* l1 = [[NSNumber alloc] initWithLong:42L];

// long long
NSNumber* ll1 = @42LL;
NSNumber* ll1 = [[NSNumber alloc] initWithLong:42LL];</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// Int (x64)
let i1 = 1
let i2 = -1
let i3 = 2_147_483_648
let i4 = -2_147_483_649












// UInt (x64)
let u1:UInt = 9_223_372_036_854_775_808

// lan√ßa exce√ß√£o
// does not fit inside Int (x64)
let e1 = 9_223_372_036_854_775_808
</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>// Int
val i1 = 1
val 12 = -1
val i3 = 2_147_483_648
val i4 = -2_147_483_649




// Long
val l1 = 1L</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// int
Object i1 = 1;
Object i2 = -1;






// long
Object l1 = 2_147_483_648l;
Object l2 = -2_147_483_649L;
Object l3 = 1l;
Object l4 = 1L;


// lan√ßa exce√ß√£o
// integer number too large
Object l5 = 9_223_372_036_854_775_808L;</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// int
var i1 = 1;
var i2 = -1;

// uint
var u1 = 1u;
var u2 = 2147483648U;
var u3 = 2147483648;

// long
var l1 = 2147483648L;
var l2 = -2147483649;
var l3 = -2147483649L;
var l4 = 1l;
var l5 = 1L;


// ulong
// terminal com ul ou lu
// TODO                      </code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

</div>



<h3 id='literaisdecimaisfloatingpoint'>Decimais Floating Point</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// f32 (float)
let f1 = 1f32;


// f64 (double)
let d1 = 1f64;
let d2 = 1.0;                </code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
                                    </code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// NSNumber wrapping float
NSNumber* f1 = @1f;
NSNumber* f1m = [NSNumber numberWithFloat:1f];

// NSNumber wrapping double
NSNumber *d1 = @1.0;
NSNumber *d1m = [NSNumber numberWithDouble:1.0];          </code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// Float
let f1:Float = 1


// Double
let d1 = 1.0
let d2 = 0.7 // n√£o aceita .7          </code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>// Float
val f1 = 1f
val f2 = 1F

// Double
val d1 = 1.0
val d2 = .7                 </code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// float
Object f1 = 1f;
Object f2 = 1F;

// double
Object d1 = 1d;
Object d2 = 1D;
Object d3 = 1.0;
Object d4 = .7;              </code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// float
var f1 = 1f;
var f2 = 1F;

// double
var db1 = 1d;
var db2 = 1D;
var db3 = 1.0;
var db4 = .7;

// decimal
var dc = 1m;                 </code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// double
let d1 = 1;
let d2 = -1;
let d3 = 2147483648;
let d4 = -2147483649;
let d5 = 1.0;
let d6 = .7;                 </code
>
</div>

</div>



<h3 id='notacoesnumericas'>Nota√ß√µes</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// nota√ß√£o cient√≠fica
let c1 = 1e_0;
let c2 = 1e-1;
let c3 = -0.7_e-2;

// nota√ß√£o bin√°ria
let b1 = 0b_0000_0001;
let b2 = -0b0000_0010;

// nota√ß√£o octal
let o1 = 0o_01234567;
let o2 = -0o1234567;

// nota√ß√£o hexadecimal
let cor = 0x_ff_00_00;
let x1 = -0x0123456789ABCDEF;

// TODO misturar nota√ß√µes
// com sufixos</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
                                    </code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
                                                          </code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// nota√ß√£o cient√≠fica
let c1 = 1e0
let c2 = 1e-1
let c3 = -0.7_e-2

// nota√ß√£o bin√°ria
let b1 = 0b0000_0001
let b2 = -0b0000_0010

// nota√ß√£o octal
let o1 = 0o01234567
let o2 = -0o1234567

// nota√ß√£o hexadecimal
let cor = 0xff_00_00
let x1 = -0x0123456789ABCDEF

// nota√ß√£o hexadecimal cient√≠fica
let xc1 = 0xff0000p0
let xc2 = -0x0123456789ABCDEF_p9       </code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>// nota√ß√£o cient√≠fica
val c1 = 1e0
val c2 = 1e-1
val c3 = -.7e-2

// nota√ß√£o bin√°ria
val b1 = 0b0000_0001
val b2 = -0B0000_0010





// nota√ß√£o hexadecimal
val cor = 0xff_00_00
val x1 = -0X0123456789ABCDEF</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// nota√ß√£o cient√≠fica
double c1 = 1e0;
double c2 = 1e-1;
double c3 = -.7e-2;

// nota√ß√£o bin√°ria
int b1 = 0b0000_0001;
int b2 = -0B00000010;

// nota√ß√£o octal
int o1 = 01_234_567;
int o2 = -01234567;

// nota√ß√£o hexadecimal
int cor = 0xff_00_00;
int x1 = -0X0123456789ABCDEF;

// TODO misturar nota√ß√µes
// com sufixos</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// nota√ß√£o cient√≠fica
double c1 = 1e0;
double c2 = 1e-1;
double c3 = -.7e-2;

// nota√ß√£o bin√°ria - C# 7+
val b1 = 0b0000_0001
val b2 = -0B0000_0010



// nota√ß√£o hexadecimal
int cor = 0xff0000;
int x1 = -0X0123456789ABCDEF;

// TODO misturar nota√ß√µes
// com sufixos</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// nota√ß√£o cient√≠fica
let c1 = 1e0;
let c2 = 1e-1;
let c3 = -.7e-2;

// nota√ß√£o bin√°ria
let b1 = 0B00000001;
let b2 = -0b00000010;

// nota√ß√£o octal
let o1 = 0o01234567;
let o2 = -0O1234567;

// nota√ß√£o hexadecimal
let cor = 0xff0000;
let x1 = -0X0123456789ABCDEF;</code
>
</div>

</div>



<h3 id='paddingnumerico'>Padding</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>let i1 = 10;
let p1 = 01;
let p2 = 00.1;               </code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// n√∫meros come√ßando com 0
// s√£o considerados nota√ß√£o
// octal                            </code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
                                                          </code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>let i1 = 10
let p1 = 01
let p2 = 00.1                          </code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>

val p2 = 00.1                </code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// n√∫meros come√ßando com 0
// s√£o considerados nota√ß√£o
// octal                     </code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>var i1 = 10;
var p1 = 01;
var p1 = 00.1;               </code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>let i1 = 10;
let p1 = 01;                 </code
>
</div>

</div>



<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='conversoesnumericas'>Convers√£o entre Tipos Num√©ricos</h2>



<h3 id='operacoesnumericas'>Opera√ß√µes</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// Requer compila√ß√£o com flag -O
// Compila√ß√µes sem otimiza√ß√£o panic no overflow

let i32_1:i32 = 2;
let i32_2:i32 = 4;
let i32_min:i32 = std::i32::MIN;
let i32_max:i32 = std::i32::MAX;

let i641:i64 = i32_max as i64; // explicit conversion 2147483647 (i64)
let i161:i16 = i32_max as i16; // explicit conversion -1 (i16)

// explicit conversion
let adicao1 = i32_max + 1; // -2147483648 (i32)
let adicao2 = i641 + (i32_1 as i64); // 2147483649 (i64)
let adicao3 = i641 + (i32_max as i64); // 4294967294 (i64)

// explicit conversion
let subtracao1 = i32_min - 1; // 2147483647 (i32)
let subtracao2 = (i161 as i32) - i32_1; // -3 (i32)
let subtracao3 = (i161 as i32) - i32_max; // -2147483648 (i32)

// explicit conversion
let multiplicacao1 = i32_1 * i32_2; // 8 (i32)
let multiplicacao2 = i32_max * i32_1; // -2 (i32)
let multiplicacao3 = (i32_1 as i64) * i641; // 4294967294 (i64)

// explicit conversion
let divisao1 = i32_2 / i32_1; // 2 (i32)
let divisao2 = i32_1 / i32_2; // 0 (i32)
let divisao3 = (i161 as i32) / i32_1; // 0 (i32)

// NOTA
// literais num√©ricas sem sufixo possuem o tipo _
// e n√£o realizam opera√ß√µes matem√°ticas

// TODO converte para char e boolean</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// Convers√£o expl√≠cita √© sempre requerida para
// opera√ß√µes com vari√°veis

let i32_1:Int32 = 2
let i32_2:Int32 = 4
let i32_min:Int32 = Int32.min
let i32_max:Int32 = Int32.max

let i64:Int64 = Int64(i32_max) // explicit conversion 2147483647 (Int64)
let i16:Int16 = Int16(truncatingBitPattern: i32_max) // explicit conversion -1 (Int16)

// explicit conversion and overflow operator &amp;+
var adicao1 = i32_max &amp;+ 1 // -2147483648 (Int32)
var adicao2 = i64 + Int64(i32_1) // 2147483649 (Int64)
var adicao3 = i64 + Int64(i32_max) // 4294967294 (Int64)

// explicit conversion and overflow operator &amp;-
var subtracao1 = i32_min &amp;- 1 // 2147483647 (Int32)
var subtracao2 = Int32(i16) &amp;- i32_1 // -3 (Int32)
var subtracao3 = Int32(i16) &amp;- i32_max // -2147483648 (Int32)

// explicit conversion and overflow operator &amp;*
var multiplicacao1 = i32_1 * i32_2 // 8 (Int32)
var multiplicacao2 = i32_max &amp;* i32_1 // -2 (Int32)
var multiplicacao3 = Int64(i32_1) * i64 // 4294967294 (Int64)

// explicit conversion
var divisao1 = i32_2 / i32_1 // 2 (Int32)
var divisao2 = i32_1 / i32_2 // 0 (Int32)
var divisao3 = Int32(i16) / i32_1 // 0 (Int32)

// NOTA
// Literais num√©ricas n√£o possuem tipo espec√≠fico,
// apenas vari√°veis possuem. Portanto realizar
// opera√ß√µes com vari√°veis requer convers√µes
// expl√≠citas, enquanto que opera√ß√µes com literais
// n√£o requer

let intVar = 1
var doubleVar = 0.1

// requer convers√£o expl√≠cita
let somaVar = Double(intVar) + doubleVar
doubleVar += Double(intVar)

// n√£o requer
let somaLiteral = 1 + 0.1
doubleVar += 1</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
></code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>

int i32_1 = 2;
int i32_2 = 4;
int i32_min = Integer.MIN_VALUE;
int i32_max = Integer.MAX_VALUE;

long i64 = i32_max; // implicit conversion 2147483647 (long)
short i16 = (short)i32_max; // explicit conversion -1 (short)

// usa o tipo maior
Object adicao1 = i32_max + 1; // -2147483648 (int)
Object adicao2 = i64 + i32_1; // 2147483649 (long)
Object adicao3 = i64 + i32_max; // 4294967294 (long)

// usa o tipo maior
Object subtracao1 = i32_min - 1; // 2147483647 (int)
Object subtracao2 = i16 - i32_1; // -3 (int)
Object subtracao3 = i16 - i32_max; // -2147483648 (int)

// usa o tipo maior
Object multiplicacao1 = i32_1 * i32_2; // 8 (int)
Object multiplicacao2 = i32_max * i32_1; // -2 (int)
Object multiplicacao3 = i32_1 * i64; // 4294967294 (long)

// usa o tipo maior
Object divisao1 = i32_2 / i32_1; // 2 (int)
Object divisao2 = i32_1 / i32_2; // 0 (int)
Object divisao3 = i16 / i32_1; // 0 (int)

// TODO char converte tb</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>unchecked {

	int i32_1 = 2;
	int i32_2 = 4;
	int i32_min = Int32.MinValue;
	int i32_max = Int32.MaxValue;

	long i64 = i32_max; // implicit conversion 2147483647 (long)
	short i16 = (short)i32_max; // explicit conversion -1 (short)

	// usa o tipo maior
	var adicao1 = i32_max + 1; // -2147483648 (int)
	var adicao2 = i64 + i32_1; // 2147483649 (long)
	var adicao3 = i64 + i32_max; // 4294967294 (long)

	// usa o tipo maior
	var subtracao1 = i32_min - 1; // 2147483647 (int)
	var subtracao2 = i16 - i32_1; // -3 (int)
	var subtracao3 = i16 - i32_max; // -2147483648 (int)

	// usa o tipo maior
	var multiplicacao1 = i32_1 * i32_2; // 8 (int)
	var multiplicacao2 = i32_max * i32_1; // -2 (int)
	var multiplicacao3 = i32_1 * i64; // 4294967294 (long)

	// usa o tipo maior
	var divisao1 = i32_2 / i32_1; // 2 (int)
	var divisao2 = i32_1 / i32_2; // 0 (int)
	var divisao3 = i16 / i32_1; // 0 (int)

}



// convers√£o impl√≠cita se o n√∫mero couber no outro
// byte -&gt; int, uint ou float por exemplo
// sbyte -&gt; int ou float

// convers√£o expl√≠cita
// entre integrals
// entre floats
// de floats para integrals

// tipo numerico n√£o converte pra char

/*

When you convert from a double or float value to an integral type,
the value is truncated. If the resulting integral value is outside
the range of the destination value, the result depends on the
overflow checking context.

When you convert double to float, the double value is rounded
to the nearest float value. If the double value is too small
or too large to fit into the destination type, the result
will be zero or infinity.

When you convert decimal to float or double, the decimal value is rounded
to the nearest double or float value.
*/</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>'use strict';

// s√≥ usa um √∫nico tipo num√©rico double
// n√£o h√° o que converter

// n√∫meros n√£o sofrem overflow nem underflow,
// e n√£o d√£o aviso se voc√™ tentar passar
// dos limites

let i = Number.MAX_VALUE;
let j = Number.MAX_VALUE + 1; // n√£o d√° aviso
if (i === j) {
	console.log('j foi limitado');
}

i = -i
j = -j - 1; // n√£o d√° aviso
if (i === j) {
	console.log('j foi limitado');
}</code
>
</div>

</div>



<h3 id='conversoesnumericasfuncoes'>Argumentos</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>
</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>/*

{

// convers√£o expl√≠cita de int para byte 1
this.recebeByte((byte)1);

// convers√£o expl√≠cita 44
this.recebeByte((byte)300);

}

private void recebeByte(byte numero) {
	System.out.println("\nRecebe byte");
	System.out.println(numero);
}
*/
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// s√≥ usa um √∫nico tipo num√©rico double
// n√£o h√° o que converter</code
>
</div>

</div>


<h3>Parsing de n√∫meros</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>
</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>
</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
></code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='tiposchar'>Chars</h2>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>NSNumber* someChar = @'T';
NSNumber* someChar = [NSNumber numberWithChar:'T'];</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>
</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// s√≥ usa strings
// n√£o possui chars</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='tiposstring'>Strings</h2>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// tipo &amp;str

let simples = "A primeira faz \"tchan\" e s√≥";

let calvinHarris = "how deep\nis your love"; // 2 linhas

// v√°rias linhas
let josePauloPaes = "Meu amor √© simples, Dora,
Como a √°gua e o p√£o.

Como o c√©u refletido
Nas pupilas de um c√£o.";

// concatena√ß√£o
let leminski = concat!("Merda √© veneno.",
	"No entanto, n√£o h√° nada",
	"que seja mais bonito",
	"que uma bela cagada.",
	"Cagam ricos, cagam pobres,",
	"cagam reis e cagam fadas.",
	"N√£o h√° merda que se compare",
	"√† bosta da pessoa amada."
);

// tipo String

let simples = "A primeira faz \"tchan\" e s√≥".to_string();</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>auto cString = "m√£e d'√°gua";
auto cStringEscape = "A primeira faz \"tchan\"";
auto rawString = R"(A segunda faz "tchun")";
auto html = R"(&lt;em class="especial"&gt;√™nfase&lt;/em&gt;)";

auto meuSeparador = R"meuSeparador(aa)meuSeparador";
auto meuSeparador = R"meuSeparador( )" )meuSeparador"; // FIXME highlighter raw string

auto calvinHarris = "how deep\nis your love"; // 2 linhas

auto pareceMasNaoE = "come√ßa e \
termina na mesma linha?"; // 1 linha apenas

// v√°rias linhas
auto josePauloPaes = "Meu amor √© simples, Dora,\n\
Como a √°gua e o p√£o.\n\
\n\
Como o c√©u refletido\n\
Nas pupilas de um c√£o.";

// v√°rias linhas
auto leminski = R"(Merda √© veneno.
No entanto, n√£o h√° nada
que seja mais bonito
que uma bela cagada.
Cagam ricos, cagam pobres,
cagam reis e cagam fadas.
N√£o h√° merda que se compare
√† bosta da pessoa amada.)";

// concatena√ß√£o
// TODO</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>NSString* simples = @"";
NSMutableString* mutavel = @"";
char* cString = "";</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>let simples = "A primeira faz \"tchan\" e s√≥"

let calvinHarris = "how deep\nis your love" // 2 linhas

// concatena√ß√£o - √∫nica maneira de usar v√°rias linhas antes de swift 4
let josePauloPaes = "Meu amor √© simples, Dora," +
"\nComo a √°gua e o p√£o." +
"\n" +
"\nComo o c√©u refletido" +
"\nNas pupilas de um c√£o."

// v√°rias linhas (swift 4+)
let leminskiTemplate = """Merda √© veneno.
No entanto, n√£o h√° nada
que seja mais bonito
que uma bela cagada.
Cagam ricos, cagam pobres,
cagam reis e cagam fadas.
N√£o h√° merda que se compare
√† bosta da pessoa amada."""

let leadingWhitespace = """
	Sem leading (alinhado com a √∫ltima linha)
		Com um tab de leading
	Sem leading (alinhado com a √∫ltima linha)
	"""

let multiplier = 3
let stringInterpolada = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"

let emoji = "üòç";
let combined = "\u{D83D}\u{DE0D}"
let clustered = "\u{1F60D}"

// string √© imut√°vel, ent√£o seus m√©todos retornam novas inst√¢ncias
let beeGees = calvinHarris.replacingOccurrences(of: "love", with: "looove")

"Gritando".uppercaseString // retorna 'GRITANDO'</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>val simples = "A primeira faz \"tchan\" e s√≥";

val calvinHarris = "how deep\nis your love"; // 2 linhas

// concatena√ß√£o
val josePauloPaes = "Meu amor √© simples, Dora," +
"\nComo a √°gua e o p√£o." +
"\n" +
"\nComo o c√©u refletido" +
"\nNas pupilas de um c√£o."

// v√°rias linhas
val leminskiTemplate = """Merda √© veneno.
No entanto, n√£o h√° nada
que seja mais bonito
que uma bela cagada.
Cagam ricos, cagam pobres,
cagam reis e cagam fadas.
N√£o h√° merda que se compare
√† bosta da pessoa amada."""

val leadingWhitespace = """
	|Sem leading
	|	Com leading
	|Sem leading
	""".trimMargin()
// caso padr√£o de trimMargin("|")

// TODO</code>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>String simples = "A primeira faz \"tchan\" e s√≥";

String calvinHarris = "how deep\nis your love"; // 2 linhas

// concatena√ß√£o - √∫nica maneira de usar v√°rias linhas
String josePauloPaes = "Meu amor √© simples, Dora,\n" +
"Como a √°gua e o p√£o.\n" +
"\n" +
"Como o c√©u refletido\n" +
"Nas pupilas de um c√£o.";

// concatena√ß√£o
StringBuilder leminskiBuilder = new StringBuilder();
leminskiBuilder.append("Merda √© veneno.");
leminskiBuilder.append("\nNo entanto, n√£o h√° nada");
leminskiBuilder.append("\nque seja mais bonito");
leminskiBuilder.append("\nque uma bela cagada.");
leminskiBuilder.append("\nCagam ricos, cagam pobres,");
leminskiBuilder.append("\ncagam reis e cagam fadas.");
leminskiBuilder.append("\nN√£o h√° merda que se compare");
leminskiBuilder.append("\n√† bosta da pessoa amada.");

String leminski = leminskiBuilder.toString();

// StringBuilder n√£o √© thread safe
// Existe tamb√©m a classe StringBuffer, que √©</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>var simples = "A primeira faz \"tchan\"";
var dupla = @"A segunda faz ""tchun""";
var interpolated = $"A segunda faz \"tchun\"";
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>'use strict';

let simples = 'A primeira faz "tchan"';
let dupla = "A segunda faz 'tchun'";
let duplaTemplate = `A primeira faz "tchan". A segunda faz 'tchun'`;

const iara = "m√£e d'√°gua";
const modoDificil = 'O\'Reilly';
let html = '<em class="especial">√™nfase</em>';

let calvinHarris = 'how deep\nis your love'; // 2 linhas

let pareceMasNaoE = 'come√ßa e \
termina na mesma linha?'; // 1 linha apenas

// v√°rias linhas
let josePauloPaes = 'Meu amor √© simples, Dora,\n\
Como a √°gua e o p√£o.\n\
\n\
Como o c√©u refletido\n\
Nas pupilas de um c√£o.';

// v√°rias linhas
let leminskiTemplate = `Merda √© veneno.
No entanto, n√£o h√° nada
que seja mais bonito
que uma bela cagada.
Cagam ricos, cagam pobres,
cagam reis e cagam fadas.
N√£o h√° merda que se compare
√† bosta da pessoa amada.`;

let multiplier = 3
let stringInterpolada = `${multiplier} times 2.5 is ${multiplier * 2.5}`

let emoji = 'üòç';
let es5 = '\uD83D\uDE0D'; // code units / surrogates
let es6 = '\u{1F60D}'; // code point

// string √© imut√°vel, ent√£o seus m√©todos retornam novas inst√¢ncias
let beeGees = calvinHarris.replace('love', 'looove');

'Gritando'.toUpperCase(); // retorna 'GRITANDO'</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
>Option Explicit

Dim simples As String

simples = "A primeira faz ""tchan"""
</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='tiposarray'>Arrays</h2>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// TODO
std::Array arrayCpp;
int arrayCPreAlocada[10];
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>int arrayCPreAlocada[10];

// uma dimens√£o
NSArray* prePopulada = @[@"p", @"r", @"e"];
NSArray* prePopuladaAntiga = [NSArray arrayWithObjects:@"o", @"l", @"d", nil];

int linhas = 2;
int colunas = 4;

// multi dimensional
int arrayCMdPreAlocada[linhas][colunas];
int arrayCMdPrePopulada[linhas][colunas] = {
	{0, 1, 2, 3},
	{4, 5, 6, 7}
};
int  arrayCMdPrePopulada2[linhas][colunas] = {0, 1, 2, 3, 4, 5, 6, 7};

for (NSString* valor in prePopulada) {
	//
}</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>var vazia = [Int]()
var vazia2:[Int] = []
var vazia3:Array&lt;Int&gt; = Array&lt;Int&gt;()

// uma dimens√£o
var preAlocada = [Int](count: 10, repeatedValue: 0)
preAlocada = [Int](count: 17, repeatedValue: 0)
var prePopulada = ["p", "r", "e"]
var prePopuladaT:[String] = ["p", "o", "p"]

let linhas = 2
let colunas = 4

// multi dimensional

var mdPrePopulada:[[Int]] = [
	[0, 1, 2, 3],
	[4, 5, 6, 7]
]









preAlocada[5] = 16000;
preAlocada[6...8] = [4, 20, 8];
let indice0 = prePopulada[0];
let two = mdPrePopulada[0, 2];

for valor in prePopulada {
	//
}

for (indice, valor) in prePopulada.enumerate() {
	// indice e valor
}

let tamanho =  = mdPrePopulada.count

// tamb√©m temos a propriedade .empty
// e os m√©todos insert e removeAtIndex

// TODO testar coisas n√£o cobertas na documenta√ß√£o
// comparar arrays</code
>
</div>
<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>



// uma dimens√£o
var preAlocada = IntArray(10)
preAlocada = IntArray(17)



val linhas = 2
val colunas = 4

// multi dimensional
var mdPreAlocada = Array(linhas, { IntArray(colunas) })

// TODO</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>



// uma dimens√£o
int[] preAlocada = new int[10];
preAlocada = new int[17];
String[] prePopulada = {"p", "r", "e"};


int linhas = 2;
int colunas = 4;

// multi dimensional
byte[][] mdPreAlocada = new byte[linhas][colunas];
byte[][] mdPrePopulada = {
	{0, 1, 2, 3},
	{4, 5, 6, 7}
};









preAlocada[5] = 16000;

String indice0 = prePopulada[0];
byte two = mdPrePopulada[0][2];

for (String valor : prePopulada) {
	//
}





int tamanho =  = mdPrePopulada.length;

// TODO comparar arrays

// pode mas n√£o fa√ßa
// acho que tem pra quem vem do C
float podeMasNaoFaca[];
float[][] podeMasNaoFaca = {{}};
float[] podeMasNaoFaca[] = {{}};
float podeMasNaoFaca[][] = {{}};</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>



// uma dimens√£o
int[] preAlocada = new int[10];
preAlocada = new int[17];
String[] prePopulada = {"p", "r", "e"};


int linhas = 2;
int colunas = 4;

// multi dimensional
byte[,] mdPreAlocada = new byte[linhas, colunas];
byte[,] mdPrePopulada = {
	{0, 1, 2, 3},
	{4, 5, 6, 7}
};

byte[][] arrayDeArraysPreAlocada = new byte[4][];
arrayDeArraysPreAlocada[0] = new byte[4];
// ...
byte[][] arrayDeArraysPrePopulada = {
	new byte[] {0, 1, 2, 3},
	new byte[] {4, 5, 6, 7}
};

preAlocada[5] = 16000;

String indice0 = prePopulada[0];
byte two = mdPrePopulada[0, 2];

foreach (var valor in prePopulada) {
	//
}





var tamanho = mdPrePopulada.Length

// TODO exemplos com var
// comparar arrays</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>let vazia = [];



// uma dimens√£o
let preAlocada = new Array(10);
preAlocada = new Array(17);
let prePopulada = ["p", "r", "e"];


let linha = 0;
let coluna = 2;

// multi dimensional

let mdPrePopulada = [
	[0, 1, 2, 3],
	[4, 5, 6, 7]
];









preAlocada[5] = 16000;

let indice0 = prePopulada[0];
let two = mdPrePopulada[linha][coluna];

for (let valor of prePopulada) {
	//
}





let tamanho =  = mdPrePopulada.length;
// TODO comparar arrays</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
>Dim vazia() As Integer
Dim preAlocada(9) As Integer

' Aloca espa√ßo na array vazia
' √â poss√≠vel usar vari√°veis ao inv√©s de literais fixas
ReDim Preserve vazia(0 To 9)





















preAlocada(5) = 1600


Dim valor As Integer

For Each valor In prePopulada
	'
Next</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='tiposlista'>Listas</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>NSMutableArray* lista;</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>List&lt;object&gt; lista;
</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>let lista = [];</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
>Dim lista As Collection
Set lista = New Collection</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='stackheap'>Stack e Heap</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// TODO
// tipos na stack por padr√£o

// tipos com new na heap

// enums?
// closures?
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// TODO
// structs na stack?
// e classes?
// enums?
// closures? tem closures?
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// TODO
// primtive on stack
// structs e enums value types - stack
// classes and closures on the heap
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// TODO
// &amp;'static str statically allocated lives inside the program binary code
// stack by default
// heap
// String
// Box&lt;T&gt;
// Vec&lt;T&gt;
// growable on heap
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// tipos valor na stack

// tipos primitivos na stack
int i = 10;

// enums na stack

// structs √†s vezes na stack
AStruct a;
Point p;

unsafe {
	byte* ponteiroDeArray = stackalloc byte[1024];
}

// nullables na stack

// tipos de refer√™ncia na heap

// class, interface, array e delegate
string a = "Na heap"; // TODO verificar string heap
object o = new object();</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// tipos primitivos na stack
int i = 10;

// tipos de refer√™ncia na heap
String s = "Na heap"; // TODO verificar string heap
Object o = new Object();
// enums tb?</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// N√£o existe uma defini√ß√£o
// na especifica√ß√£o
// A m√°quina virtual pode ou n√£o
// alocar tipos primitivos
// e tipos de refer√™ncia
// tanto na stack quanto na heap
</code
>
</div>

</div>

<ol>
	<li>C++ / Rust</li>
	<li>Objective-C / Swift / C#</li>
	<li>Java</li>
	<li>JavaScript</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='memoria'>Gerenciamento de mem√≥ria</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++ - RAII</p>
<code class='cpp'
>// smart pointers
</code
>
</div>

<div class='codeblock'>
<p>Objective-C - Reference Counting</p>
<code class='objectivec'
>// ARC
</code
>
</div>

<div class='codeblock'>
<p>Swift - Reference Counting</p>
<code class='swift'
>// ARC
</code
>
</div>

<div class='codeblock'>
<p>Rust - Ownership e Lifetimes</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C# - Mark and Sweep GC</p>
<code class='cs'
>// weak references
</code
>
</div>

<div class='codeblock'>
<p>Java - Mark and Sweep GC</p>
<code class='java'
>// weak e ghost references
</code
>
</div>

<div class='codeblock'>
<p>JavaScript - Mark and Sweep GC</p>
<code class='javascript'
>// weak maps
</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='ponteiros'>Apontar √© feio <span>J√° dizia sua m√£e</span></h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// vari√°vel tipo ponteiro
// ponteiros s√£o nullable e podemos usar
// o valor especial nullptr, que representa
// um endere√ßo de mem√≥ria inv√°lido
int* newNull{nullptr}; // C++11

// vers√µes antigas usam o valor NULL, que √© 0
// por baixo dos panos, tamb√©m representando
// um endere√ßo de mem√≥ria inv√°lido
int* oldNull{NULL}; // old

// existe ainda um tipo nullptr_t, que s√≥ pode
// receber nullptr e n√£o aceita nenhum outro valor
// n√£o imagino muitos usos para ele fora fazer
// piadinhas com o Elvis ;)
std::nullptr_t o_onlyNuuull{nullptr}; // C++11

// vari√°veis comuns tipo int
int intOriginal{90};
int segundoIntOriginal{95};

// vari√°vel tipo ponteiro de int (int*) aponta
// para vari√°vel comum tipo int
//  seu valor √© um inteiro 32 ou 64 bits, representando
// o endere√ßo de mem√≥ria de intOriginal, que podemos
// obter usando o operador &amp;
int* ponteiroDeInt{&amp;intOriginal};

// para acessarmos o valor da vari√°vel atrav√©s
// do ponteiro, usamos o operador *
cout &lt;&lt; "valor de int " &lt;&lt; *ponteiroDeInt &lt;&lt; endl; // 90

// se fizermos ele apontar para outra vari√°vel, seu valor muda
ponteiroDeInt = &amp;segundoIntOriginal;
cout &lt;&lt; "valor de int " &lt;&lt; *ponteiroDeInt &lt;&lt; endl; // 95

// tamb√©m podemos pegar endere√ßos de mem√≥ria atrav√©s de outros
// ponteiros, pois como disse acima, seus valores s√£o num√©ricos
// 32 ou 64 bits
int* ponteiroDeSegundoInt{ponteiroDeInt};
cout &lt;&lt; "valor de int " &lt;&lt; *ponteiroDeSegundoInt); // 95

// TODO
// podemos atribuir enderecos aleat√≥rios de mem√≥ria para ponteiros :(

// podemos marcar o ponteiro como const, mas isso
// N√ÉO PREVINE QUE ELE APONTE PARA VARI√ÅVEIS DIFERENTES!!!
// TODO verificar se previne a modifica√ß√£o dos objetos apontados
const int* ponteiroConst{&amp;intOriginal}; // 90
ponteiroConst = &amp;segundoIntOriginal; // 95

// depois que n√£o precisarmos mais dos ponteiros
// precisamos APAG√Å-LOS ANTES QUE SAIAM DE ESCOPO,
// para evitar que fiquem perdidos na mem√≥ria
// sem podermos acess√°-los (dangling pointers)
// devemos fazer isso apenas para ponteiros null
// ou ponteiros de objetos alocados na heap
// atrav√©s do operador new
delete newNull;
delete oldNull;

// o gerenciamento manual dos ponteiros com delete
// n√£o √© recomendado, e existem classes que os apagam
// automaticamente e de maneira determin√≠stica assim
// que saem de escopo
auto ponteiroSmart{std::make_unique&lt;int&gt;(1000)};
auto ponteiroSmartShared{std::make_shared&lt;int&gt;(1001)};

// TODO old boost smart pointers

// embora isso n√£o seja necess√°rio para ponteiros int*
// existe uma outra caracter√≠stica dessas classes, que
// √© n√£o permitir o valor nullptr, uma vez que seu tipo
// √© especificado
auto semNullPointer{std::make_unique&lt;int&gt;(nullptr)}; // erro :)

// embora NULL seja um valor v√°ido para int*, uma vez que
// NULL na verdade √© 0 por baixo dos panos
auto semNullPointer{std::make_unique&lt;int&gt;(NULL)}; // funciona!

// al√©m disso, n√£o √© poss√≠vel mudar o endere√ßo para o qual
// esse tipo de ponteiro aponta uma segunda vez
auto semSegundaChance{std::make_unique&lt;int&gt;(1000)};
// semSegundaChance = &amp;intOriginal; // erro
// semSegundaChance = ponteiroDeInt; // erro

// TODO refer√™ncias
// refer√™ncias n√£o s√£o ponteiros oficialmente segundo
// a especifica√ß√£o

// n√£o podem ser nullptr nem NULL
int&amp; ponteiroRefNullPointer{nullptr}; // erro :)
int&amp; ponteiroRefNULL{NULL}; // erro :)

int&amp; ponteiroRef{intOriginal}; // 90
ponteiroRef = segundoIntOriginal; // 95

const int&amp; ponteiroConstRef{intOriginal}; // 90
ponteiroConstRef = segundoIntOriginal; // erro, n√£o √© mut√°vel :)

// n√£o pode pegar o endere√ßo de refer√™ncias

// ponteiros para arrays
// ponteiros para fun√ß√µes
// void*
// ponteiros de ponteiros
// refer√™ncias de ponteiros</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// vari√°vel tipo ponteiro
// ponteiros s√£o nilable e podemos usar
// o valor nil, que representa
// um endere√ßo de mem√≥ria inv√°lido
int* nilPointer = nil; // Objective-C

// √© poss√≠vel usar do C o valor NULL, que √© 0
// por baixo dos panos, tamb√©m representando
// um endere√ßo de mem√≥ria inv√°lido
int* cNullPointer = NULL; // C</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>var nilPointer:UnsafeMutablePointer&lt;int&gt; = nil

// vari√°veis comuns tipo int
let intOriginal = 90
let segundoIntOriginal = 95

// int* ponteiroDeInt = &amp;intOriginal;
var ponteiroDeInt:UnsafeMutablePointer&lt;Int&gt; = &amp;intOriginal

print(ponteiroDeInt) // 90

ponteiroDeInt = &amp;segundoIntOriginal
print(ponteiroDeInt) // 95

let ponteiroDeSegundoInt = ponteiroDeInt
print(ponteiroDeSegundoInt) // 95

// const int* ponteiroDeInt = &amp;intOriginal;
var ponteiroConst:UnsafePointer&lt;Int&gt; = &amp;intOriginal
ponteiroConst = &amp;segundoIntOriginal

// mais ou menos const int&amp; ponteiroConstRef; ??
let ponteiroConstRef:UnsafePointer&lt;Int&gt; = &amp;intOriginal

// TODO
// podemos atribuir endere√ßos aleat√≥rios de mem√≥ria para ponteiros ??

// ponteiro de array

// ponteiros para fun√ß√µes?

// void* ponteiroGenerico;
var ponteiroGenerico:UnsafePointer&lt;Void&gt;

// int** ponteiroDePonteiro;
let ponteiroDePonteiro = AutoreleasingUnsafeMutablePointer&lt;Int?&gt; // tem que ser nullable?</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// TODO
let p:*const i32 = ptr::null();
let p:*mut i32 = ptr::null();

let x = 5;
let raw = &amp;x as *const i32;

let mut y = 10;
let raw_mut = &amp;mut y as *mut i32;

let points_at = unsafe { *raw };

unsafe {
	let points_at = *raw;
}

use std::mem;

unsafe {
	let a = [0u8, 0u8, 0u8, 0u8];
	let b = mem::transmute::&lt;[u8; 4], u32&gt;(a);
}</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>using System;

namespace MarcoLuglio.PonteirosExample {

	class MainClass {

		public static void Main(string[] args) {

			// C# requer um contexto unsafe para utiliza√ß√£o de ponteiros
			// Existem v√°rios contexto que podem ser marcados como unsafe,
			// mas vou mostrar apenas o bloco de c√≥digo unsafe
			unsafe {

				// TODO n√£o pode null pointer

				// vari√°veis comuns tipo int
				int intOriginal = 90;
				int segundoIntOriginal = 95;

				// vari√°vel tipo ponteiro de int (int*)
				// aponta para vari√°vel comum tipo int
				// seu valor √© um inteiro 64 bits (long), representando
				// o endere√ßo de mem√≥ria de intOriginal, que podemos obter
				// usando o operador &amp;
				int* ponteiroDeInt = &amp;intOriginal;

				// para acessarmos o valor da vari√°vel comum
				// atrav√©s do ponteiro, usamos o operador *
				Console.WriteLine(@"valor de int {0} ", *ponteiroDeInt); // 90

				// se fizermos ele apontar para outra vari√°vel, seu valor muda
				ponteiroDeInt = &amp;segundoIntOriginal;
				Console.WriteLine(@"valor de int {0} ", *ponteiroDeInt); // 95

				// tamb√©m podemos pegar endere√ßos de mem√≥ria atrav√©s de outros
				// ponteiros, pois como disse acima, seus valores s√£o n√∫meros
				// tipo long
				int* ponteiroDeSegundoInt = ponteiroDeInt;
				Console.WriteLine(@"valor de int {0} ", *ponteiroDeSegundoInt); // 95

				// n√£o √© poss√≠vel iniciar um ponteiro especificando diretamente
				// um endere√ßo de mem√≥ria
				int* enderecoQualquer = 10; // erro TODO verificar qual o erro

				// vari√°vel tipo ponteiro de buffer de bytes (bytes*)
				// aponta para array de bytes pr√©-alocada na stack
				// seu valor √© igual ao endere√ßo de mem√≥ria da array de bytes
				byte* ponteiroDeArray = stackalloc byte[1024];

				// atribu√≠mos o valor 5 para o √≠ndice 0 da array na stack
				// e o valor 11 para o √≠ndice 729
				// para acessarmos os √≠ndices, usamos o operador []
				ponteiroDeArray[0] = 5;
				ponteiroDeArray[729] = 11;

				// para acessarmos os valores nos √≠ndices, usamos o operador []
				byte indice0 = ponteiroDeArray[0];
				byte indice729 = ponteiroDeArray[729];
				Console.WriteLine(
					@"valores {0} e {1}",
					indice0, // 0
					indice729 // 1
				);

				// Notem que n√£o h√° nada no ponteiro que indique se tratar de uma array!
				// Ent√£o como o compilador consegue diferenciar entre um ponteiro
				// para um byte comum e para uma array de bytes?
				// Ele n√£o consegue! E dependendo do que voc√™ for fazer, nem vai lan√ßar
				// uma exce√ß√£o, apenas usar um valor incorreto.
				// Portanto cuidado ao utilizar ponteiros.
				// Por exemplo, seria v√°lido (embora n√£o recomendado) fazer isso:

				// byte byteOriginal = 37;
				// ponteiroDeArray = &amp;byteOriginal;

				// vari√°vel tipo ponteiro desconhecido
				// aponta para qualquer tipo de vari√°vel
				// quando null, seu valor √© igual a 0, representando um endere√ßo
				// de mem√≥ria inv√°lido
				// neste estado, *ponteiroGenerico lan√ßa NullReferenceException
				void* ponteiroGenerico = null;

				// esse tipo de ponteiro n√£o √© recomendado pois perde
				// a informa√ß√£o sobre o tipo para o qual ele aponta
				// essa caracter√≠stica √© usada para fazer casts for√ßados
				// neste estado, seu valor √© igual ao endere√ßo de mem√≥ria de intOriginal
				ponteiroGenerico = &amp;intOriginal;

				// para acessarmos o valor apontado por esse tipo de ponteiro
				// √© necess√°rio fazer um cast para o tipo que se deseja
				Console.WriteLine(@"valor de void {0} ", (*(int*)ponteiroGenerico)); // 90

				// agora seu valor √© igual ao endere√ßo de mem√≥ria da array de bytes
				ponteiroGenerico = ponteiroDeArray;

				// podemos acessar os valores da array apontada pelo ponteiro
				// fazendo o cast apropriado
				// a mesma recomenda√ß√£o sobre o operador [] vale aqui, o compilador
				// n√£o consegue identificar se o valor √© uma array ou um byte simples
				// e vai acreditar no que voc√™ pedir
				Console.WriteLine(@"valor de void*[0] {0} ", ((byte*)ponteiroGenerico)[0]); // 5

				// vari√°vel tipo ponteiro de ponteiro de int (int**)
				// aponta para vari√°vel do tipo ponteiro de int
				// seu valor √© igual ao endere√ßo de mem√≥ria de ponteiroGenerico
				// esse tipo de ponteiro √© utilizado quando n√£o desejamos copiar o
				// ponteiro original ao pass√°-lo para outras fun√ß√µes
				// uma vez que, como o ponteiro √© um valor long, √© passado por c√≥pia
				// para as fun√ß√µes!
				int** ponteiroDePonteiro = (int**)&amp;ponteiroGenerico;

				// para acessarmos o valor no final da cadeia, usamos o operador * duas vezes
				Console.WriteLine(@"valor de ponteiro {0} ", **ponteiroDePonteiro);

				// se usarmos apenas uma vez, obteremos o ponteiro intermedi√°rio
				Console.WriteLine(
					@"endere√ßo apontado pelo ponteiro intermedi√°rio {0} ",
					*ponteiroDePonteiro
				);

				// novamente, o compilador n√£o pode ajudar muito caso voc√™ cometa um erro
				// por exemplo, se esquecermos do operador &amp; estaremos pegando o endere√ßo
				// do valor final, ao inv√©s do endereco do ponteiro intermedi√°rio, por√©m,
				// estamos dizendo ao compilador que √© o endere√ßo de um ponteiro leg√≠timo
				ponteiroDePonteiro = (int**)ponteiroGenerico;

				// e s√≥ ser√° lan√ßado um erro se tentarmos acessar o valor final na cadeia
				// pois estaremos tentando usar um valor inteiro como se fosse um ponteiro
				Console.WriteLine(@"lan√ßa NullReferenceException {0} ", **ponteiroDePonteiro);

				// embora possamos criar ponteiros de ponteiros de ponteiros, acho que n√£o
				// h√° uma aplica√ß√£o muito pr√°tica pra isso
				int*** ponteiroDesnecessario;

				// TODO structs e fixed {}

			}

			// os ponteiros s√£o desalocados ap√≥s o t√©rmino do contexto unsafe
			// n√£o √© necess√°rio deletar os ponteiros manualmente

		}

	}

}</code
>
</div>

<div class='codeblock'>
<p>Java</p>
-
</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

</div>

<ol>
	<li>Swift</li>
	<li>C++ / C#</li>
	<li>Objective-C</li>
	<li>TODO classificar rust quando tiver um exemplo mais completo</li>
</ol>

<p>N√£o sei ao certo como avaliar esse t√≥pico. Certamente n√£o √© a mesma coisa que gerenciamento de mem√≥ria avaliado logo acima.
<br />Todas as linguagens permitem <code class='cpp'>void*</code> de alguma maneira
<br />Swift possui nomes mais claros em rela√ß√£o ao que cada ponteiro significa, embora a rela√ß√£o com suas vers√µes em C n√£o sejam f√°ceis de adivinhar. N√£o √© necess√°rio utilizar operadores diferentes para interagir com ponteiros.
<br />C# tenta evitar ao m√°ximo o uso de ponteiros para tarefas corriqueiras. Mas faz muito pouco em rela√ß√£o √† C++ para impedir problemas com a utiliza√ß√£o de ponteiros quando s√£o necess√°rios, e acaba sendo equivalente em seguran√ßa, embora de maneira diferente. As duas linguagens possuem recursos para impedir ponteiros <code class='cs'>null</code>, e para apagar os ponteiros quando sa√≠rem de escopo. C# delimita claramente um bloco isolado para trabalhar com ponteiros, mas n√£o permite marc√°-los como <code class='cs'>const</code>. C++ ainda tem o operador <code class='cpp'>delete</code>, mas voc√™ n√£o precisa us√°-lo.
<br />Objective-C usa ponteiros estilo C. Requer muitas vezes que os objetos sejam alocados e depois inicializados num passo diferente. Como muitas coisas nessa linguagem, mistura sintaxes das duas linguagens. Por exemplo, <em>ivars</em> e <em>properties</em>.</p>

</section>



<section>

<h2 id='typealias'>Type Aliasing</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// simple type
using size_t = unsigned int;
typedef unsigned char BYTE; // old

// function type
using StrategyFunctionPointer = void(*)();

// ou
using StrategyFunction_t = void();
StrategyFunction_t* strategyFunctionPointer = f;

// ou
#include &lt;type_traits&gt;
using StrategyFunctionPointer = std::add_pointer&lt;void()&gt;::type;

// ou (old)
typedef void(*StrategyFunctionPointer)();

// s√≥ metodos ou fun√ß√µes tb?</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// simple type
@compatibility_alias UICollectionViewController PSTCollectionViewController;
typedef unsigned char BYTE;

// function type
typedef void(*StrategyFunctionPointer)();</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// simple type
typealias AudioSample = UInt16


// function type
typealias StrategyFunctionPointer = () -&gt; ()</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// simple type
type Name = String;


// function type
// TODO testar
// type StrategyFunctionPointer = Fn(i32) -&gt; i32;</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// simple type
using R = N1.N2;


// function type
delegate void StrategyFunctionDelegate();</code
>
</div>

<div class='codeblock'>
<p>Java</p>
-
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>
</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>


<section>

<h2 id='lacos'>La√ßos</h2>

<h3 id='foreach'>for each</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>for item in collection {
	println!("{}", item);
}</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>for (const auto &amp;item : collection) { // C++ 11+
	cout &gt;&gt; item;
}

// functor com contrutor impl√≠cito
struct Functor {
	void operator()(const Item&&amp;item) {
		cout &gt;&gt; item;
	}
};
Functor functor();
std::for_each(collection.begin(), collection.end(), functor);</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>for(id item in collection) {
	NSLog(item);
} </code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>for item in collection {
	print(item)
}

let numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
for (animalName, legCount) in numberOfLegs {
	print("\(animalName)s have \(legCount) legs")
}</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>for (item in collection) {
	print(item)
}</code
></div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>for (Object item : collection) {
	System.out.println(item);
}</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>foreach (object item in collection) {
	System.Console.WriteLine(item);
}</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>for (item of collection) {
	console.log(item);
}

for (item in collection) {
	if (collection.hasOwnProperty(item)) {
		console.log(item);
	}
}</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
>For Each item In collection
	Print item
Next</code
>
</div>

</div>

<h3 id='foreach'>for each + ranges</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>for index in 0..5 {
	println!("{}", x); // x: i32
}</code
>
</div>

<div class='codeblock'>
<p>C++</p>
-
</div>

<div class='codeblock'>
<p>Objective-C</p>
-
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>for index in 0...4 {
	print("\(index) times 5 is \(index * 5)")
}

let minutes = 30
for tickMark in 0..&lt;minutes {
	// render the tick mark each minute (30 times)
}

// range exclusivo - to
let minuteInterval = 5
for tickMark in stride(from: 0, to: minutes, by: minuteInterval) {
	// render the tick mark every 5 minutes (0, 5, 10 ... 25)
}

// range inclusivo - through
let minuteInterval = 5
for tickMark in stride(from: 0, through: minutes, by: minuteInterval) {
	// render the tick mark every 5 minutes (0, 5, 10 ... 30)
}</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>for (i in 0..4) {
	print(i)
}</code
></div>

<div class='codeblock'>
<p>Java</p>
-
</div>

<div class='codeblock'>
<p>C#</p>
-
</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
-
</div>

</div>

<h3>label, goto, continue, break e switch</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// label e break / continue

'loop1: for i in 0...3 {

	'loop2: for j in 0...3 {
		if (i == 1 &amp;&amp; j == 1) {
			continue 'loop1; // pode usar break tb
		}
		println!(
			"i = {0}, j = {1}",
			i, // 0
			j // 1
		)
	}
}



// switch e match
match x {
	1 | 2 => println!("one or two"),
	3...5 => println!("between three and five"),
	6 => println!("six"),
	// default √© opcional, mas se ausente
	// os demais cases devem ser exaustivos
	_ => println!("something else"),
}

// ver <a href='https://doc.rust-lang.org/1.1.0/book/patterns.html'>destructuring</a></code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
></code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
></code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// label e break / continue
loop1:
for i in 0..&lt;3 {
	loop2:
	for j in 0..&lt;3 {
		if (i == 1 &amp;&amp; j == 1) {
			continue loop1; // pode usar break tb
		}
		print("i = \(i), j = \(j)")
	}
}

// testar isso
/*label: {
	// do stuff
	if check break label
	// do more stuff
}*/

// switch e fallthrough
switch a {
	case "a":
		// tem que ser indicado explicitamente
		// com a palavra fallthrough
		fallthrough
	case "A":
		//

	default:
		//
}

// switch e match
switch a {

	case "a", "A":
		print("The letter A")
		// break √© impl√≠cito
		// mas ainda pode ser usado
		// no meio de um bloco por exemplo

	// default √© opcional, mas se ausente
	// os demais cases devem ser exaustivos
	default:
		print("Not the letter A")

}

switch approximateCount {
	case 0:
		naturalCount = "no"
	case 1..&lt;5:
		naturalCount = "a few"
	default:
		naturalCount = "many"
}

switch somePoint {
	case (0, 0):
		print("\(somePoint) is at the origin")
	case (_, 0):
		print("\(somePoint) is on the x-axis")
	case (0, _):
		print("\(somePoint) is on the y-axis")
	case (-2...2, -2...2):
		print("\(somePoint) is inside the box")
	default:
		print("\(somePoint) is outside of the box")
}

let anotherPoint = (2, 0)
switch anotherPoint {
	case (let x, 0):
		print("on the x-axis with an x value of \(x)")
	case (0, let y):
		print("on the y-axis with a y value of \(y)")
	case let (x, y):
		print("somewhere else at (\(x), \(y))")
}

switch yetAnotherPoint {
	case let (x, y) where x == y:
		print("(\(x), \(y)) is on the line x == y")
	case let (x, y) where x == -y:
		print("(\(x), \(y)) is on the line x == -y")
	case let (x, y):
		print("(\(x), \(y)) is just some arbitrary point")
}</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>// label e break / continue
for (i in 0 until 3) {
	loop2@
	for (j in 0 until 3) {
		if (i == 1 &amp;&amp; j == 1) {
			continue@loop1 // pode usar break@ tb
		}
		println("i = $i, j = $j")
	}
}

// testar isso
/*label: {
	// do stuff
	if (check) break label
	// do more stuff
}*/

// switch e match (em kotlin se chama when)
when (x) {
	0, 1 -&gt; print("x == 0 or x == 1")
	else -&gt; print("otherwise")
}

when (x) {
	in 1..10 -&gt; print("x is in the range")
	in validNumbers -&gt; print("x is valid")
	!in 10..20 -&gt; print("x is outside the range")
	else -&gt; print("none of the above")
}</code
></div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// label e break / continue











label: {
	// do stuff
	if (check) break label;
	// do more stuff
}</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// label e goto
for (int a = 0; a &lt; 10; a++) {
	for (int y = 0; y &lt; 10; y++) { // Run until condition.
		for (int x = 0; x &lt; 10; x++) { // Run until condition.
			if (x == 5 &amp;&amp; y == 5) {
				goto Outer;
			}
		}
		dummy++;
	}
Outer:
	continue;
}
return dummy;

// switch e goto
switch (id) {
	case 1000:
		price += 10;
		goto case 100;
	case 100:
		return price * 10;
	default:
		return price;
}

// switch fallthrough
switch (id) {
	case "ab":
	case "cd":
	case "ef":
		// n√£o pode haver nenhum c√≥digo entre os "case"
		break;
	case "gh":
		break;
	default: // default √© opcional
		break;
}

// switch e "match" - requer C# 7+
switch(shape) {
	case Circle c:
		WriteLine($"circle with radius {c.Radius}");
		break;
	case Rectangle s when (s.Length == s.Height):
		WriteLine($"{s.Length} x {s.Height} square");
		break;
	case Rectangle r:
		WriteLine($"{r.Length} x {r.Height} rectangle");
		break;
	default:
		WriteLine("unknown shape");
		break;
	case null:
		throw new ArgumentNullException(nameof(shape));
}</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// label e break / continue
loop1:
for (i = 0; i &lt; 3; i++) {
	loop2:
	for (j = 0; j &lt; 3; j++) {
		if (i === 1 &amp;&amp; j === 1) {
			continue loop1; // pode usar break tb
		}
		console.log(`i = ${i}, j = ${j}`);
	}
}

label: {
	// do stuff
	if (check) break label;
	// do more stuff
}









// switch fallthrough
switch (id) {
	case "ab":
	case "cd":
		// algum c√≥digo aqui
	case "ef":
		// n√£o pode haver nenhum c√≥digo entre os "case"
		break;
	case "gh":
		break;
	default: // default √© opcional
		break;
}</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
>'label e goto, resume e next
On Error GoTo Erro

	' Fa√ßa alguma coisa e saia da fun√ß√£o
	' antes de chegar nas linhas de tratamento de erro
	Exit Sub

' Label de erro
' Labels n√£o podem conter espa√ßos em branco antes dos nomes
Erro:
	' Fa√ßa alguma coisa e saia da fun√ß√£o
	Exit Sub

	' Ou continue a execu√ß√£o normalmente
	Resume Next

	' Ou passe para um tratamento espec√≠fico
	If Err.Number = 13 Then
		Resume ErroEspecifico

ErroEspecifico:
	Exit Sub




'switch ("select")
Select Case age
	Case 50
		ageBlock = "the big five-oh"
	Case 80, 81, 82, 83, 84, 85, 86, 87, 88, 89
		ageBlock = "octogenarian"
	Case 90 To 99
		ageBlock = "nonagenarian"
	Case Is >= 100
		ageBlock = "centenarian"
	Case Else
		ageBlock = "just old"
End Select</code
>
</div>

</div>

</section>



<section>

<h2 id='funcoes'>Fun√ß√µes</h2>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// declara√ß√£o de fun√ß√£o
fn normal() { /**/ } // mesmo que -&gt; ()
fn normalUnit() -&gt; () { /**/ }


// express√£o de fun√ß√£o
let expressao = normal;

fn retorno() -&gt; &amp;'static str {
	"retorno" // sem ; no final
}

fn retorno() -&gt; &amp;'static str {
	return "retorno";
}


use std::any::Any;

fn retornoMisturado() -&gt; Any {
	// TODO
}




fn superior&lt;F&gt;(funcao:F) where F:Fn() {
	funcao();
}

fn superior&lt;F&gt;(funcao:F) -&gt; &amp;'static str where F:Fn() {
	funcao();
}

// TODO fazer superior com type aliasing

superior(normal);
superior(normalUnit);
superior(retorno);</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// declara√ß√£o de fun√ß√£o
void normal() { /**/ }



// express√£o de fun√ß√£o
auto expressao = normal;

std::string retorno() {
	return "retorno";
}

void superior(void(*funcao)()) {
	funcao();
}

void superior(std::string(*funcao)()) {
	funcao();
}

// ou

using Function_t = void();

void superior(Function_t* funcao) {
	funcao();
}

using Function2_t = std::string();

void superior(Function2_t* funcao) {
	funcao();
}

// ou

using FunctionPointer = void(*)();

void superior(FunctionPointer funcao) {
	funcao();
}

using FunctionPointer2 = std::string(*)();

void superior(FunctionPointer2 funcao) {
	funcao();
}

// ou

#include &lt;type_traits&gt;

using FunctionPointer = std::add_pointer&lt;void()&gt;::type;

void superior(FunctionPointer funcao) {
	funcao();
}

using FunctionPointer2 = std::add_pointer&lt;std::string()&gt;::type;

void superior(FunctionPointer2 funcao) {
	funcao();
}

superior(&amp;normal);
superior(&amp;retorno);</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// declara√ß√£o de fun√ß√£o
void normal() { /**/ }

// TODO
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// declara√ß√£o de fun√ß√£o
func normal() { /**/ } // mesmo que -&gt; Void ou -&gt; ()
func normalVoid() -&gt; Void { /**/ }
func normalEmptyTuple() -&gt; () { /**/ }

// express√£o de fun√ß√£o
let expressao = normal;

func retorno() -&gt; String {
	return "retorno"
}








func retornoMisturado(numero:Int) -&gt; Any {
	if numero &gt; 0 {
		return "texto";
	}
	return 25;
}

func superior(funcao:() -&gt; Void) {
	funcao()
}

func superior(funcao:() -&gt; String) {
	funcao()
}

// TODO fazer superior com type aliasing
// TODO explicar nomes de par√¢metros

superior(normal)
superior(normalVoid)
superior(normalEmptyTuple)
superior(retorno)</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
-
</div>

<div class='codeblock'>
<p>Java</p>
-
</div>

<div class='codeblock'>
<p>C#</p>
-
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>//  declara√ß√£o de fun√ß√£o
function comum() { /**/ }
function normal(texto) { /**/ }


// express√£o de fun√ß√£o
const surpresa = function() { /**/ };
const outraSurpresa = normal;

// express√£o de fun√ß√£o an√¥nima auto execut√°vel
// note os () em volta dela
(function() {
	//
})();

function retorno() {
	return "retorno";
}

function retornoMisturado(numero) {
	if (numero &gt; 0) {
		return 'texto';
	}
	return 25;
}

function superior(funcao) {
	funcao();
}

// chamadas perfeitamente v√°lidas
comum(); // arguments ser√° []
comum('lala'); // arguments ser√° ['lala']
comum('lala', 'lolo'); // arguments ser√° ['lala', 'lolo']
normal('lolo'); // texto ser√° 'lolo' e  arguments ser√° ['lolo']

// chamada v√°lida
normal(); // o par√¢metro texto ter√° o valor undefined e arguments ser√° []

normal.call(this, 'dada√≠smo'); // o par√¢metro texto ter√° o valor 'dada√≠smo' e arguments ser√° ['dada√≠smo']</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
>'M√©todos que n√£o retornam valores s√£o chamados subrotinas, ou simplesmente subs
Public Sub SemRetorno()
	'...
End Sub

'Podemos sair precocemente de um sub usando Exit Sub
Public Sub AbortarCedo()

	Dim algumaFlag As Boolean: algumaFlag = True

	If algumaFlag Then
		Exit Sub 'Equivalente √† "return"
	End If

	'Fazer o resto se passar pela flag

End Sub


'M√©todos com retorno s√£o Fun√ß√µes
Public Function ComRetorno() As Boolean

 	'Equivalente √† "return true".
	'Note que s√£o necess√°rias duas linhas

	ComRetorno = True 'Esta atribui o valor de retorno, mas n√£o interfere na execu√ß√£o das linhas seguintes
	Exit Function 'E esta retorna o valor especificado imediatamente

End Function 'Caso o Exit Function n√£o tenha sido usado, retorna o valor especificado quando chegar aqui


'Tanto subs quanto fun√ß√µes podem receber par√¢metros

Private Sub ComParametro(i As Byte)
	Exit Sub
End Sub

Private Function ComParametroERetorno(i As Integer) As Boolean
	If i &lt;&gt; 0 Then 'Operador diferente √© &lt;&gt;
		ComParametroERetorno = True
		Exit Function
	Else
		ComParametroERetorno = False
		Exit Function
	End If
End Function
'Ou
Private Function ComParametroERetorno(i As Integer) As Boolean
	ComParametroERetorno = IIf(i &lt;&gt; 0, True, False) 'Inline If (IIf) funciona quase como operador tern√°rio ? :
	Exit Function
End Function


'Podemos passar v√°rios par√¢metros separando por v√≠rgula
Private Sub ComParametro(i As Long, j As Currency)
	'...
End Sub


'E podemos quebrar os par√¢metros em at√© 24 linhas utilizando _ (continua√ß√£o de linha)
'Note que √© necess√°rio um espa√ßo antes de _
'E n√£o podem haver coment√°rios :(
Private Sub ComParametro( _
	i As Single, _
	j As Double _
)

	'Single √© float, e Double √© double mesmo

End Sub

'Para chamar subrotinas e fun√ß√µes, existem casos em que deve ser usados par√™nteses, e casos em que eles n√£o devem ser usados
'O uso de par√™nteses quando n√£o obrigat√≥rio faz com que os par√¢metros sejam passados por valor ao inv√©s de refer√™ncia
'Teoricamente Call deveria permitir usar par√™nteses sempre, mas n√£o √© o caso. N√£o h√° necessidade de usar Call

'TODO Testar isso aqui

Dim param As Integer: param = 1
Dim param2 As Integer: param = 1

ComRetorno
Call ComRetorno
retorno = ComRetorno
retorno = ComRetorno()

ComParametro param 'Passado por refer√™ncia
ComParametro(param) 'Passado por valor
Call ComParametro(param)

ComParametroERetorno param 'Passado por refer√™ncia
ComParametroERetorno(param) 'Passado por valor
Call ComParametroERetorno(param)
retorno = ComParametroERetorno(param)

ComDoisParametros param, param2 'Passado por refer√™ncia
ComDoisParametros(param, param2) 'Passado por valor
Call ComDoisParametros(param, param2)

ComParametroERetorno param, param2 'Passado por refer√™ncia
ComParametroERetorno(param, param2) 'Passado por valor
Call ComParametroERetorno(param, param2)
retorno = ComParametroERetorno(param, param2)</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>


<h3 id='argumentosreferencia'>Argumentos por refer√™ncia</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// ver <a href='#ponteiros'>ponteiros</a></code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// ver <a href='#ponteiros'>ponteiros</a></code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// ver <a href='#ponteiros'>ponteiros</a></code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// tipos primitivos por valor por padr√£o
// modific√°veis com inout
// arrays e objetos por refer√™ncia

func swapTwoInts(_ a:inout Int, _ b:inout Int) {
	let temp = a
	a = b
	b = temp
}

var a = 2
var b = 3
// requer &amp; na frente do nome
// al√©m do inout da defini√ß√£o
swapTwoInts(&amp;a, &amp;b)</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>// tipos primitivos por valor
// arrays e objetos por refer√™ncia</code
></div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// tipos primitivos por valor
// arrays e objetos por refer√™ncia</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// tipos primitivos por valor por padr√£o
// modific√°veis com ref ou out
// arrays e objetos por refer√™ncia

public void SwapTwoInts(ref int a, ref int b) {
	int temp = a;
	a = b;
	b = temp;
}

public bool OutExample(string a, out int c) {
	// TODO alguma l√≥gica condicional com a
	return false;
}

// argumentos ref precisam ser inicializados
// antes de serem passados para a fun√ß√£o
var a = 2;
var b = 3;
SwapTwoInts(a, b);

// argumentos out N√ÉO precisam ser inicializados
// antes de serem passados para a fun√ß√£o
int c;
if (!OutExample(c)) {
	return;
}</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// tipos primitivos por valor
// arrays e objetos por refer√™ncia</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
><strong class='small comment'>'O padr√£o √© passar tudo por refer√™ncia,</strong>
<strong class='small comment'>'inclusive tipos primitivos como Ints</strong>
'Podemos for√ßar a passagem de um par√¢metro
'por valor ou por refer√™ncia usando ByVal e ByRef
'Essa palavras n√£o tem efeito quando passamos constantes

'Arrays e User Defined Types (UDTs) n√£o podem
'ser passados por valor

Private Sub PorValor(ByVal i As Long)
	'...
End Sub

Private Sub PorReferencia(ByRef i As Long)
	'...
End Sub</code
>
</div>

</div>



<h3 id='argumentosopcionais'>Argumentos opcionais</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
-
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
	>void point(int x, int y) { /**/ }
void point(int x, int y = 4) { /**/ }
void point(int x = 3, int y = 4) { /**/ }</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
-
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>//func point(x:Int, y:Int) { /**/ } // testar
func point(x:Int, y:Int = 4) { /**/ }
// func point(x:Int = 3, y:Int = 4) { /**/ } //testar</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>// fun point(x:Int, y:Int) { /**/ } // testar
fun point(x:Int, y:Int = 4) { /**/ }
// fun point(x:Int = 3, y:Int = 4) { /**/ } // testar

// named arguments
fun point(x:Int = 3, y:Int) { /**/ }

// tamb√©m <a href='#overload'>overload</a> como alternativa</code
></div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// n√£o possui
// usar <a href='#overload'>overload</a> como alternativa</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// public void Point(int x, int y) { /**/ } // testar
public void Point(int x, int y = 4) { /**/ }
// public void Point(int x = 3, int y = 4) { /**/ } // testar

// tamb√©m <a href='#overload'>overload</a> como alternativa</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// a assinatura das fun√ß√µes n√£o √© verificada ao cham√°-las
// podemos passar mais ou menos argumentos para a fun√ß√£o
// independente de como ela foi definida
// os argumentos a mais n√£o ter√£o nome
// e os argumentos a menos ter√£o o valor null
function point(x, y) {
	if (y == null) {
		y = 4;
	}
}</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
>Private Sub Point(X As Integer, Optional Y As Integer = 4)
	'
End Sub</code
>
</div>

</div>



<h3 id='argumentosnome'>Argumentos nomeados</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// usar builder pattern
// como alternativa</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// usar builder pattern
// como alternativa</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// todos os argumentos devem ser nomeados</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>func namedArgs(
	tooMany:Int,
	args:Int,
	toRemember:Bool,
	theirMeaning:String = "a",
	byPosition:String = "b"
	) {

	//
}

// argumentos devem seguir a ordem
// mas os que possuem valor padr√£o
// podem ser omitidos
namedArgs(
	tooMany: 2,
	args: 1,
	toRemember: false,
	byPosition: "args"
)

// nomes dos argumentos que podem
// ser omitidos devem usar _ para
// o nome externo
func unnamedArgs(
	tooMany:Int,
	_ args:Int,
	_ toRemember:Bool,
	_ theirMeaning:String = "a",
	_ byPosition:String = "b"
	) {

	//
}

unnamedArgs(tooMany: 2, 1, false, "args")</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>fun namedArgs(
	tooMany:Int,
	args:Int,
	toRemember:Boolean,
	theirMeaning:String = "a",
	byPosition:String = "b"
	) {

	//
}

namedArgs(
	tooMany = 2,
	args = 1,
	toRemember = false,
	byPosition = "args"
)

// TODO verificar isso pq tem par√¢metro faltando
namedArgs(
	2,
	args = 1,
	toRemember = false,
	byPosition = "args"
)

// TODO verificar isso pq tem par√¢metro faltando
namedArgs(tooMany = 2, 1, false, "args")</code
></div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// usar builder pattern
// como alternativa</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>public class NamedArgs {
	public NamedArgs(
		int tooMany,
		int args,
		bool toRemember,
		string theOrder
		) {

		//
	}
}

// argumentos n√£o precisam seguir a ordem
// e os que possuem valor padr√£o podem
// ser omitidos
var ex = new NamedArgs(
	args: 1,
	toRemember: false,
	tooMany: 2,
	theOrder: "named"
);</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// usar builder pattern
// como alternativa</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
>'usar builder pattern
'como alternativa</code
>
</div>

</div>



<h3 id='funcoesvariadicas'>Fun√ß√µes e M√©todos Vari√°dicos</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
At√© a vers√£o 1.8 n√£o possui
</div>

<div class='codeblock'>

<p>C++</p>
<code class='cpp'
>// argumentos do mesmo tipo

#include &lt;iostream&gt;

using std::string;
using std::cout;
using std::endl;

template&lt;typename... Tipos&gt;
void imprimirSimples(string titulo, Tipos... paginas) {

	const uint16_t quantidadeDeParametros {sizeof...(paginas)};

	// n√£o pode criar uma array com 0 elementos
	if (quantidadeDeParametros == 0) {
		return;
	}

	// expande os argumentos
	int paginasArray[quantidadeDeParametros] {paginas...};

	for (auto pagina : paginasArray) {
		cout &lt;&lt; "Imprimindo p√°gina " &lt;&lt; pagina &lt;&lt; endl;
	}

}

imprimirSimples(1, 2, 5);</code
>

<p>C++</p>
<code class='cpp'
>// argumentos de todos os tipos

#include &lt;iostream&gt;
#include &lt;boost/range/irange.hpp&gt;

using std::string;
using std::cout;
using std::endl;

/// imprimirHelper template gen√©rico
template&lt;typename T&gt;
void imprimirHelper(T pagina) {
	// poderia usar a linha abaixo para descobrir o tipo de T
	// por√©m, melhor usar o template especializado
	// if (std::is_same&lt;T, int&gt;::value) { /* ... */ }
	cout &lt;&lt; "Imprimindo outra coisa" &lt;&lt; endl;
}

/// imprimirHelper template especializado para int
template&lt;&gt;
void imprimirHelper&lt;int&gt;(int pagina) {
	cout &lt;&lt; "Imprimindo p√°gina " &lt;&lt; pagina &lt;&lt; endl;
}

/// imprimirHelper template especializado para boost::irange
template&lt;&gt;
void imprimirHelper&lt;boost::irange&gt;(boost::irange faixa) {
	cout &lt;&lt; "Imprimindo p√°gina " &lt;&lt; std::begin(faixa) &lt;&lt; " at√© " &lt;&lt; std::end(faixa) &lt;&lt; endl;
}


// foward declaration imprimir template?? N√£o estou certo da fun√ß√£o disso :/
void imprimir(string titulo) {}

// implementa√ß√£o imprimir template
template&lt;typename Tipo, typename... Tipos&gt;
void imprimir(string titulo, Tipo pagina, Tipos... paginas) {
	// executa o helper especializado e chama recursivamente a si mesmo
	imprimirHelper(pagina);
	imprimir(titulo, paginas...);
}

imprimir&lt;int, boost::irange, string&gt;("resumo", 1, boost::irange(2, 5), "cap√≠tulo 2");</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// macros n√£o seguras estilo C

#include &lt;iostream&gt;
#include &lt;cstdarg&gt;

void imprimirSimplesMacro(const std::string titulo, ...) {

	// va_list argumentos recebe o que vir depois do par√¢metro titulo
	va_list argumentos;
	va_start(argumentos, titulo);

	int pagina;
	while (true) {
		pagina = va_arg(argumentos, int);
		if (pagina == -1) {
			break;
		}
		std::cout &lt;&lt; "Imprimindo " &lt;&lt; pagina &lt;&lt; std::endl;
	}

	va_end(argumentos);

}

// preciso sempre passar -1 no final como terminador
// se n√£o d√° overflow e l√™ peda√ßo de mem√≥ria al√©m do que deveria
imprimirSimplesMacro("resumo", 1, 2, 5, -1);</code
>
</div>

<div class='codeblock'>

<p>Swift</p>
<code class='swift'
>// argumentos do mesmo tipo

func imprimirSimples(titulo titulo:String, paginas:Int...) {
	for pagina in paginas {
		print("Imprimindo p√°gina \(pagina) num total de \(paginas.count)")
	}
}

imprimirSimples(titulo: "resumo", paginas: 1, 2, 5)</code
>

<p>Swift</p>
<code class='swift'
>// argumentos de todos os tipos

func imprimir(titulo titulo:String, paginas:Any...) {
	for valor in paginas {
		switch valor {
		case let pagina as Int:
			print("Imprimindo p√°gina \(pagina)")
		case let faixa as Range&lt;Int&gt;:
			print("Imprimindo p√°ginas \(faixa.first!) at√© \(faixa.last!)")
		default:
			print("Imprimindo outra coisa")
		}
	}
}

imprimir(titulo: "resumo", paginas: 1, 2...5, "cap√≠tulo 2")</code
>
</div>



<div class='codeblock'>

<p>Kotlin</p>
<code class='kotlin'
>// argumentos do mesmo tipo

imprimirSimples(String titulo, vararg paginas:Int) {
	/*for (int pagina : paginas) {
		System.out.println(String.format("Imprimindo p√°gina %1", pagina));
	}*/
}

imprimirSimples("resumo", 1, 2, 5);</code
>

<p>Kotlin</p>
<code class='kotlin'
>// argumentos de todos os tipos

/*void imprimir(String titulo, Object... paginas) {
	for (Object valor : paginas) {
		if (valor instanceof Integer) {
			System.out.println(String.format("Imprimindo p√°gina %d", valor));
		} else if (valor instanceof Range&lt;Integer&gt;) {
			System.out.println(String.format(
				"Imprimindo p√°ginas %d at√© %d",
				((Range&lt;Integer&gt;)valor).getMinimum(),
				((Range&lt;Integer&gt;)valor).getMaximum()
			));
		} else {
			System.out.println("Imprimindo outra coisa");
		}
	}
}

imprimir("resumo", 1, Range.between(2, 5), "cap√≠tulo 2");*/</code
>
</div>



<div class='codeblock'>

<p>Java</p>
<code class='java'
>// argumentos do mesmo tipo

void imprimirSimples(String titulo, int... paginas) {
	for (int pagina : paginas) {
		System.out.println(String.format("Imprimindo p√°gina %1", pagina));
	}
}

imprimirSimples("resumo", 1, 2, 5);</code
>

<p>Java</p>
<code class='java'
>// argumentos de todos os tipos

void imprimir(String titulo, Object... paginas) {
	for (Object valor : paginas) {
		if (valor instanceof Integer) {
			System.out.println(String.format("Imprimindo p√°gina %d", valor));
		} else if (valor instanceof Range&lt;Integer&gt;) {
			System.out.println(String.format(
				"Imprimindo p√°ginas %d at√© %d",
				((Range&lt;Integer&gt;)valor).getMinimum(),
				((Range&lt;Integer&gt;)valor).getMaximum()
			));
		} else {
			System.out.println("Imprimindo outra coisa");
		}
	}
}

imprimir("resumo", 1, Range.between(2, 5), "cap√≠tulo 2");</code
>
</div>



<div class='codeblock'>

<p>C#</p>
<code class='cs'
>// argumentos do mesmo tipo

void ImprimirSimples(string titulo, params int[] paginas) {
	foreach (int pagina in paginas) {
		System.Console.WriteLine(
			@"Imprimindo pagina {0} num total de {1}",
			pagina,
			paginas.Length
		);
	}
}

ImprimirSimples(@"resumo", 1, 2, 5);</code
>

<p>C#</p>
<code class='cs'
>// argumentos de todos os tipos

void Imprimir(string titulo, params object[] paginas) {
	foreach (object valor in paginas) {
		if (valor is int) {
			System.Console.WriteLine(@"Imprimindo p√°gina {0}", valor);
		} else if (valor is IEnumerable&lt;int&gt;) {
			System.Console.WriteLine(
				@"Imprimindo p√°ginas {0} at√© {1}",
				(valor as IEnumerable&lt;int&gt;).First(),
				(valor as IEnumerable&lt;int&gt;).Last()
			);
		} else {
			System.Console.WriteLine(@"Imprimindo outra coisa");
		}
	}
}

Imprimir(@"resumo", 1, Enumerable.Range(2, 4), @"cap√≠tulo 2");</code
>
</div>



<div class='codeblock'>

<p>JavaScript</p>
<code class='javascript'
>'use strict';

// argumentos do mesmo tipo

function imprimirSimples(titulo, ...paginas) {
	for (let pagina of paginas) {
		console.log(`Imprimindo p√°gina ${pagina}`);
	}
}

imprimirSimples("resumo", 1, 2, 5);</code
>

<p>JavaScript</p>
<code class='javascript'
>'use strict';

// argumentos de todos os tipos

function imprimir(titulo, ...valores) {
	for (let valor of valores) {
		if (Number.isInteger(valor)) {
			console.log(`Imprimindo p√°gina ${valor}`);
		} else if ((valor.begin || valor.begin === 0)
			&amp;&amp; valor.end
			) {
			console.log(`Imprimindo p√°ginas ${valor.begin} at√© ${valor.end}`);
		} else {
			console.log('Imprimindo outra coisa');
		}
	}
}

imprimir("resumo", 1, {begin: 2, end: 5}, "cap√≠tulo 2");</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
>' argumentos do mesmo tipo

Public Sub ImprimirSimples(titulo As String, ParamArray paginas() As Integer)
	Dim pagina As Integer
	For Each pagina In paginas
		Print pagina
	Next
End Sub

Imprimir "resumo", 1, 2, 5</code>
</div>

</div>



<ol>
	<li>a</li>
</ol>

<p>A</p>



<h3 id='lambdas'>Lambdas</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>func superior(funcao:() -&gt; Void) {
	funcao()
}

// declara√ß√£o simplificada
superior({() in print("lambda")})




func superior(funcao:(_:Int) -&gt; Int) {
	print(funcao(1))
}

// declara√ß√£o simplificada
superior({x in x + 1})

// declara√ß√£o completa
superior({(x:Int) -&gt; Int in
	return x + 1
})

// superior({x, y in x + y})</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>public class Main {

	public static void Main(string[] args) {







		// declara√ß√£o simplificada
		Main.superior(() =&gt; System.Console.WriteLine("lambda"));


		// declara√ß√£o simplificada
		Main.superior(x =&gt; x + 1);

		// declara√ß√£o completa
		Main.superior((int x) =&gt; {
			return x + 1;
		});

		// Main.superior(x, y -&gt; x + y);

	}

	public delegate void LambdaDelegate();




	public static void superior(LambdaDelegate funcao) {
		funcao();
	}

	public delegate int Lambda2Delegate(int x);




	public static void superior(Lambda2Delegate funcao) {
		System.Console.WriteLine(funcao(1));
	}

}</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>public class Main {

	public static void main(String[] args) {

		// n√£o s√£o fun√ß√µes de verdade, s√£o classes
		// que podem ser declaradas como se fossem
		// fun√ß√µes lambda, mas ainda √© preciso chamar
		// o m√©todo da classe para execut√°-las
		// no caso do exemplo, o m√©todo se chama call

		// declara√ß√£o simplificada
		Main.superior(() -&gt; System.out.println("lambda"));


		// declara√ß√£o simplificada
		Main.superior(x -&gt; x + 1);

		// declara√ß√£o completa
		Main.superior((int x) -&gt; {
			return x + 1;
		});

		// Main.superior(x, y -&gt; x + y);

	}

	@FunctionalInterface
	public interface Lambda {
		void call();
	}

	public static void superior(Lambda funcao) {
		funcao.call();
	}

	@FunctionalInterface
	public interface Lambda2 {
		int call(int x);
	}

	public static void superior(Lambda2 funcao) {
		System.out.println(funcao.call(1));
	}

}</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>function superior(funcao) {
	funcao();
}

// declara√ß√£o simplificada
superior(() =&gt; console.log('lambda'));

// declara√ß√£o antiga
superior(function() { /**/ });

function superior2(funcao) {
	console.log(funcao(1));
}

// declara√ß√£o simplificada
superior(x =&gt; x + 1);

// declara√ß√£o completa
superior((x) =&gt; {
	return x + 1;
});

// superior(x, y =&gt; x + y)</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>



<h3 id='funcoesinternas'>Fun√ß√µes Internas</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>void externa() {



	auto internaLambda = [](){ /**/ };

	// ou

	struct internaFunctor { // testar isso
		void operator()() { /**/ }
	};

	internaLambda();
	internaFunctor();

}</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// blocks em m√©todos
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>func externa() {

	func interna() { /**/ }

	// let internaLambda = {() in /**/ }

	interna()
	internaLambda();

}</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>fn externa() {

	fn interna() { /**/ }

	// let internaLambda = || { /**/ };

	interna();
	internaLambda();

}</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>public class Main {

	public static void Main(string[] args) {




		InternaDelegate interna = () =&gt; {
			System.Console.WriteLine(@"interna");
		};

		interna();

		Interna2Delegate interna2 = x =&gt; x + 1;

		var y = interna2(1);

		// ou

		Action interna = new Action(() =&gt; {
			System.Console.WriteLine(@"interna");
		})); // testar isso

		Func&lt;int&gt; interna2 = new Func&lt;int&gt;(x =&gt; x + 1);

		// C# 7 dever√° permitir fun√ß√µes locais tamb√©m

	}

	delegate void InternaDelegate();




	delegate int Interna2Delegate(int x);

}</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>public class Main {

	public static void main(String[] args) {

		// n√£o s√£o fun√ß√µes de verdade
		// ver lambdas acima para explica√ß√£o

		Funcional interna = () -&gt; {
			System.out.println("interna");
		};

		interna.call();

		Funcional2 interna2 = x -&gt; x + 1;

		int y = interna2.call(1);

	}

	@FunctionalInterface
	public interface Funcional {
		void call();
	}

	@FunctionalInterface
	public interface Funcional2 {
		int call(int x);
	}

}</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>function externa() {

	function interna() { /**/ }

	let internaLambda = () =&gt; { /**/ };

	interna();
	internaLambda();

}</code
>
</div>

</div>



<ol>
	<li>Swift / Rust / JavaScript</li>
	<li>C++</li>
	<li>C#</li>
	<li>Java</li>
	<li>Objective-C</li>
</ol>

<p>Swift, Rust e JavaScript permitem a criac√£o natural de fun√ß√µes dentro de fun√ß√µes.
<br />C++ requer o uso de um lambda, mas seu tipo pode ser deduzido pelo compilador.
<br />C# tamb√©m usa um lambda, mas seu tipo deve ser declarado por meio de um <code class='cs'>delegate</code>.
<br />Java n√£o possui fun√ß√µes internas de verdade. S√£o classes com uma sintaxe um pouco mais reduzida.
<br />Objective-C?</p>


<h3 id='closures'>Closures</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>#include &lt;iostream&gt;

int main(int argc, const char* argv[]) {

	using std::make_shared;
	using std::cout;
	using std::endl;

	auto facade = [](){
		// acess√≠vel somente pela fun√ß√£o interna
		auto i = make_shared&lt;int&gt;();
		auto interna = [i](){
			(*i)++;
			return *i;
		};
		// exp√µe a fun√ß√£o interna
		return interna;
	};

	auto closure = facade();
	cout &lt;&lt; closure() &lt;&lt; endl; // 1
	cout &lt;&lt; closure() &lt;&lt; endl; // 2

	return 0;

}</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char* argv[]) {

	// typedef ajuda na legibilidade
	typedef int (^interna_t)(void);
	typedef interna_t (^facade_t)(void);

	facade_t facade = ^{
		// acess√≠vel somente pela fun√ß√£o interna
		__block int i = 0;
		interna_t interna = ^{
			i++;
			return i;
		};
		// exp√µe a fun√ß√£o interna
		return interna;
	};

	interna_t closure = facade();
	NSLog(@"%i", closure()); // 1
	NSLog(@"%i", closure()); // 2

	return 0;

}</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>







func facade() -&gt; () -&gt; Int {
	// acess√≠vel somente pela fun√ß√£o interna
	var i = 0
	func interna() -&gt; Int {
		i = i + 1
		return i
	}
	// exp√µe a fun√ß√£o interna
	return interna
}

let closure = facade();
print(closure()); // 1
print(closure()); // 2</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>



public class MainClassClosure {

	delegate int InternaDelegate();




	static InternaDelegate Facade() {
		// acess√≠vel somente pela fun√ß√£o interna
		int i = 0;
		InternaDelegate interna = () =&gt; {
			i++;
			return i;
		};
		// exp√µe a fun√ß√£o interna
		return interna;
	}

	public static void Main(string[] args) {
		var closure = Facade();
		System.Console.WriteLine(closure()); // 1
		System.Console.WriteLine(closure()); // 2
	}

}</code
>
</div>

<div class='codeblock'>
<p>Java</p>

<code class='java multipart'
>class ClosureState {
	public int i;
}

public class MainClosure {

	@FunctionalInterface
	public interface Interna {
		int call();
	}

	static Interna facade() {
		// acess√≠vel somente pela "fun√ß√£o" interna
		final ClosureState closureState = new ClosureState();
		Interna interna = () -&gt; {
			closureState.i++;
			return closureState.i;
		};
		// exp√µe a "fun√ß√£o" interna
		return interna;
	}

	public static void main(String[] args) {
		Interna closure = facade();
		System.out.println(closure.call()); // 1
		System.out.println(closure.call()); // 2
	}

}</code
>

<code class='java'
><strong>// PS: pra evitar ter que declarar uma classe ClosureState</strong>
<strong class='small comment'>// eu poderia ter feito</strong>
final Object closureState = new Object() {
	public int i;
};

<strong>// mas a√≠ para ler as propriedades eu teria que usar</strong>
<strong class='small comment'>// reflection toda a vez</strong>
Class ClosureClass = closureState.getClass();

Field IField = ClosureClass.getDeclaredField("i")
IField.getInteger(closureState);</code
>

</div>

<!-- TODO testar captura de vari√°veis -->

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>





'use strict';

function facade() {
	// acess√≠vel somente pela fun√ß√£o interna
	let i = 0;
	let interna = () =&gt; {
		i++;
		return i;
	};
	// exp√µe a fun√ß√£o interna
	return interna;
}

let closure = facade();
console.log(closure()); // 1
console.log(closure()); // 2</code
>
</div>

</div>

<ol>
	<li>Swift / JavaScript</li>
	<li>Rust?</li>
	<li>C#</li>
	<li>C++</li>
	<li>Java</li>
	<li>Objective-C</li>
</ol>

<p>Swift e JavaScript s√£o os mais sucintos. √â verdade que √© necess√°rio saber da exist√™ncia de <em>closures</em> para n√£o criar uma sem querer, como muitos programadores JavaScript devem ter descoberto da pior maneira. Por√©m as novas regras de escopo, similares √†s das demais linguagens minimizam esse problema.
<br />Rust?
<br />Em compara√ß√£o com as linguagens anteriores, C# requer apenas a declara√ß√£o de um <code class='cs'>delegate</code> a mais.
<br />C++ por sua vez, requer cuidados no gerenciamento de mem√≥ria das vari√°veis acessadas pela closure com <code class='cpp'>make_shared</code>.
<br />Java complica um pouco o padr√£o, requerendo que as vari√°veis sejam membros de um objeto marcado como <code class='java'>final</code>.
<br />Objective-C possui uma sintaxe bastante dif√≠cil para identificar as closures, e o uso de <em>aliases</em> torna as assinaturas um pouco mais leg√≠veis. Tamb√©m √© necess√°rio identificar de maneira especial as vari√°veis que ser√£o usadas na closure com <code class='objectivec'>__block</code>.</p>

</section>



<section>

<h2 id='modulos'>M√≥dulos</h2>

<div class='comparison large'>

<div class='codeblock'>

	<div class='pair'>

		<div>

<p>C++ Microsoft - DentroDoModulo.hpp</p>
<code class='cpp'
>
#pragma once

namespace marcoluglio {
	class DentroDoModulo {};
}</code
>

		</div>

		<div>

<p>C++ - DentroDoModulo.cpp</p>
<code class='cpp'
>
#include "DentroDoModulo.hpp"

namespace marcoluglio {
	//
}</code
>

		</div>

	</div>

<p>C++ - main.cpp</p>
<code class='cpp'
>#include "DentroDoModulo.hpp"

int main(int argc, const char* argv[]) {
	using marcoluglio::DentroDoModulo;
	DentroDoModulo meuObjeto = DentroDoModulo();
}</code
>

</div>

<div class='codeblock'>

	<div class='pair'>

		<div>

<p>C++ - DentroDoModulo.hpp</p>
<code class='cpp'
>#ifndef MARCOLUGLIO_DENTRODOMODULO_HPP_INCLUDED
#define MARCOLUGLIO_DENTRODOMODULO_HPP_INCLUDED

namespace marcoluglio {
	class DentroDoModulo {};
}

#endif /* MARCOLUGLIO_DENTRODOMODULO_HPP_INCLUDED */</code
>

		</div>

		<div>

<p>C++ - DentroDoModulo.cpp</p>
<code class='cpp'
>
#include "DentroDoModulo.hpp"

namespace marcoluglio {
	//
}</code
>

		</div>

	</div>

<p>C++ - main.cpp</p>
<code class='cpp'
>#include "DentroDoModulo.hpp"

int main(int argc, const char* argv[]) {
	using marcoluglio::DentroDoModulo;
	DentroDoModulo meuObjeto = DentroDoModulo();
}</code
>

</div>

<div class='codeblock'>

	<div class='pair'>

		<div>

<p>Objective-C - MLGDentroDoModulo.h</p>
<code class='objectivec'
>
#import &lt;Foundation/Foundation.h&gt;

@interface MLGDentroDoModulo : NSObject
	//
@end

</code
>

		</div>

		<div>

<p>Objective-C - MLGDentroDoModulo.m</p>
<code class='objectivec'
>
#import "MLGDentroDoModulo.h"

@implementation MLGDentroDoModulo
	//
@end</code
>

		</div>

	</div>

<p>Objective-C - main.m</p>
<code class='objectivec'
>#import &lt;Foundation/Foundation.h&gt;
#import "MLGDentroDoModulo.h"

int main(int argc, const char* argv[]) {
	MLGDentroDoModulo* meuObjeto;
	meuObjeto = [[MLGDentroDoModulo alloc] init];
	return 0;

	// n√£o possui namespaces
	// a utiliza√ß√£o de prefixos com 3 letras
	// ou mais nas classes √© a alternativa
	// recomendada

}</code
>

</div>

<div class='codeblock'>
<p>Swift - DentroDoModulo.swift</p>
<code class='swift'
>// a cria√ß√£o de namespaces √© impl√≠cita
// para cada m√≥dulo

// um m√≥dulo √© um agrupamento macro, bem
// diferente do que se utiliza nas
// outras linguagens

// ele abrange um target inteiro de
// compila√ß√£o como um framework,
// uma biblioteca ou um execut√°vel

import UIKit

class DentroDoModulo: UIViewController {
}</code
>

<p>Swift - main.swift</p>
<code class='swift'
>let meuObjeto = DentroDoModulo()</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>mod
</code
>
<p>Rust</p>
<code class='rust'
>use
</code
>
</div>

<div class='codeblock'>
<p>C# - DentroDoModulo.cs</p>
<code class='cs'
>namespace marcoluglio {
	public class DentroDoModulo { /**/ }
}</code
>
<p>C# - main.cs</p>
<code class='cs'
>using marcoluglio;

class MainClass {
	public static void Main(string[] args) {
		DentroDoModulo meuObjeto;
		meuObjeto = new DentroDoModulo();
	}
}</code
>
</div>

<div class='codeblock'>
<p>Java - marcoluglio/DentroDoModulo.java</p>
<code class='java'
>package marcoluglio;

public class DentroDoModulo { /**/ }</code
>
<p>Java - main.java</p>
<code class='java'
>import marcoluglio.DentroDoModulo;

public class OlaMundo {
	public static void main(String[] args) {
		DentroDoModulo meuObjeto;
		meuObjeto = new DentroDoModulo();
	}
}</code
>
</div>

<div class='codeblock'>
<p>JavaScript compatibilidade</p>
<code class='javascript'
>'use strict';

define('dentroDoModulo', () =&gt; {
	const DentroDoModulo = class DentroDoModulo() { /**/ }
	return DentroDoModulo;
});

define(['dentroDoModulo'], (DentroDoModulo) =&gt; {
	let meuObjeto = new DentroDoModulo();
});
</code
>
</div>

<div class='codeblock'>
<p>JavaScript - DentroDoModulo.js</p>
<code class='javascript'
>'use strict';

export default class DentroDoModulo { /**/ }</code
>

<p>JavaScript - main.js</p>
<code class='javascript'
>'use strict';

import DentroDoModulo from 'DentroDoModulo';

let meuObjeto = new DentroDoModulo();</code
>
</div>

</div>

<ol>
	<li>C# / Java</li>
	<li>JavaScript</li>
	<li>Rust</li>
	<li>C++</li>
	<li>Swift</li>
	<li>Objective-C</li>
</ol>

<p>C# e Java possuem maior granularidade. A √∫nica diferen√ßa entre os dois √© que o m√≥dulo em Java deve ser replicado na estrutura de pastas dos arquivos que cont√©m as classes, ao passo que em C# n√£o. Se voc√™ j√° teve que cavar dentro de mil pastas por classes Java sabe que isso acaba mais atrapalhando do que ajudando. Por√©m, deve haver certamente quem diga que a liberdade que C# proporciona nesse quesito pode ser mal utilizada e gerar confus√£o.
<br />JavaScript at√© a vers√£o ES6, n√£o possu√≠a nenhuma sintaxe especial para definir m√≥dulos. Mesmo ap√≥s a oficializa√ß√£o da especifica√ß√£o, nenhum navegador a implementou at√© o momento. O que vemos no exemplo √© um padr√£o denominado <abbr title='Asynchronous Module Definition'>AMD</abbr> que √© bastante flex√≠vel, por√©m um pouco redundante e propenso a erros.
<br />Rust?
<br />C++ possui passos manuais na defini√ß√£o de m√≥dulos. A sintaxe para aninhar <em>namespaces</em> s√≥ ser√° melhorada na pr√≥xima especifica√ß√£o (c++1z). Oficialmente a forma de garantir que um m√≥dulo n√£o seja importado mais de uma vez, e por consequ√™ncia sobrescrito, √© usar os <em>include guards</em> <code class='cpp'>#ifndef</code>, <code class='cpp'>#define</code> e <code class='cpp'>#endif</code>. A diretiva mais amig√°vel <code class='cpp'>#pragma once</code> n√£o √© oficial, embora a maioria dos compiladores reconhe√ßa devido √† sua popularidade.
<br />Swift tem uma defini√ß√£o t√£o abrangente de m√≥dulos que quase n√£o se pode dizer que ele tenha uma.
<br />Objective-C herda de C?</p>

</section>



<section>

<h2 id='excecoes'>Exce√ß√µes</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp multipart'
>#include &lt;exception&gt;

using std::exception;

try {
	throw anyType;
	// ou simplesmente
	throw;
} catch (const exception&amp; ex) {
	//
} catch (...) {
	//
}</code
>

<code class='cpp'
><strong>// N√ÉO COPIE!!! DEPRECATED!!!</strong>

// havia uma sintaxe para "checked exceptions"
int myfunction(int param) throw();
int myfunction(int param) throw(someType);</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>- (void) someMethod {
	@try {
		//
	} @catch (NSException *exception) {
		@throw exception; //  rethrows exception?
	} @finally {
		//
	}
}

// ou

someCFunction(); // TODO</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>enum MLError : ErrorType {
	case Bad
	case Worse
}

func canThrowErrors() throws -&gt; String {
	throw MLError.Bad
}

func cannotThrowErrors() -&gt; String {
	//
}

defer {
	//
}

// usar do-catch, try?, try! ou indicar throws</code
>
<!-- https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html -->
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>match may_panic() {
	Ok(result) =&gt; println!("{}", result),
	Err(err) =&gt; println!("Error: {}", err),
}

// ou

let result = try!(may_panic());</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>try {

	someObject.mayThrowException();

} catch (Exception ex) {

	// rethrows exception
	throw;

	// ou throw nova exce√ß√£o com InnerException
	// n√£o devemos lan√ßar System.Exception diretamente
	throw new ArgumentException("Novo erro", ex);

} finally {
	//
}

try {
	//
} catch {
	//
}

try {
	//
} finally {
	//
}</code
>
</div>

<div class='codeblock'>

<p>Java - Main.java</p>
<code class='java'
>public class Main {

	<strong>// Indicamos que n√£o queremos cuidar da checked exception</strong>
	<strong class='small comment'>// neste ponto do c√≥digo com "throws" e deixamos o erro</strong>
	<strong class='small comment'>// se propagar</strong>
	public static void main(String[] args) <strong class='small'>throws Exception</strong> {
		PodeOuNao problematico = new PodeOuNao();
		<strong>problematico.checkedMethod();</strong>
		problematico.uncheckedMethod();
	}

}</code
>

<p>Java - Main.java</p>
<code class='java'
>public class Main {

	public static void main(String[] args) {
		PodeOuNao problematico = new PodeOuNao();
		<strong>// Contemos a propaga√ß√£o da checked exception</strong>
		<strong class='small comment'>// com try catch</strong>
		<strong class='small'>try {</strong>
			<strong>problematico.checkedMethod();</strong>
		<strong class='small'>} catch (Exception ex) {</strong>
			//
		<strong>} finally {</strong>
			//
		<strong>}</strong>
		problematico.uncheckedMethod();
	}

}</code
>

<p>Java - Main.java</p>
<code class='java'
>public class Main {

	public static void main(String[] args) {
		PodeOuNao problematico = new PodeOuNao();
		try {
			problematico.uncheckedMethod();
		} catch (Exception ex) {
			// throw nova exce√ß√£o com cause
			throw new RuntimeException(ex);
		} finally {
			//
		}
	}

}</code
>

<p>Java - PodeOuNao.java</p>
<code class='java'
>package marcoluglio.exceptionexample;

public final class PodeOuNao {

	// checked exceptions devem ser cercadas por
	// try catch ou o m√©todo deve indicar explicitamente
	// que pode lan√ß√°-las com "throws"
	public void checkedMethod() throws Exception {
		throw new Exception("pego na compila√ß√£o!");
	}

	// unchecked exceptions n√£o precisam de tais
	// cuidados
	public void uncheckedMethod() {
		throw new RuntimeException("pego na execu√ß√£o!");
	}

}</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>try {
	throw anyType;
	// mas geralmente
	throw new Error('Whoops!');
} catch (e if e instanceof Error) {
	//
} catch (ex) {
	throw ex; // rethrows
} finally {
	//
}

// TODO pode nested

try {
	// sem catch
} finally {
	//
}</code
>
<!-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch -->
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
>Private Sub CapturaDeErro()

	' Visual Basic n√£o possui try catch
	' Usamos labels para tratar erros
	On Error GoTo Erro

	' Fa√ßa alguma coisa e saia da fun√ß√£o
	' antes de chegar nas linhas de tratamento de erro
	Exit Sub

' Label de erro
' Labels n√£o podem conter espa√ßos em branco antes dos nomes
Erro:
	' Fa√ßa alguma coisa e saia da fun√ß√£o
	Exit Sub

	' Ou continue a execu√ß√£o normalmente
	Resume Next

	' Ou passe para um tratamento espec√≠fico
	If Err.Number = 13 Then
		Resume ErroEspecifico

ErroEspecifico:
	Exit Sub

End Sub</code>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='async'>Async</h2>

<!-- tasks, promises e futures, deferreds, generators, events/delegates -->


<h3 id='generators'>Generators</h3>

<h4>Yield</h4>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
-
</div>

<div class='codeblock'>
<p>Objective-C</p>
-
</div>

<div class='codeblock'>
<p>Swift</p>
-
</div>

<div class='codeblock'>
<p>Rust</p>
-
</div>

<div class='codeblock'>

<p>C# - AnimadorGenerator.cs</p>
<code class='cs'
>using System.Collections.Generic;

namespace MarcoLuglio.ClosureGeneratorExample {

	public class AnimadorGenerator {

		// os par√¢metros n√£o podem ser ref nem out
		public IEnumerable&lt;float&gt; Animar(float inicio, float fim, int tempo) {

			var tempoAtual = 1;
			var delta = (fim - inicio) / tempo;
			var passo = 0f;

			while (tempoAtual &lt;= tempo) {
				try {
					passo = fim - (delta * (tempo - tempoAtual));
					tempoAtual += 1;
					yield return passo;
				} finally {
					// n√£o posso usar catch com generators
				}
			}

			// tamb√©m posso usar yield break; se quiser interromper

		}

	}

}</code
>

<p>C# - MainClass.cs</p>
<code class='cs'
>using System;

namespace MarcoLuglio.ClosureGeneratorExample {

	public class MainClass {

		public static void Main(string[] args) {

			var animadorGenerator = new AnimadorGenerator();

			var animadorIterator = animadorGenerator.Animar(0, 100, 9);
			foreach (var resultado in animadorIterator) {
				Console.WriteLine(resultado);
			}

			// ou

			var animadorIterator = animadorGenerator.Animar(0, 100, 9).GetEnumerator();
			while (animadorIterator.MoveNext()) {
				var resultado = animadorIterator.Current;
				Console.WriteLine(resultado);
			}

		}

	}

}</code
>

</div>

<div class='codeblock'>
<p>Java</p>
-
</div>

<div class='codeblock'>

<p>JavaScript - animar.js</p>
<code class='javascript'
>'use strict';






function* animar(inicio, fim, tempo) {

	var tempoAtual = 1;
	var delta = (fim - inicio) / tempo;
	var passo = 0f;

	while (tempoAtual &lt;= tempo) {
		try {
			passo = fim - (delta * (tempo - tempoAtual));
			tempoAtual += 1;
			yield passo;
		} catch (ex) {
			//
		}
	}

}






</code
>

<p>JavaScript - main.js</p>
<code class='javascript'
>'use strict';







let animadorIterador = animar(0, 100, 9);

for (let resultado of animadorIterator) {
	console.log(resultado.value);
}

// ou

do {
	let resultado = animadorIterador.next();
	if (resultado.value || resultado.value === 0) {
		console.log(resultado.value);
	}
} while (!resultado.done)</code
>

</div>

</div>



<h4>Closures</h4>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>

<p>C# - AnimadorClosure.cs</p>
<code class='cs'
>namespace MarcoLuglio.GeneratorExample {

	// assinatura da closure
	public delegate float? Next();







	public class AnimadorClosure {

		public static Next Animar(float inicio, float fim, int tempo) {

			// vari√°veis capturadas na closure
			var tempoAtual = 1;
			var delta = (fim - inicio) / tempo;
			var passo = 0f;


			// closure
			Next lambda = () =&gt; {
				if (tempoAtual &lt;= tempo) {
					passo = fim - (delta * (tempo - tempoAtual));
					tempoAtual += 1;
					return passo;
				}
				return null;
			};

			return lambda;

		}

	}

}</code
>

<p>C# - MainClass.cs</p>
<code class='cs'
>using System;

namespace MarcoLuglio.GeneratorExample {

	class MainClass {

		public static void Main(string[] args) {

			var animadorClosure = AnimadorClosure.Animar(0, 100, 9);
			float? resultado;

			do {
				resultado = animadorClosure();
				Console.WriteLine(resultado);
			} while (resultado != null);

		}

	}

}</code
>

</div>

<div class='codeblock'>

<p>Java - AnimadorClosure.java</p>
<code class='java'
>package marcoluglio.generatorexample;

// as assinaturas poss√≠veis das closures est√£o nesse pacote
import java.util.function.*;

class ClosureState {
	public int tempoAtual;
	public float delta;
	public Float passo;
}

public class AnimadorClosure {

	public static Supplier&lt;Float&gt; animar(float inicio, float fim, int tempo) {

		// vari√°veis capturadas na closure
		final ClosureState closureState = new ClosureState();
		closureState.tempoAtual = 1;
		closureState.delta = (fim - inicio) / tempo;
		closureState.passo = 0;

		// closure
		Supplier&lt;Float&gt; lambda = () -&gt; {
			if (closureState.tempoAtual &lt;= tempo) {
				closureState.passo = fim - (closureState.delta * (tempo - closureState.tempoAtual));
				closureState.tempoAtual += 1;
				return closureState.passo;
			}
			return null;
		};

		return lambda;

	}

}


</code
>

<p>Java - Main.java</p>
<code class='java multipart'
>
import java.util.function.*;
import marcoluglio.generatorexample.AnimadorClosure;

public class Main {

	public static void main(String[] args) {

		Supplier&lt;Float&gt; animadorClosure = AnimadorClosure.animar(0, 100, 9);
		Float resultado;

		do {
			resultado = animadorClosure.get();
			System.out.println(resultado);
		} while (resultado != null);

	}

}</code
>

<code class='java'
><strong>// PS: pra evitar ter que declarar uma classe ClosureState, eu poderia ter feito</strong>
final Object closureState = new Object() {
	public int tempoAtual;
	public float delta;
	public Float passo;
};

<strong>// mas a√≠ para ler as propriedades eu teria que usar reflection toda a vez</strong>
Class ClosureClass = closureState.getClass();

Field TempoAtualField = ClosureClass.getDeclaredField("tempoAtual")
TempoAtualField.getInteger(closureState);

Field DeltaField = ClosureClass.getDeclaredField("delta")
DeltaField.getFloat(closureState);

Field PassoField = ClosureClass.getDeclaredField("passo")
PassoField.getFloat(closureState);</code
>

</div>

<div class='codeblock'>

<p>JavaScript - animarClosure.js</p>
<code class='javascript'
>'use strict';












animar(inicio, fim, tempo) {

	// vari√°veis capturadas na closure
	let tempoAtual = 1;
	let delta = (fim - inicio) / tempo;
	let passo = 0;


	// closure
	let lambda = () =&gt; {
		if (tempoAtual &lt;= tempo) {
			passo = fim - (delta * (tempo - tempoAtual));
			tempoAtual += 1;
			return passo;
		}
		return;
	};

	return lambda;

}




</code
>

<p>JavaScript - main.js</p>
<code class='javascript'
>







let animadorClosure = animar(0, 100, 9);
let resultado;

do {
	resultado = animadorClosure();
	console.log(resultado);
} while (resultado || resultado === 0);</code
>

</div>

</div>



<h4>Functors</h4>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>

<p>C#</p>
-
</div>

<div class='codeblock'>
<p>Java</p>
-
</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

</div>



<h4>Classes</h4>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>

<p>C# - AnimadorIterator.cs</p>
<code class='cs'
>using System.Collections.Generic;

namespace MarcoLuglio.GeneratorExample {

	public class AnimadorIterator : IEnumerable&lt;float&gt;, IEnumerator&lt;float&gt; {

		public AnimadorIterator(float inicio, float fim, int tempo) {
			this.fim = fim;
			this.tempo = tempo;
			this.delta = (fim - inicio) / tempo;
			this.Reset();
		}

		#region interface IEnumerable

		public IEnumerator&lt;float&gt; GetEnumerator() { // implementa√ß√£o impl√≠cita
			return this;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
			return this;  // implementa√ß√£o expl√≠cita --^
		}

		#endregion

		#region interface IEnumerator

		public bool MoveNext() { // implementa√ß√£o impl√≠cita

			if (this.tempoAtual &lt;= this.tempo) {
				this.passo = this.fim - (this.delta * (this.tempo - this.tempoAtual));
				this.tempoAtual += 1;
				return true;
			}

			return false;

		}

		public float Current { // implementa√ß√£o impl√≠cita
			get { return this.passo; }
		}

		object System.Collections.IEnumerator.Current { // implementa√ß√£o expl√≠cita
			get { return this.passo; }
		}

		public void Reset() { // implementa√ß√£o impl√≠cita
			this.tempoAtual = 1;
			this.passo = 0;
		}

		public void Dispose() { /**/ } // implementa√ß√£o impl√≠cita

		#endregion

		private readonly int tempo;
		private int tempoAtual;
		private readonly float fim;
		private readonly float delta;
		private float passo;

	}

}</code
>

<p>C# - MainClass.cs</p>
<code class='cs'
>using System;

namespace MarcoLuglio.GeneratorExample {

	class MainClass {

		public static void Main(string[] args) {

			var animadorIterator = new AnimadorIterator(0, 100, 9);

			foreach (var resultado in animadorIterator) {
				Console.WriteLine(resultado);
			}

		}

	}

}</code
>

</div>

<div class='codeblock'>

<p>Java - AnimadorIterator.java</p>
<code class='java'
>package marcoluglio.generatorexample;

import java.util.Iterator;

public class AnimadorIterator implements Iterable&lt;Float&gt;, Iterator&lt;Float&gt; {

	public AnimadorIterator(float inicio, float fim, int tempo) {
		this.fim = fim;
		this.tempo = tempo;
		this.delta = (fim - inicio) / tempo;
		this.reset();
	}

	// region Interface Iterable&lt;T&gt;

	@Override // "implementa√ß√£o expl√≠cita"
	public Iterator&lt;Float&gt; iterator() {
		return this;
	}

	// endregion




	// region Interface Iterator&lt;T&gt;

	@Override // "implementa√ß√£o expl√≠cita"
	public boolean hasNext() {
		if (this.tempoAtual &lt;= this.tempo) {
			return true;
		}
		return false;
	}

	@Override // "implementa√ß√£o expl√≠cita"
	public Float next() {
		this.passo = this.fim - (this.delta * (this.tempo - this.tempoAtual));
		this.tempoAtual += 1;
		return this.passo;
	}

	// endregion




	private void reset() {
		this.tempoAtual = 1;
		this.passo = 0;
	}





	private final int tempo;
	private int tempoAtual;
	private final float fim;
	private final float delta;
	private float passo;

}</code
>

<p>Java - Main.java</p>
<code class='java'
>

import marcoluglio.generatorexample.AnimadorIterator;

public class Main {

	public static void main(String[] args) {

		AnimadorIterator animadorIterador = new AnimadorIterator(0, 100, 9);

		for (float resultado : animadorIterador) {
			System.out.println(resultado);
		}

	}

}</code
>

</div>

<div class='codeblock'>

<p>JavaScript - Iterator.js</p>
<code class='javascript'
>class AnimadorIterator {

	constructor(inicio, fim, tempo) {
		Object.defineProperties(this, {
			_fim: {value: fim},
			_tempo: {value: tempo},
			_tempoAtual: {value: tempo, writable: true},
			_delta: {value: (fim - inicio / tempo)},
			_passo: {value: 0, writable: true}
		});
		Object.seal(this);
		this.reset();
	}

	reset() {
		this._tempoAtual = 1;
		this._passo = 0;
	}

	// iterador for of
	*[Symbol.iterator]() {
		if (this._tempoAtual &lt;= this.tempo) {
			this._passo = this._fim - (this._delta * (this._tempo - this._tempoAtual));
			this._tempoAtual += 1;
			yield this._passo;
		}
	}

}


































</code
>

<p>JavaScript - main.js</p>
<code class='javascript'
>







let animadorIterator = new AnimadorIterator(0, 100, 9);

for (let resultado of animadorIterator) {
	console.log(resultado);
}</code
>

</div>

</div>



<ol>
	<li>a</li>
</ol>

<p>A</p>



<h3 id='tasks'>Tasks</h3>

<div class='comparison'>

<div class='codeblock'>

<p>C++ - main.cpp</p>
<code class='cpp'
>#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;boost/algorithm/string.hpp&gt;

#include "taskFunction.hpp"

int main(int argc, const char* argv[]) {

	using std::async;
	using std::string;
	using std::cout;
	using std::endl;

	using MarcoLuglio::TaskExample::taskFunction;

	// alternativa 1: m√©todo
	// TODO

	// alternativa 2: fun√ß√£o
	auto functionFuture = async(taskFunction, "fun√ß√£o");

	// alternativa 3: lambda
	auto lambdaFuture = async([](string element) -&gt; string {
		boost::to_upper(element);
		return element;
	}, "lambda");


	// espera os Futures calcularem um valor
	// concreto antes de prosseguir
	cout &lt;&lt; functionFuture.get() &lt;&lt; endl;
	cout &lt;&lt; lambdaFuture.get() &lt;&lt; endl;

	return 0;

}</code
>

	<div class='pair'>

		<div>

<p>C++ - taskFunction.hpp</p>
<code class='cpp'
>#pragma once

#include &lt;string&gt;

namespace MarcoLuglio {
namespace TaskExample {

	using std::string;

	string taskFunction(string element);

}
}</code
>

		</div>

		<div>

<p>C++ - taskFunction.cpp</p>
<code class='cpp'
>#include &lt;boost/algorithm/string.hpp&gt;
#include "taskFunction.hpp"


namespace MarcoLuglio {
namespace TaskExample {

	using std::string;

	string taskFunction(string element) {
		boost::to_upper(element);
		return element;
	}

}
}</code
>

		</div>

	</div>

</div>

<div class='codeblock'>
<p>Objective-C</p>
-
</div>

<div class='codeblock'>

<p>Swift - Console</p>
<code class='swift'
>// libdispatch ou Grande Central Dispatch
import Dispatch

// fun√ß√µes auxiliares para simplificar sincroniza√ß√£o

func check(semaforo:dispatch_semaphore_t) -&gt; Int {
	let waitResult = dispatch_semaphore_wait(
		semaforo,
		dispatch_time(DISPATCH_TIME_NOW, 1_000_000_000)
	)
	return waitResult
}

func wait(semaforo:dispatch_semaphore_t) {
	while check(semaforo) != 0 { /**/ }
}

// tasks

var element = "lambda"

let utilityQueue = dispatch_get_global_queue(
	QOS_CLASS_UTILITY,
	0
)
let semaforo = dispatch_semaphore_create(0)

dispatch_async(utilityQueue) {
	element = element.uppercaseString
	print(element)
	dispatch_semaphore_signal(semaforo)
}

// espera os blocos terminarem antes de prosseguir
wait(semaforo)

/*
Os tipos pr√©-definidos de queues s√£o:
QOS_CLASS_USER_INTERACTIVE - if it should not cause the ui to lag or hang
QOS_CLASS_USER_INITIATED - if is started by ui interaction such as a click
QOS_CLASS_UTILITY - if it is a slow operation such as io
QOS_CLASS_BACKGROUND - background tasks
*/</code
>

<p>Swift - UI</p>
<code class='swift'>// libdispatch ou Grande Central Dispatch
import Dispatch

// fun√ß√µes auxiliares para simplificar sincroniza√ß√£o

func check(semaforo:dispatch_semaphore_t) -&gt; Int {
	let waitResult = dispatch_semaphore_wait(
		semaforo,
		dispatch_time(DISPATCH_TIME_NOW, 1_000_000_000)
	)
	return waitResult
}

func wait(semaforo:dispatch_semaphore_t) {
	while check(semaforo) != 0 { /**/ }
}

// tasks

var element = "lambda"

let utilityQueue = dispatch_get_global_queue(
	QOS_CLASS_UTILITY,
	0
)
let semaforo = dispatch_semaphore_create(0)

dispatch_async(utilityQueue) {
	element = element.uppercaseString
	let mainQueue = dispatch_get_main_queue()
	dispatch_async(mainQueue) {
		print(element)
		dispatch_semaphore_signal(semaforo)
	}
}

// espera os blocos terminarem antes de prosseguir
wait(semaforo)</code
>

</div>

<div class='codeblock'>
<p>Rust</p>
-
</div>

<div class='codeblock'>

<p>C# - MainClass.cs</p>
<code class='cs'
>using System;

namespace MarcoLuglio.TaskExample {

	class MainClass {

		public static void Main(string[] args) {
			// async n√£o pode ser usado no m√©todo
			// main, ent√£o chamamos no objeto
			var mainObject = new MainClass();
			mainObject.main();
		}

		private async void main() {
			var promise = new Promise(@"some value");
			var resultado = await promise.GetResultAsync();
			Console.WriteLine(@"esperou " + resultado);
		}

	}

}</code
>

<p>C# - Promise.cs</p>
<code class='cs'
>using System.Threading.Tasks;

namespace MarcoLuglio.TaskExample {

	public class Promise {

		public Promise(string element) {
			this.element = element;
		}

		public async Task&lt;string&gt; GetResultAsync() {
			return this.element.ToUpper();
		}

		string element;

	}

}</code
>

</div>

<div class='codeblock'>

<p>Java - Main.java</p>
<code class='java'
>

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;

public class Main {

	public static void main(String[] args) {

		// gerencia threads
		ExecutorService executor = Executors.newFixedThreadPool(2);

		// alternativa 1: interface Callable
		Task callableTask = new Task("async");
		Future&lt;String&gt; taskFuture = executor.submit(callableTask);

		// alternativa 2: lambda Callable
		String element = "lambda";
		Future&lt;String&gt; lambdaFuture = executor.submit(() -&gt; {
			return element.toUpperCase();
		});

		// alternativa 3: Threads e Futures manuais sem executor
		Task manualTask = new Task("manual");
		FutureTask&lt;String&gt; manualFuture = new FutureTask&lt;String&gt;(manualTask);
		new Thread(manualFuture).start();

		try {

			// espera os Futures calcularem um valor
			// concreto antes de prosseguir
			System.out.println(taskFuture.get());
			System.out.println(lambdaFuture.get());
			System.out.println(manualFuture.get());

			// encerra as threads do executor
			executor.shutdown();

		} catch (InterruptedException e) {
			// fazer alguma coisa
		} catch (ExecutionException e) {
			// fazer alguma coisa
		}

	}

}</code
>

<p>Java - Task.java</p>
<code class='java'
>package marcoluglio.taskexample;

import java.util.concurrent.Callable;

public class Task implements Callable&lt;String&gt; {

	public Task(String element) {
		this.element = element;
	}

	@Override
	public String call() throws Exception {
		return this.element.toUpperCase();
	}

	String element;

}</code
>

</div>

<div class='codeblock'>

<p>Java Android - AsyncTask.java</p>
<code class='java'
>// TODO AsyncTask</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>function workAsync(element) {
	return new Promise((resolve, reject) =&gt; {
		resolve(element.toUpperCase());
	});
}

workAsync('some value')
	.then((result) =&gt; {
		console.log(result);
	});</code
>
</div>

</div>



<ol>
	<li>a</li>
</ol>

<p>A</p>



<h3 id='threads'>Threads</h3>

<div class='comparison'>

<div class='codeblock'>

<p>C++ - main.cpp</p>
<code class='cpp'
>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;boost/algorithm/string.hpp&gt;
#include "cout_mutex.hpp" // para simplicidade do exemplo
#include "Model.hpp"
#include "ParallelWorker.hpp"
#include "parallelWorkerFunction.hpp"

int main(int argc, const char* argv[]) {

	using std::string;
	using std::cout;
	using std::endl;

	using std::make_unique;
	using std::thread;
	using std::ref;

	using MarcoLuglio::ThreadExample::Model;
	using MarcoLuglio::ThreadExample::ParallelWorker;
	using MarcoLuglio::ThreadExample::parallelWorkerFunction;

	// mem√≥ria compartilhada entre as threads
	// como as threads n√£o viver√£o mais que
	// a main thread, posso usar unique_ptr
	auto dataQueue = make_unique&lt;Model&gt;();
	dataQueue.Push("dislexicos");
	dataQueue.Push("devem");
	dataQueue.Push("ler");
	dataQueue.Push("frases");
	dataQueue.Push("assim");

	// alternativa 1: m√©todo
	auto worker{ParallelWorker(*dataQueue)};
	thread parallelThread{&amp;ParallelWorker::Work, worker};

	// alternativa 2: fun√ß√£o
	thread functionThread{parallelWorkerFunction, ref(*dataQueue)};

	// alternativa 3: lambda
	thread lambdaThread{[](Model&amp; dataQueue){
		string element;
		auto sair = false;
		while (!sair) {
			element = dataQueue.Next();
			// deixa a thread terminar naturalmente
			if (element == "") {
				sair = true;
				continue;
			}
			boost::to_upper(element);
			cout_mutex.lock();
			cout &lt;&lt; element &lt;&lt; endl;
			cout_mutex.unlock();
		}
	}, ref(*dataQueue)};

	// espera as threads terminarem antes de prosseguir
	parallelThread.join();
	functionThread.join();
	lambdaThread.join();

}</code
>

<code class='cpp'
><strong>// TODO verificar isso tudo</strong>
<strong>// PS: unique_ptr devolve um ponteiro n√£o copi√°vel quando desreferenciado</strong>
auto dataQueue = make_unique&lt;Model&gt;();
auto copia = *dataQueue; // erro: n√£o copi√°vel
<strong>// por isso precisamos passar para as threads, um ponteiro do ponteiro</strong>
<strong class='comment small'>// ou uma refer√™ncia do ponteiro</strong>
auto referenciaDoPonteiro*&amp; = ref(dataQueue);
<strong>// ou ainda, uma refer√™ncia copi√°vel do valor apontado</strong>
auto referencia&amp; = ref(*dataQueue);</code
>


	<div class='pair'>

		<div>

		<p>C++ - Model.hpp</p>
<code class='cpp'
>#pragma once

#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;

namespace MarcoLuglio {
namespace ThreadExample {

	using std::string;
	using std::queue;
	using std::mutex;

	// C++ possui classes nativas com acesso
	// sincronizado, mas n√£o as utilizei para
	// demonstrar o uso de locks manuais
	class Model final {

	public:
		Model();
		~Model();
		void Push(string);
		string Next();

	private:

		queue&lt;string&gt; dataQueue;

		/// Lock simples expl√≠cita para sincroniza√ß√£o
		mutex modelLock;

	};

}
}</code
>

		</div>

		<div>

<p>C++ - Model.cpp</p>
<code class='cpp'
>#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;
#include "Model.hpp"

namespace MarcoLuglio {
namespace ThreadExample {

	using std::string;
	using std::queue;
	using std::lock_guard;
	using std::mutex;

	Model::Model() {
		dataQueue = queue&lt;string&gt;();
	};

	Model::~Model() {
		//
	};

	void Model::Push(string) {
		// s√≥ a main thread insere, ent√£o
		// n√£o precisa sincronizar
		dataQueue.push(element);
	};

	string Model::Next() {
		// sincroniza o acesso das threads
		lock_guard&lt;mutex&gt; _{modelLock};
		if (!dataQueue.empty()) {
			string element = dataQueue.front();
			dataQueue.pop();
			return element;
		}
		// string n√£o pode ser nullptr em c++
		return "";
	};

}
}</code
>

		</div>

	</div>

	<div class='pair'>

		<div>

<p>C++ - ParallelWorker.hpp</p>
<code class='cpp'
>#pragma once

namespace MarcoLuglio {
namespace ThreadExample {

	class Model;

	class ParallelWorker final {

	public:
		explicit ParallelWorker(Model&amp; model);
		~ParallelWorker();
		void Work();

	private:
		Model* dataQueue;
		std::string element;

		/// Flag para t√©rmino da thread
		bool sair;

	};

}
}</code
>

		</div>

		<div>

<p>C++ - ParallelWorker.cpp</p>
<code class='cpp'
>#include &lt;iostream&gt;
#include &lt;boost/algorithm/string.hpp&gt;
#include "cout_mutex.hpp" // para simplicidade do exemplo
#include "Model.hpp"
#include "ParallelWorker.hpp"

namespace MarcoLuglio {
namespace ThreadExample {

	using std::cout;
	using std::endl;

	ParallelWorker::ParallelWorker(Model&amp; model) {
		dataQueue = &amp;model;
		sair = false;
	};

	ParallelWorker::~ParallelWorker() {
		//
	};

	void ParallelWorker::Work() {
		while (!sair) {
			element = dataQueue-&gt;Next();
			// deixa a thread terminar naturalmente
			if (element == "") {
				sair = true;
				continue;
			}
			boost::to_upper(element);
			cout_mutex.lock();
			cout &lt;&lt; element &lt;&lt; endl;
			cout_mutex.unlock();
		}
	};

}
}</code
>

		</div>

	</div>

	<div class='pair'>

		<div>

<p>C++ - parallelWorkerFunction.hpp</p>
<code class='cpp'
>#pragma once

namespace MarcoLuglio {
namespace ThreadExample {

	class Model;

	void parallelWorkerFunction(Model&amp; dataQueue);

}
}</code
>

		</div>

		<div>

<p>C++ - parallelWorkerFunction.cpp</p>
<code class='cpp'
>#include &lt;iostream&gt;
#include &lt;boost/algorithm/string.hpp&gt;
#include "cout_mutex.hpp" // para simplicidade do exemplo
#include "Model.hpp"
#include "parallelWorkerFunction.hpp"

namespace MarcoLuglio {
namespace ThreadExample {

	using std::string;
	using std::cout;
	using std::endl;

	void parallelWorkerFunction(Model&amp; dataQueue) {
		string element;
		auto sair = false;
		while (!sair) {
			element = dataQueue.Next();
			// deixa a thread terminar naturalmente
			if (element == "") {
				sair = true;
				continue;
			}
			boost::to_upper(element);
			cout_mutex.lock();
			cout &lt;&lt; element &lt;&lt; endl;
			cout_mutex.unlock();
		}
	}

}
}</code
>

		</div>

	</div>

</div>

<div class='codeblock'>
<p>Objective-C</p>
<!--
http://www.cs.umd.edu/class/spring2010/cmsc498i/files/lectures/21_PerfConcurrency.pdf

https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html
https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html
https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html

https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man3/pthread.3.html
-->
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>

<p>Swift - Cocoa threads</p>
<code class='swift'>import Foundation

func join(thread:NSThread) {
	while !thread.finished { /**/ }
}

public final class NSParallelWorker {

	@objc public func work() {
		// deixa a thread terminar naturalmente
		while !self.sair {
			print("parallel worker")
			self.sair = true
		}
	}

	private var sair:Bool = false

}

// foundation thread com m√©todos
let nsParallelWorker = NSParallelWorker()
let selector = #selector(NSParallelWorker.work)
let nsThread:NSThread = NSThread.init(
	target: nsParallelWorker,
	selector: selector,
	object: nil
	)
nsThread.start()

// espera as threads terminarem antes de prosseguir
join(nsThread)</code
>

<p>Swift - POSIX threads</p>
<code class='swift'>//int threadError = pthread_create(
//	&amp;posixThreadID,
//	&amp;attr,
//	&amp;PosixThreadMainRoutine,
//	NULL
//	);

let pThread:pthread_t;
let pThreadAttr:pthread_attr_t;
pthread_attr_init(UnsafeMutablePointer&lt;pthread_attr_t&gt;(pThreadAttr))
let threadError = pthread_create(
	UnsafeMutablePointer&lt;pthread_t&gt;(pThread),
	UnsafePointer&lt;pthread_attr_t&gt;(pThreadAttr),
	{(UnsafeMutablePointer&lt;Void&gt;) -&gt; UnsafeMutablePointer&lt;Void&gt; in
		//code
	}, nil)
// let modelLock:pthread_mutex_t =
// pthread_join(
//	pThread,
//	UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Void&gt;&gt;
//	);</code
>
<!--
usar sem√°foros para controlar acesso √† cole√ß√£o
dispatch tasks para uma √∫nica queue
usar uma queue que n√£o modifica a cole√ß√£o at√© processar tudo


dispatch_group_t myGroup = dispatch_group_create();
dispatch_group_async(myGroup, dispatch_get_global_queue(), ^{
	//stuff to do in the background
});

//do some stuff

dispatch_group_wait(myGroup, DISPATCH_TIME_FOREVER);
dispatch_release(myGroup);

NSTask executa um novo processo
override NSOperation :(

-->

</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// queue
use std::collections::vec_deque::VecDeque;

// threads
use std::thread;

// channels
use std::sync::mpsc::{Sender, Receiver};
use std::sync::mpsc;

fn uppercase(c:char) -&gt; char {
	c.to_uppercase().next().unwrap()
}

fn main() {

	let mut model = VecDeque::new();
	model.push_back("dislexicos");
	model.push_back("devem");
	model.push_back("ler");
	model.push_back("frases");
	model.push_back("assim");

	let (senderChannel, receiverChannel)
		:(Sender&lt;&amp;str&gt;, Receiver&lt;&amp;str&gt;)
		= mpsc::channel();

	// envia dados pelo canal
	for element in model {
		senderChannel.send(element);
	}

	// fecha o canal
	drop(senderChannel);

	// alternativa 1: thread e lambda
	let mut lambdaElement = "lambda";
	let lambda_thread = thread::spawn(move || {

		let mut element:&amp;str;
		let mut elementUppercase:String;

		// roda at√© o canal ser fechado
		for element in receiverChannel {
			let uppercase:String = element
				.chars()
				.map(uppercase)
				.collect();
			println!("{:?}", uppercase);
		}

		// poder√≠amos usar receiverChannel.recv().unwrap()
		// e receiverChannel.try_recv().unwrap()

	});

	// alternativa 2: Builder e lambda
	let mut builderElement = "builder";
	let builder_thread = thread::Builder::new()
		.name("builder thread".to_string())
		.spawn(move || {

		let uppercase:String = builderElement
			.chars()
			.map(uppercase)
			.collect();
		println!("{:?}", uppercase);

	});

	// espera as threads terminarem antes de prosseguir
	lambda_thread.join();
	builder_thread.unwrap().join();

}</code
>
</div>

<div class='codeblock'>

<p>C# - MainClass.cs</p>
<code class='cs'
>using System;
using System.Threading;

namespace MarcoLuglio.ThreadExample {

	public class MainClass {

		public static void Main(string[] args) {

			// mem√≥ria compartilhada entre as threads
			var dataQueue = new Model();
			dataQueue.Push("dislexicos");
			dataQueue.Push("devem");
			dataQueue.Push("ler");
			dataQueue.Push("frases");
			dataQueue.Push("assim");





			// alternativa 1: m√©todo
			var worker = new ParallelWorker(dataQueue);
			var parallelThread = new Thread(worker.Work);
			parallelThread.Start();


			// alternativa 2: lambda
			var lambdaThread = new Thread(() =&gt; {
				string element;
				var sair = false;
				while (!sair) {
					// dataQueue capturado pelo lambda
					element = dataQueue.Next();
					// deixa a thread terminar naturalmente
					if (element == null) {
						sair = true;
						continue;
					}
					Console.WriteLine(element.ToUpper());
				}
			});
			lambdaThread.Start();


			// espera as threads terminarem antes de prosseguir
			parallelThread.Join();
			lambdaThread.Join();

		}

	}

}



</code
>

<p>C# - Model.cs</p>
<code class='cs'
>using System.Collections.Generic;

namespace MarcoLuglio.ThreadExample {

	// C# possui classes nativas com acesso
	// sincronizado, mas n√£o as utilizei para
	// demonstrar o uso de locks manuais
	public sealed class Model {

		public Model() {
			this.modelLock = new object();
			this.dataQueue = new Queue&lt;string&gt;();
		}

		public void Push(string element) {
			// s√≥ a main thread insere, ent√£o
			// n√£o precisa sincronizar
			this.dataQueue.Enqueue(element);
		}

		public string Next() {
			// sincroniza o acesso das threads
			lock (this.modelLock) {
				if (this.dataQueue.Count == 0) {
					return null;
				}
				return this.dataQueue.Dequeue();
			}
		}

		private readonly Queue&lt;string&gt; dataQueue;

		/// &lt;summary&gt;
		/// Lock simples expl√≠cita para sincroniza√ß√£o
		/// &lt;/summary&gt;
		private readonly object modelLock;

	}

}</code
>

<p>C# - ParallelWorker.cs</p>
<code class='cs'
>using System;

namespace MarcoLuglio.ThreadExample {

	public sealed class ParallelWorker {

		public ParallelWorker(Model dataQueue) {
			this.dataQueue = dataQueue;
		}

		// m√©todo "Main" da thread
		public void Work() {
			while (!this.sair) {
				this.element = this.dataQueue.Next();
				// deixa a thread terminar naturalmente
				if (this.element == null) {
					this.sair = true;
					continue;
				}
				Console.WriteLine(this.element.ToUpper());
			}
		}

		private Model dataQueue;
		private string element;

		/// &lt;summary&gt;
		/// Flag para t√©rmino da thread
		/// &lt;/summary&gt;
		private bool sair = false;

	}

}</code
>

</div>

<div class='codeblock'>

<p>Java - Main.java</p>
<code class='java'
>




public class Main {

	public static void main(String[] args) {

		// mem√≥ria compartilhada entre as threads
		Model dataQueue = new Model();
		dataQueue.push("dislexicos");
		dataQueue.push("devem");
		dataQueue.push("ler");
		dataQueue.push("frases");
		dataQueue.push("assim");

		// alternativa 1: subclasse de Thread
		ParallelThread parallelThread = new ParallelThread(dataQueue);
		parallelThread.start();

		// alternativa 2: interface Runnable
		Runnable parallelRunnable = new ParallelRunnable(dataQueue);
		Thread parallelRunnableThread = new Thread(parallelRunnable);
		parallelRunnableThread.start();

		// alternativa 3: lambda Runnable
		// ou interface funcional Runnable
		Runnable lambda = () -&gt; {
			String element;
			boolean sair = false;
			while (!sair) {
				// dataQueue capturado pelo lambda
				element = dataQueue.next();
				// deixa a thread terminar naturalmente
				if (element == null) {
					sair = true;
					continue;
				}
				System.out.println(element.toUpperCase());
			}
		};
		Thread lambdaRunnable = new Thread(lambda);
		lambdaRunnable.start();

		// espera as threads terminarem antes de prosseguir
		try {
			parallelThread.join();
			parallelRunnable.join();
			lambdaRunnable.join();
		} catch (InterruptedException e) {
			// fazer alguma coisa
		}

	}

}</code
>

<p>Java - Model.java</p>
<code class='java'
>package marcoluglio.threadexample;

import java.util.LinkedList;

// Java possui classes nativas com acesso
// sincronizado, mas n√£o as utilizei para
// demonstrar o uso de locks manuais
public final class Model {

	public Model() {
		this.modelLock = new Object();
		this.dataQueue = new LinkedList&lt;String&gt;();
	}

	public void push(String element) {
		// s√≥ a main thread insere, ent√£o
		// n√£o precisa sincronizar
		this.dataQueue.add(element);
	}

	public String next() {
		// sincroniza o acesso das threads
		synchronized(this.modelLock) {
			return this.dataQueue.poll();
		}
	}

	private LinkedList&lt;String&gt; dataQueue;

	/** Lock simples expl√≠cita para sincroniza√ß√£o */
	private final Object modelLock; // TODO testar o final

}







</code
>

<p>Java - ParallelThread.java</p>
<code class='java'
>

package marcoluglio.threadexample;

public final class ParallelThread extends Thread {

	public ParallelThread(Model dataQueue) {
		this.dataQueue = dataQueue;
	}

	// m√©todo "main" da thread
	@Override
	public void run() {
		while (!this.sair) {
			this.element = this.dataQueue.next();
			// deixa a thread terminar naturalmente
			if (this.element == null) {
				this.sair = true;
				continue;
			}
			System.out.println(this.element.toUpperCase());
		}
	}

	private Model dataQueue;
	private String element;

	/** Flag para t√©rmino da thread */
	private boolean sair = false;

}</code
>

<p>Java - ParallelRunnable.java</p>
<code class='java'
>package marcoluglio.threadexample;

public final class ParallelRunnable implements Runnable {

	public ParallelRunnable(Model dataQueue) {
		this.dataQueue = dataQueue;
	}

	// m√©todo "main" da thread
	@Override
	public void run() {
		while (!this.sair) {
			this.element = this.dataQueue.next();
			// deixa a thread terminar naturalmente
			if (this.element == null) {
				this.sair = true;
				continue;
			}
			System.out.println(this.element.toUpperCase());
		}
	}

	private Model dataQueue;
	private String element;

	/** Flag para t√©rmino da thread */
	private boolean sair = false;

}</code
>

</div>

<div class='codeblock'>

<p>JavaScript - main.js</p>
<code class='javascript'
>'use strict';

// cria a worker thread de uso exclusivo
// da main thread
let webWorker = new Worker('worker.js');

// web workers n√£o compartilham mem√≥ria
// apenas trocam mensagens entre si
// e n√£o podem acessar o DOM

// envia mensagens para a worker thread
webWorker.postMessage(['algum', 'valor']);
webWorker.postMessage([10, 20]);

// callback para recep√ß√£o de mensagens
// da worker thread
webWorker.onmessage = (event) =&gt; {
	console.log(event.data);
};

// mata a thread imediatamente se quiser
// webWorker.terminate();</code
>

<p>JavaScript - worker.js</p>
<code class='javascript'
>'use strict';

// callback para recep√ß√£o de mensagens
// da main thread (ui thread)
onmessage = (event) =&gt; {

	console.log(event.data[0]);
	console.log(event.data[1]);
	let result = event.data.join(' ');

	// envia mensagens para a main thread
	postMessage(result);

	// termina a thread se quiser
	// close();

};</code
>

</div>

<div class='codeblock'>

<p>JavaScript - sharedThread1.js</p>
<code class='javascript'
>'use strict';

<strong>// cria uma worker thread compartilhada</strong>
let <strong class='small'>webWorkerOp1</strong> = new <strong class='small'>SharedWorker(</strong>'worker.js'<strong class='small'>);</strong>

// envia mensagens para a worker thread compartilhada
webWorkerOp1<strong>.port</strong>.postMessage(['algum', 'valor']);
webWorkerOp1<strong>.port</strong>.postMessage([10, 20]);

// callback para recep√ß√£o de mensagens
// da worker thread
webWorkerOp1<strong>.port</strong>.onmessage = (event) =&gt; {
	console.log(event.data);
};</code
>

<p>JavaScript - sharedThread2.js</p>
<code class='javascript'
>'use strict';

// cria uma worker thread compartilhada
let <strong>webWorkerOp2</strong> = new <strong>SharedWorker(</strong>'worker.js'<strong>);</strong>

// envia mensagens para a worker thread compartilhada
webWorkerOp2<strong>.port</strong>.postMessage(['misturar', 2]);
webWorkerOp2<strong>.port</strong>.postMessage([10, 20]);

// callback para recep√ß√£o de mensagens
// da worker thread
webWorkerOp2<strong>.port</strong>.onmessage = (event) =&gt; {
	console.log(event.data);
};</code
>

<p>JavaScript - worker.js</p>
<code class='javascript'
>'use strict';

<strong>onconnect = (event) =&gt; {</strong>

	<strong>let port = event.ports[0];</strong>

	// callback para recep√ß√£o de mensagens
	// da main thread (ui thread)
	<strong>port.</strong>onmessage = (event) =&gt; {

		console.log(event.data[0]);
		console.log(event.data[1]);
		let result = event.data.join(' ');

		// envia mensagens para a main thread
		<strong>port.</strong>postMessage(result);

		// termina a thread se quiser
		// close();

	};

<strong>};</strong></code
>

</div>

</div>



<ol>
	<li>C#</li>
	<li>C++</li>
	<li>JavaScript</li>
	<li>Java</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='diretivas'>Diretivas</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>/*
os() OSX, iOS, watchOS, tvOS, Linux
arch() x86_64, arm, arm64, i386
swift() &gt;= followed by a version number
*/

#if os(iOS) &amp;&amp; !swift(&gt;= 2)
	// statements
#elseif os(OSX)
	// statements
#else
	// statements
#endif</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// TODO rust tem v√°rios atributos

// compila√ß√£o condicional com #cfg √© um deles

// copiado de <a rel='external nofollow' href='http://rustbyexample.com/attribute/cfg.html'>rust by example</a> e <a rel='external nofollow' href='http://doc.rust-lang.org/reference.html#conditional-compilation'>docs oficiais</a>

#[cfg(...)]
#[cfg(target_os = "macos")]
#[cfg(any(foo, bar))]
#[cfg(all(unix, target_pointer_width = "32"))]
#[cfg(not(foo))]

#[cfg(target_os = "linux")]
fn are_you_on_linux() {
	println!("You are running linux!")
}

// function only gets compiled if target OS is *not* linux
#[cfg(not(target_os = "linux"))]
fn are_you_on_linux() {
	println!("You are *not* running linux!")
}

fn main() {
	are_you_on_linux();

	println!("Are you sure?");
	if cfg!(target_os = "linux") {
		println!("Yes. It's definitely linux!");
	} else {
		println!("Yes. It's definitely *not* linux!");
	}
}

/*
debug_assertions - Enabled by default when compiling
without optimizations. This can be used to enable extra
debugging code in development but not in production.
For example, it controls the behavior of the
standard library's debug_assert! macro.

target_arch = "..." - "x86", "x86_64", "mips",
"powerpc", "powerpc64", "arm", or "aarch64".

target_endian = "..." - "little", "big".
target_env = ".." - musl, msvc, gnu or blank
target_family = "..." - "unix" or "windows".

target_os = "..." - "windows", "macos", "ios", "linux",
"android", "freebsd", "dragonfly", "bitrig" , "openbsd"
or "netbsd".

target_pointer_width = "..." - "32" or "64"
target_vendor = "..." - apple, pc, "unknown".

test - Enabled when compiling the test harness
(using the --test flag).

unix - See target_family.
windows - See target_family.
*/</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// n√£o podem ter whitespace antes!

#if DEBUG
	//
#elif TRACE
	//
#else
	//
#endif

// TODO ver oq o visual studio fornece

#define TESTE

#if TESTE

#warning TESTE is defined
// ou
#error TESTE is defined

#endif

#undef TESTE

// desabilitar avisos do compilador
#pragma warning disable 414, 3021
[CLSCompliant(false)]
public class C {
	static void Main() {}
}
#pragma warning restore 414, 3021

// garantir checksums de arquivos
#pragma checksum "filename.cs" "{3673e4ca-6098-4ec1-890f-8fceb2a794a2}" "{012345678AB}"
//                                         guid --^           checksum bytes --^

// #line √© mais usado por source generators

// for√ßa step over pelo debugger
#line hidden

#line 837 "Meio in√∫til"
#line default</code
>
</div>

<div class='codeblock'>
<p>Java</p>
-
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>'use strict'; // modo estrito</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
>Option Compare
Option Explicit

#Const DEBUG = 1

#If DEBUG = 1 Then
	'C√≥digo de debug
#Else
	'C√≥digo normal
#End If</code>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='tuples'>Tuples</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>#include &lt;tuple&gt;

auto valores{std::make_tuple(3.8, 'A', "Lisa Simpson")};
auto valoresCpp17{1, -1};

std::get&lt;0&gt;(valores);</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
-
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>let someTuple: (Double, Double, Double) = (3.14159, 2.71828, 1.1)
someTuple.0
// lembrando que uma tuple vazia em swift significa Void
// () -> ()
// () -> Void</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>let some_tuple = (1u8, 2u16, 2f32);
some_tuple.0;</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// tuple literals - C# 7+
var population = ("New York", 7891957, 7781984); // com √≠ndices // TODO verificar isso
var population = (a:"New York", b:7891957, c:7781984); // com nomes // TODO verificar isso

// tuple classes
var population = new Tuple&lt;string, int, int&gt;("New York", 7891957, 7781984);
population.Item1;</code
>
</div>

<div class='codeblock'>
<p>Java</p>
-
</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

</div>

<ol>
	<li>Rust / Swift</li>
	<li>C++ / C#</li>
</ol>

<p>Rust e Swift lidam com <em>tuples</em> de modo bastante integrado √† linguagem.<br />
C++ e C# tratam <em>tuples</em> como se fossem uma funcionalidade constru√≠da sobre o paradigma de orienta√ß¬µ√£o √† objetos.
</p>

</section>



<section>

<h2 id='objetos'>Objetos</h2>



<h3 id='structs'>Structs</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// Devemos inicializar todos os campos
// da struct com a sintaxe de chaves
// antes de poder us√°-la
pub struct ResultadoCaixa {
	pub total:i32,
	pub valorPago:i32,
	pub troco:i32,
}

let mut compra2 = ResultadoCaixa{
	total: 967,
	valorPago: 1000,
	troco: 33
};


















// structs podem ter m√©todos
// m√©todos podem ou n√£o modificar a struct
// dependendo de como recebem o argumento
// self. Se &amp;self ou &amp;mut self

impl ResultadoCaixa {

	pub fn descontarFidelidade(&amp;mut self) {
		self.total = self.calcularFidelidade();
		self.troco = self.valorPago - self.total;
	}

	fn calcularFidelidade(&amp;self) -&gt; i32 {
		self.total - 1
	}

}





// structs n√£o herdam de um objeto comum


// Nem suportam heran√ßa


// No entanto, podem implementar traits



trait Parcelavel {
	fn parcelar(&amp;self) -&gt; [i32; 3];
}

impl Parcelavel for ResultadoCaixa {
	fn parcelar(&amp;self) -&gt; [i32; 3] {
		//
	}
}</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// structs e classes s√£o id√™nticas
// em C++ exceto por uma √∫nica diferen√ßa
// por padr√£o os campos das structs s√£o
// publicos, e os das classes s√£o privados</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// Objective-C usa structs do C
// que s√£o um simples agrupamento
// de vari√°veis sem nenhuma outra
//funcionalidade extra
struct ResultadoCaixa {
	public var total:int
	public var valorPago:int
	public var troco:int
};

// sempre que utilizarmos o nome
// do tipo definido com uma struct
// precisamos incluir a palavra struct
// antes do nome do tipo
struct ResultadoCaixa compra1;
compra1.total = 967;
compra1.valorPago = 1000;
compra1.troco = 33;</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// Devemos inicializar todos os campos
// da struct com o inicializador gerado
// automaticamente antes de poder us√°-la
public struct ResultadoCaixa {
	public var total:Int
	public var valorPago:Int
	public var troco:Int
}

let compra1 = ResultadoCaixa(
	total: 967,
	valorPago:1000,
	troco:33
)


















// structs podem ter m√©todos
// por padr√£o, m√©todos n√£o podem modificar a struct
// mas podem ser marcados com a palavra mutating
// para indicar este intuito

public struct ResultadoCaixaFidelidade {

	public mutating func descontarFidelidade() {
		self.total = self.calcularFidelidade()
		self.troco = self.valorPago - self.total
	}

	private func calcularFidelidade() -&gt; Int {
		return total - 1
	}

	public var total:Int
	public var valorPago:Int
	public var troco:Int

}

// structs n√£o herdam de um objeto comum


// Nem suportam heran√ßa


// No entanto, podem implementar protocolos
// Embora o resultado seja bastante confuso
// em termos de aloca√ß√£o de mem√≥ria

public protocol Parcelavel {
	func parcelar():[Int]
}

public struct ResultadoCaixaCartao : Parcelavel {
	public func parcelar():[Int] {
		//
	}
}</code
>
</div>



<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>// data classes N√ÉO S√ÉO structs
// mas tem um prop√≥sito similar
public data class ResultadoCaixa(
	val total:Int,
	val valorPago:Int,
	var troco:Int
)

val compra1 = ResultadoCaixa(
	total = 967,
	valorPago = 1000,
	troco = 33
)</code
>
</div>



<div class='codeblock'>
<p>Java</p>
-
</div>



<div class='codeblock'>
<p>C#</p>
<code class='cs'
>
// Se criada sem new os campos
// s√£o iniciados manualmente
public struct ResultadoCaixa {
	public int total;
	public int valorPago;
	public int troco;
}

ResultadoCaixa compra1;
compra1.total = 967; // 9,67
compra1.valorPago = 1000; // 10,00
compra1.troco = 33; // 00,33

// Se criada com new os campos
// s√£o iniciados no construtor
public struct ResultadoCaixaC {

	ResultadoCaixaC(int total, int valorPago) {
		this.total = total;
		this.valorPago = valorPago;
		this.troco = valorPago = total;
	}

	public int total;
	public int valorPago;
	public int troco;

}

var compra2 = new ResultadoCaixaC(967, 1000);




// structs podem ter m√©todos

public struct ResultadoCaixaFidelidade {

	public void descontarFidelidade() {
		this.total = this.calcularFidelidade();
		this.troco = this.valorPago = this.total;
	}

	private int calcularFidelidade() {
		return this.total - 1;
	}

	public int total;
	public int valorPago;
	public int troco;

}

// structs herdam de Object
Console.WriteLine (resultado is Object); // true

// Mas N√ÉO suportam heran√ßas subsequentes
public struct ResultadoCaixaFidelidade2 : ResultadoCaixa {} // erro

// No entanto, podem implementar interfaces
// Embora o resultado seja bastante confuso
// em termos de aloca√ß√£o de mem√≥ria

public interface Parcelavel {
	int[] Parcelar();
}

public struct ResultadoCaixaCartao : Parcelavel { // ok
	public int[] Parcelar() {
		//
	}
}</code
>
</div>



<div class='codeblock'>
<p>JavaScript</p>
-
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
>' User Defined Types (UDTs) se parecem com structs

'Definimos o tipo num arquivo .bas separado
Public Type ResultadoCaixa
	Total As Integer
	ValorPago As Integer
	Troco As Integer
End Type

Dim compra1 As ResultadoCaixa

compra1.total = 967; ' 9,67
compra1.valorPago = 1000; ' 10,00
compra1.troco = 33; ' 00,33

'ou com With

With compra1
	.total = 967; ' 9,67
	.valorPago = 1000; ' 10,00
	.troco = 33; ' 00,33
End With</code>
</div>

</div>



<h3 id='classes'>Classes</h3>

<div class='comparison large'>

<div class='codeblock'>
<p>Rust</p>
-
</div>

<div class='codeblock'>

	<div class='pair'>

		<div>
			<p>C++ - ResultadoCaixa.hpp</p>
			<code class='cpp'
>#pragma once

class ResultadoCaixa final {

public:

	explicit ResultadoCaixa(const int total, const int valorPago);
	~ResultadoCaixa();
	void descontarFidelidade();

private:

	// por padr√£o, m√©todos podem modificar a classe
	// mas podem ser marcados com a palavra const
	// para proibir este intuito
	int calcularFidelidade() const;

	int total;
	int valorPago;
	int troco;

};</code
			>
		</div>

		<div>
			<p>C++ - ResultadoCaixa.cpp</p>
			<code class='cpp'
>#include "ResultadoCaixa.hpp"

ResultadoCaixa::ResultadoCaixa(const int total, const int valorPago)
	: total{total}, valorPago{valorPago} {

	this-&gt;troco = valorPago - total;
}

ResultadoCaixa::~ResultadoCaixa() {
	//
}

ResultadoCaixa::descontarFidelidade() {
	this-&gt;total = calcularFidelidade();
	this-&gt;troco = valorPago - total;
}

int ResultadoCaixa::calcularFidelidade() const {
	return total - 1;
}</code
			>
		</div>

	</div>

	<p>C++ - main.cpp</p>
	<code class='cpp'
>#include "ResultadoCaixa.hpp"

int main(int argc, const char* argv[]) {

	// aloca na stack
	auto compra1 = ResultadoCaixa(997, 1000);
	compra1.descontarFidelidade();

	// aloca na heap
	auto compra2 = new ResultadoCaixa(997, 1000);
	compra2.descontarFidelidade();

	return 0;

}</code
	>

</div>

<div class='codeblock'>

	<div class='pair'>

		<div>
			<p>Objective-C - ResultadoCaixa.h</p>
			<code class='objectivec'
>#import &lt;Foundation/Foundation.h&gt;

@interface ResultadoCaixa : NSObject {
	// instance variables ou ivars
	@private
	int _troco;
}

- (void) descontarFidelidade;

- (int) calcularFidelidade;

// propriedades
@property (assign, nonatomic) int total;
@property (assign, nonatomic) int valorPago;

@end</code
			>
		</div>

		<div>
			<p>Objective-C - ResultadoCaixa.m</p>
			<code class='objectivec'
>#import "ResultadoCaixa.h"

@implementation ResultadoCaixa

	- (id) initWithTotal:(int)novoTotal eValorPago:(int)novoValorPago {
		[self init];
		// propriedades s√£o acessadas com .
		self.total = novoTotal;
		self.valorPago = novoValorPago;
		// ivars s√£o acessadas com -&gt;
		self-&gt;_troco = self.valorPago - self.total;
		return self;
	}

	- (void) descontarFidelidade {
		self.total = [self calcularFidelidade];
		self-&gt;_troco = self.valorPago - self.total;
	}

	- (int) calcularFidelidade {
		return self.total - 1;
	}

@end</code
			>
		</div>

	</div>

	<p>Objective-C - main.m</p>
	<code class='objectivec'
>#import "ResultadoCaixa.h"

int main(int argc, const char* argv[]) {

	ResultadoCaixa* compra1 = [[ResultadoCaixa alloc] initWithTotal:997 eValorPago:1000];
	[compra1 descontarFidelidade];

	return 0;

}</code
	>

</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>public final class ResultadoCaixa {

	init(total:Int, valorPago:Int) {
		self.total = total
		self.valorPago = valorPago
		self.troco = valorPago - total
	}

	public func descontarFidelidade() {
		self.total = self.calcularFidelidade()
		self.troco = self.valorPago - self.total
	}

	private func calcularFidelidade() -&gt; Int {
		return self.total - 1
	}

	private var total = 0
	private var valorPago = 0
	private var troco = 0

}

let compra1 = ResultadoCaixa()
compra1.descontarFidelidade()





class C {

	static func myStaticMethod() {
		//
	}

	static var myStaticProp:String

	deinit {
		//
	}

	lazy var prop:String

}

final class D : C, P, Q {

	override init() {
		super.init()
	}

	init?() {
		return nil
	}

	convenience init() {
		//
	}

	// o override pode ser mais vis√≠vel!
	override internal func myMethod() {
		super.myMethod()
	}

}

final class R {

	required init() {
		//
	}

}</code
>
</div>

<div class='codeblock'>

<p>Kotlin - ResultadoCaixa.kt</p>
<code class='kotlin'
>public class ResultadoCaixa(total:Int, valorPago:Int) {

	public fun descontarFidelidade() {
		this.total = this.calcularFidelidade();
		this.troco = this.valorPago - this.troco;
	}

	private fun calcularFidelidade():Int {
		return this.total - 1;
	}

	var total = total
	val valorPago = valorPago
	var troco = valorPago - total

	lateinit var prop:String

}

// OU

public class ResultadoCaixa constructor(val total:Int, val valorPago:Int) {

	init {
		this.total = total
		this.valorPago = valorPago
		this.troco = valorPago - total
	}

	public fun descontarFidelidade() {
		this.total = this.calcularFidelidade();
		this.troco = this.valorPago - this.troco;
	}

	private fun calcularFidelidade():Int {
		return this.total - 1;
	}

	var total:Int
	val valorPago:Int
	var troco:Int

}

val compra1 = ResultadoCaixa(997, 1000)
compra1.descontarFidelidade()



open class C {
}

class D : C, P, Q {
	//
}</code
>

<p>Kotlin - Main.kt</p>
<code class='kotlin'
></code
>

</div>

<div class='codeblock'>

<p>Java - ResultadoCaixa.java</p>
<code class='java'
>public final class ResultadoCaixa {

	public ResultadoCaixa(int total, int valorPago) {
		this.total = total;
		this.valorPago = valorPago;
		this.troco = this.valorPago - this.troco;
	}

	public void descontarFidelidade() {
		this.total = this.calcularFidelidade();
		this.troco = this.valorPago - this.troco;
	}

	private int calcularFidelidade() {
		return this.total - 1;
	}

	private int total = 0;

	// vari√°veis final n√£o podem ser alteradas
	// ap√≥s seu valor ter sido especificado
	private final int valorPago;

	private int troco = 0;

}</code
>

<p>Java - Main.java</p>
<code class='java'
>public class Main {
	public static void main(string[] args) {
		ResultadoCaixa compra1 = new ResultadoCaixa(997, 1000);
		compra1.descontarFidelidade();
	}
}</code
>

</div>

<div class='codeblock'>

<p>C# - ResultadoCaixa.cs</p>
<code class='cs'
>public sealed class ResultadoCaixa {

	public ResultadoCaixa(int total, int valorPago) {
		this.total = total;
		this.valorPago = valorPago;
		this.troco = this.valorPago - this.troco;
	}

	public void descontarFidelidade() {
		this.total = this.calcularFidelidade();
		this.troco = this.valorPago - this.troco;
	}

	// c# 7
	private int calcularFidelidade => this.total - 1;

	private int total = 0;

	// propriedades readonly s√≥ podem ser modificadas
	// dentro do construtor
	private readonly int valorPago;

	private int troco = 0;

}</code
>

<p>C# - MainClass.cs</p>
<code class='cs'
>public class MainClass {
	public static void Main(string[] args) {

		// argumentos por posi√ß√£o
		var compra1 = new ResultadoCaixa(997, 1000);
		compra1.descontarFidelidade();

		// argumentos nomeados
		var compra2 = new ResultadoCaixa(total:997, valorPago:1000);
		compra2.descontarFidelidade();

	}
}</code
>

</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>const ResultadoCaixa = class ResultadoCaixa {

	constructor(total, valorPago) {

		Object.defineProperties(this, {
			total: {value: total, writable: true},
			valorPago: {value: valorPago, writable: true},
			troco: {value: valorPago - total, writable: true}
		});

		Object.seal(this);

	}

	descontarFidelidade() {
		this.total = this.calcularFidelidade();
	}

	calcularFidelidade() {
		return this.total - 1;
	}

};

const compra1 = new ResultadoCaixa();
compra1.descontarFidelidade();</code
>
</div>

<div class='codeblock'>

<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr> - ResultadoCaixa.cls</p>
<code class='visualbasic'
>'Evento
Public Event OnChange(ByVal valorNovo As Byte, ByVal valorAntigo As Byte)

'Vari√°vel p√∫blica, pode ser acessada diretamente
Public publicVar As Boolean

'Vari√°veis privadas acessadas pelas propriedades
Private prop1 As Boolean
Private friendProp1 As Boolean

'Getter
Public Property Get Prop1() As Boolean
	Prop1 = prop1
End Property

'Setter de tipos primitivos usa Let
Public Property Let Prop1(ByVal value As Boolean)
	prop1 = value
End Property

'Setter de objetos usa Set

'Friend permite acesso por outros objetos do mesmo projeto / dll
'N√£o tem rela√ß√£o nenhuma com a funcionalidade em c++
Friend Property Get FriendProp1() As Boolean
	FriendProp1 = friendProp1
End Property

Public Sub Metodo1()
	RaiseEvent OnChange(1, 2)
	'Podemos nos registrar para responder √† esse evento usando no nosso form
	'Private Sub Instance_OnChange(ByVal valorNovo As Byte, ByVal valorAntigo As Byte)
		'...
	'End Sub
End Sub

Public Function Metodo2() As Boolean
	'...
End Function

Friend Function MetodoFriend(Optional ByVal argOpcional1 As Boolean = True) As Boolean
	'...
End Function</code>

<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr> - Main.bas</p>
<code class='visualbasic'
>Dim compra1 As ResultadoCaixa
Set compra1 = new ResutadoCaixa
' TODO</code>

</div>

</div>



<h4 id='gettersSetters'>Getters e Setters</h4>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
-
</div>

<div class='codeblock'>
<p>C++</p>
-
</div>

<div class='codeblock'>

	<div class='pair'>

		<div>
			<p>Objective-C - A.h</p>
			<code class='objectivec'
>#import &lt;Foundation/Foundation.h&gt;

@interface A : NSObject

@property (assign, nonatomic) NSString* prop;
@property (assign, nonatomic) NSString* prop2;

@end</code
			>
		</div>

		<div>
			<p>Objective-C - A.m</p>
			<code class='objectivec'
>#import "A.h"

@implementation A

@end</code
			>
		</div>

	</div>

	<p>Objective-C - main.m</p>
	<code class='objectivec'
>#import "A.h"

int main(int argc, const char* argv[]) {

	A* a = [[A alloc] init];
	a.prop = @"";

	return 0;

}</code
	>

</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>public final class A {

	init() {
		//
	}

	var getter:String {
		return ...
	}

	var getterSetter:String {

		get {
			return self._getterSetter
		}

		set(newValue) { // ou newValue impl√≠cito set {
			self._getterSetter = newValue
		}

	}

	private _getterSetter:String

	// setter pode ser menos vis√≠vel que o getter
	public private(set) var numberOfEdits = 0

	// internal
	private(set) var numberOfEdits = 0

}

var a = A()
a.prop = ""</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>// as classes s√£o final por padr√£o
// n√£o confundir com sealed class
// que quer dizer outra coisa
class A {

	init {
		//
	}

	// getter
	var stringRepresentation: String
	get() = this.toString()

	// getter e setter
	var stringRepresentation2: String
	get() = this.toString()
	set(value) {
		setDataFromString(value)
	}

	// com visibilidades diferentes
	var stringRepresentation3: String
	get() = this.toString()
	private set(value) {
		setDataFromString(value)
	}

}</code
>
</div>

<div class='codeblock'>
<p>Java</p>
-
</div>

<div class='codeblock'>

<p>C# - ResultadoCaixa.cs</p>
<code class='cs'
>public sealed class A {

	public A() {
		//
	}

	public string Prop {
		get;
		set;
	}

	// c# 7
	public string Prop2 {
		get =&gt; "";
		set =&gt; this.prop2 = value;
	}

	public string Prop3 {

		get {
			return "";
		}

		set {
			this.prop3 = value;
		}

	}

	private string prop2;
	private string prop3;

}</code
>

<p>C# - MainClass.cs</p>
<code class='cs'
>public class MainClass {
	public static void Main(string[] args) {

		// argumentos por posi√ß√£o
		var a = new A();
		a.prop = @"";
		a.prop2 = @"";

	}
}</code
>

</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>const A = class A {

	constructor() {

		Object.defineProperty(
			this,
			'_prop',
			{value: null, writable: true}
		);

		Object.seal(this);

	}

	get prop() {
		return this._prop;
	}

	set prop(newValue) {
		this._prop = newValue;
	}

};

const a = new A();
a.prop = '';</code
>
</div>

</div>



<h3 id='traits'>Traits</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>trait HasArea {
	fn is_invalid(&amp;self) -&gt; bool { !self.is_valid() }
}

impl HasArea for Circle {
	// is_invalid "herdado"
}</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// Heran√ßa m√∫ltipla tem
// funcionalidade similar
// √†s traits</code
>
</div>

<div class='codeblock'>

	<div class='pair'>

		<div>
			<p>Objective-C - Traits.h</p>
			<code class='objectivec'
			>@interface Person (Traits)
- (void) addFriend:(Person *)aFriend;
- (void) removeFriend:(Person *)aFriend;
- (void) sayHelloToFriends;
@end</code
			>
		</div>

		<div>
			<p>Objective-C - Traits.m</p>
			<code class='objectivec'
			>#import "Person+Relations.h"

@implementation Person (Traits)

- (void) addFriend:(Person*)aFriend {
	[[self friends] addObject:aFriend];
}

- (void) removeFriend:(Person*)aFriend {
	[[self friends] removeObject:aFriend];
}

- (void) sayHelloToFriends {
	for (Person* friend in [self friends]) {
		NSLog(@"Hello there, %@!", [friend name]);
	}
}

@end</code
			>
		</div>

	</div>

</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>extension ClassToBeExtended {
	// posso adicionar initializers
	// m√©todos
	// e propriedades
}</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>fun ClassToBeExtended.extensionMethod() {
	//
}

// ou como Java 8
public interface Desenhavel {
	desenhar() {
		//
	}
}</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>public interface Desenhavel {
	default void desenhar() {
		//
	}
}</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>public static class MyExtensions {
	public static int ExtensionMethod(this ClassToBeExtended str) {
		//
	}
}</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>
</code
>
</div>

</div>



<h3 id='interfaces'>Interfaces</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// public internal private

// interfaces

protocol P {
	// pode conter vari√°veis e m√©todos
}

protocol Q {
	//
}

// structs

struct S : P, Q {

	// para structs, o padr√£o dos m√©todos
	// √© ser const
	func constMethod() {
		//
	}

	mutating func structMethod() {
		//
	}

}

final class D : C, P, Q {

	override init() {
		super.init()
	}

	init?() {
		return nil
	}

	convenience init() {
		//
	}

	// o override pode ser mais vis√≠vel!
	override internal func myMethod() {
		super.myMethod()
	}

}

let o2 = D()</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>trait HasArea {
	fn area(&amp;self) -&gt; f64;
}

impl HasArea for Circle {
	fn area(&amp;self) -&gt; f64 {
		std::f64::consts::PI * (self.radius * self.radius)
	}
}</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>
</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>interface A {
	fun foo() { print("A") }
	fun bar()

	val prop: Int // abstract

	val propertyWithImplementation: String
		get() = "foo"
}

interface B {
	fun foo() { print("B") }
	fun bar() { print("bar") }
}

class C : A {
	override fun bar() { print("bar") }
}

class D : A, B {
	override fun foo() {
		super&lt;A&gt;.foo()
		super&lt;B&gt;.foo()
	}

	override fun bar() {
		super&lt;B&gt;.bar()
	}
}</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// TODO</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

</div>



<h3 id='heranca'>Heran√ßa</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>class C {

	static func myStaticMethod() {
		//
	}

	static var myStaticProp:S

	init() {
		//
	}

	deinit {
		//
	}

	private func myMethod() {
		self.prop
	}

	var getter:S {
		return ...
	}

	var getterSetter:S {

		get {
			return self._getterSetter
		}

		set(newValue) { // ou newValue impl√≠cito set {
			self._getterSetter = newValue
		}

	}

	lazy var prop:S

	private _getterSetter:S

	// setter pode ser menos vis√≠vel que o getter
	public private(set) var numberOfEdits = 0

	// internal
	private(set) var numberOfEdits = 0

}

final class R {

	required init() {
		//
	}

}

let o1 = C()
let o2 = D()</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>trait Foo {
	fn foo(&amp;self);
}

trait FooBar : Foo {
	fn foobar(&amp;self);
}</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>
</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>
</code
>
</div>

</div>



<h3 id='classesAnonimas'>Classes An√¥nimas</h3>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
></code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
></code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>public final class MainActivity : AppCompatActivity() {

	override fun onCreate(savedInstanceState:Bundle?) {

		super.onCreate(savedInstanceState)

		this.txtValorMes!!.addTextChangedListener(<strong>object : TextWatcher {</strong>


			override fun beforeTextChanged(s:CharSequence, start:Int, count:Int, after:Int) { /**/}


			override fun onTextChanged(s:CharSequence, start:Int, before:Int, count:Int) {
				<strong class='comment small'>// this@ acessa o escopo nomeado</strong>
				<strong class='small'>this@MainActivity.mainProperty</strong>
			}


			override fun afterTextChanged(s:Editable) { /**/ }

		<strong>}</strong>)

	}

	private var mainProperty:Int

}</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>public final class MainActivity extends AppCompatActivity {

	public void onCreate(Bundle savedInstanceState) {

		super.onCreate(savedInstanceState)

		this.txtValorMes.addTextChangedListener(<strong>new TextWatcher {</strong>

			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) { /**/ }

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
				<strong class='comment small'>// Container.this acessa o escopo externo</strong>
				<strong class='small'>Container.this.mainProperty;</strong>
			}

			@Override
			public void afterTextChanged(Editable s) { /**/ }

		<strong>}</strong>)

	}

	private int mainProperty;

}</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>
</code
>
</div>

</div>



<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2>Resolu√ß√£o de tipos</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// dynamic dispatch
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// static e dynamic dispatch
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// ver "trait objects" na doc oficial
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>
</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>
</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='tipogenerico'>Tipo Gen√©rico</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>
</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// tipagem din√¢mica
</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='operatoroverload'>Operator Overload</h2>

<div class='comparison'>

<div class='codeblock'>

	<p>C++ - main.cpp</p>
	<code class='cpp'
	>#include &lt;iostream&gt;
#include "MusicNote.hpp"

int main(int argc, const char* argv[]) {

	using std::cout;
	using std::endl;

	using MarcoLuglio::OpOvExample::MusicNote;
	using MarcoLuglio::OpOvExample::Step;
	using MarcoLuglio::OpOvExample::Semitone;

	auto cSharp = MusicNote(Step::C, Semitone::None);
	cSharp = cSharp + Semitone::Sharp;
	cout &lt;&lt; cSharp &lt;&lt; endl; // Do‚ôØ

	auto note1 = MusicNote(Step::C);
	cout &lt;&lt; note1++ &lt;&lt; endl; // Do

	auto note2 = MusicNote(Step::C);
	cout &lt;&lt; ++note2 &lt;&lt; endl; // Do‚ôØ

	return 0;

}</code
	>

	<div class='pair'>
		<div>
			<p>C++ - MusicNote.hpp</p>
			<code class='cpp'
			>#pragma once

#include &lt;cstdint&gt;
#include &lt;string&gt;
#include "Enumerators.hpp"

namespace MarcoLuglio {
namespace ThreadExample {

	class MusicNote final {

	public:

		MusicNote(Step step, Semitone semitone = Semitone::None);

		// N√£o √© poss√≠vel declarar operator&lt;&lt; como
		// um membro da classe. Mas podemos declar√°-lo
		// como uma friend function, que consegue acessar
		// as propriedades privadas da classe como se
		// fosse um membro
		friend std::ostream&amp; operator&lt;&lt;(
			std::ostream&amp; os,
			const MusicNote&amp; obj
		);

		MusicNote operator+(const Semitone semitone) const;

		/// prefix increment
		MusicNote&amp; operator++();

		/// postfix increment
		MusicNote operator++(int);

		Step getStep();

		Semitone getSemitone();

	private:
		Step step;
		Semitone semitone;

	};

}
}</code
			>
		</div>
		<div>
			<p>C++ - MusicNote.cpp</p>
			<code class='cpp'
			>#include "MusicNote.hpp"

namespace MarcoLuglio {
namespace ThreadExample {

	using std::string;

	MusicNote::MusicNote(Step step, Semitone semitone)
		: step{step}, semitone{semitone} {
		//
	}

	MusicNote MusicNote::operator+(const Semitone semitone) const {

		if (semitone == Semitone::None) {
			return *this;
		}

		Step newStep = this-&gt;step;
		Semitone newSemitone = semitone;

		if (newSemitone == Semitone::Sharp
			&amp;&amp; (newStep == Step::Mi || newStep == Step::E)
			) {

			newStep = Step::Fa;
			newSemitone = Semitone::None;

		} else if (newSemitone == Semitone::Flat
			&amp;&amp; (newStep == Step::Fa || newStep == Step::F)
			) {

			newStep = Step::Mi;
			newSemitone = Semitone::None;

		}

		// Rest of add logic here

		return MusicNote(newStep, newSemitone);

	}


	MusicNote&amp; MusicNote::operator++() {
		MusicNote&amp; ref = *this;
		auto tmp = ref + Semitone::Sharp;
		this-&gt;step = tmp.getStep();
		this-&gt;semitone = tmp.getSemitone();
		return ref;
	}

	MusicNote MusicNote::operator++(int) {
		MusicNote tmp{*this}; // copy
		this-&gt;operator++(); // pre-increment
		return tmp; // return old value
	}

	Step MusicNote::getStep() {
		return this-&gt;step;
	}

	Semitone MusicNote::getSemitone() {
		return this-&gt;semitone;
	}

	std::ostream&amp; operator&lt;&lt;(
		std::ostream&amp; os,
		const MusicNote&amp; note
		) {

		os &lt;&lt; note.step &lt;&lt; note.semitone;
		return os;
	}

}
}</code
			>
		</div>
	</div>

	<div class='pair'>
		<div>
			<p>C++ - Enumerators.hpp</p>
			<code class='cpp'
			>#pragma once

namespace MarcoLuglio {
namespace OpOvExample {

	enum Step : uint8_t {

		// solf√®je
		Do = 1,
		Re = 3,
		Mi = 5,
		Fa = 6,
		Sol = 8,
		La = 10,
		Si = 12,

		// abc
		C = 1,
		D = 3,
		E = 5,
		F = 6,
		G = 8,
		A = 10,
		B = 12

	};

	enum Semitone : int8_t {

		None = 127,
		Natural = 0,
		DoubleFlat = -2,
		Flat = -1,
		Sharp = 1,
		DoubleSharp = 2

	};

	std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Step&amp; step);

	std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Semitone&amp; semitone);

}
}</code
			>
		</div>
		<div>
			<p>C++ - Enumerators.cpp</p>
			<code class='cpp'
			>#include "Enumerators.hpp"

namespace MarcoLuglio {
namespace OpOvExample {

	std::ostream&amp; operator&lt;&lt;(
		std::ostream&amp; os,
		const Step&amp; step
		) {

		switch (step) {

			case Step::Do:
				os &lt;&lt; "Do";
				break;

			case Step::Re:
				os &lt;&lt; "Re";
				break;

			case Step::Mi:
				os &lt;&lt; "Mi";
				break;

			case Step::Fa:
				os &lt;&lt; "Fa";
				break;

			case Step::Sol:
				os &lt;&lt; "Sol";
				break;

			case Step::La:
				os &lt;&lt; "La";
				break;

			case Step::Si:
				os &lt;&lt; "Si";
				break;

			default:
				break;

		}

		return os;

	}

	std::ostream&amp; operator&lt;&lt;(
		std::ostream&amp; os,
		const Semitone&amp; semitone
		) {

		switch (semitone) {

			case Semitone::None:
				break;

			case Semitone::Natural:
				os &lt;&lt; "‚ôÆ";
				break;

			case Semitone::DoubleFlat:
				os &lt;&lt; "ùÑ´";
				break;

			case Semitone::Flat:
				os &lt;&lt; "‚ô≠";
				break;

			case Semitone::Sharp:
				os &lt;&lt; "‚ôØ";
				break;

			case Semitone::DoubleSharp:
				os &lt;&lt; "ùÑ™";
				break;

			default:
				break;

		}

		return os;

	}

}
}</code
			>
		</div>
	</div>

</div>

<div class='codeblock'>
<p>Objective-C</p>
-
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// TODO ver
// <a href='https://doc.rust-lang.org/std/ops/'>https://doc.rust-lang.org/std/ops/</a>
</code
>
</div>

<div class='codeblock'>

<p>C# - MainClass.cs</p>
<code class='cs'
>using System;

namespace MarcoLuglio.OpOvExample {
	public class MainClass {
		public static void Main(string[] args) {

			// Sim, de onde voc√™ achava que tinha vindo??
			var cSharp = new MusicNote(Step.C, Semitone.None);
			cSharp = cSharp + Semitone.Sharp;
			Console.WriteLine(cSharp); // Do‚ôØ

			var note1 = new MusicNote(Step.C);
			Console.WriteLine(note1++); // Do

			var note2 = new MusicNote(Step.C);
			Console.WriteLine(++note2); // Do‚ôØ

		}
	}
}</code
>

<p>C# - MusicNote.cs</p>
<code class='cs'
>using System;

namespace MarcoLuglio.OpOvExample {

	<strong>public final class MusicNote {</strong>

		<strong>public static MusicNote operator +(MusicNote note, Semitone semitone) {</strong>

			if (semitone == Semitone.None) {
				return note;
			}

			Step newStep = note.step;
			Semitone newSemitone = semitone;

			if (newSemitone == Semitone.Sharp
				&amp;&amp; (newStep == Step.Mi || newStep == Step.E)
				) {

				newStep = Step.Fa;
				newSemitone = Semitone.None;

			} else if (newSemitone == Semitone.Flat
				&amp;&amp; (newStep == Step.Fa || newStep == Step.F)
				) {

				newStep = Step.Mi;
				newSemitone = Semitone.None;

			}

			// Rest of add logic here

			<strong>return new MusicNote(newStep, newSemitone);</strong>

		<strong>}</strong>

		<strong class='small'>public static MusicNote operator ++(MusicNote note) {</strong>
			<strong class='comment small'>// Retorne sempre um novo objeto dentro desse override</strong>
			<strong class='comment small'>// Para que que o prefixo e o sufixo ++ funcionem corretamente</strong>
			<strong class='comment small'>// Nesse caso o override do + ir√° se encarregar disso</strong>
			<strong class='small'>return note + Semitone.Sharp;</strong>
		<strong>}</strong>

		public MusicNote(Step step, Semitone semitone = Semitone.None) {
			this.Step = step;
			this.Semitone = semitone;
		}

		public override string ToString() {
			return string.Format("{0}{1}", Step, Semitone.ToDescriptionString());
		}

		public Step Step {
			get;
			private set;
		}

		public Semitone Semitone {
			get;
			set;
		}

		private Step step = Step.Do;

		private Semitone semitone = Semitone.None;

	<strong>}</strong>

}</code
>

<p>C# - Enumerators.cs</p>
<code class='cs'
>using System;
using System.ComponentModel; // Description attribute

namespace MarcoLuglio.OpOvExample {

	public enum Step : byte {

		// solf√®je
		Do = 1,
		Re = 3,
		Mi = 5,
		Fa = 6,
		Sol = 8,
		La = 10,
		Si = 12,

		// abc
		C = 1,
		D = 3,
		E = 5,
		F = 6,
		G = 8,
		A = 10,
		B = 12

	}

	public enum Semitone : sbyte {

		[Description("")]
		None = 0,

		[Description("‚ôÆ")]
		Natural = 0,

		[Description("\uD834\uDD2B")]
		DoubleFlat = -2,

		[Description("‚ô≠")]
		Flat = -1,

		[Description("‚ôØ")]
		Sharp = 1,

		[Description("\uD834\uDD2A")]
		DoubleSharp = 2

	}

	public static class SemitoneExtensions {
		public static string ToDescriptionString(this Semitone semitone) {
			DescriptionAttribute[] attributes = (DescriptionAttribute[])semitone
				.GetType()
				.GetField(semitone.ToString())
				.GetCustomAttributes(typeof(DescriptionAttribute), false);
			return attributes.Length > 0 ? attributes[0].Description : string.Empty;
		}
	}

}<strong style='display: none'></strong></code
>

</div>

<div class='codeblock'>
<p>Java</p>
-
</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='indexing'>Indexing <span>Cole√ß√µes de Objetos como Arrays</span></h2>

<div class='comparison large'>

<div class='codeblock'>

	<div class='pair'>

		<div>
			<p>C++ - OpOvCollection.hpp</p>
			<code class='cpp'
			>#pragma once

#include &lt;string&gt;

namespace MarcoLuglio {
namespace IndexerExample {

	using std::size_t;
	using std::string;
	using std::to_string;

	/// type alias para simplificar a sintaxe
	/// do retorno da fun√ß√£o getArray
	using arrayReference = int[10];


	class OpOvCollection final {

	public:

		/// Classe auxiliar que permite altera√ß√£o
		/// dos valores da cole√ß√£o
		class Proxy final {

		public:

			Proxy(OpOvCollection&amp; collection, const size_t index)
				: collection{collection}, index{index} {}

			/// Overload do operador = para altera√ß√£o
			/// dos valores da cole√ß√£o
			int&amp; operator= (int newValue) {
				collection.array[index] = newValue;
				return collection.array[index]; // FIXME
			}

			/// C++ n√£o possui uma classe base comum
			/// ent√£o as convers√µes para string devem ser
			/// implementadas sempre
			operator string() const {
				return to_string(collection.array[index]);
			}

		private:

			/// Refer√™ncia da cole√ß√£o original, para alterac√£o
			/// dos valores nos √≠ndices
			OpOvCollection &amp;collection;

			size_t index;

		};

		OpOvCollection();

		/// Overload do operador [] para obten√ß√£o
		/// dos valores da cole√ß√£o
		/// Esse overload s√≥ possibilita retornar valores,
		/// portanto √© necess√°rio que ele retorne um objeto
		/// proxy ao inv√©s do valor real, pois o proxy
		/// possibilita a altera√ß√£o do valor na cole√ß√£o
		/// original
		OpOvCollection::Proxy operator[](const size_t index);

	private:

		/// Cole√ß√£o original
		int array[10];

	}

}
}</code
			>
		</div>

		<div>
			<p>C++ - OpOvCollection.cpp</p>
			<code class='cpp'
			>#include "OpOvCollection.hpp"

namespace MarcoLuglio {
namespace IndexerExample {

	using CollectionProxy = OpOvCollection::Proxy;
	using std::size_t;

	/// type alias para simplificar a sintaxe
	/// do retorno da fun√ß√£o getArray
	using arrayReference = int[10];


	OpOvCollection::OpOvCollection() {
		// inicia a array com valores 0
		std::fill(this-&gt;array, this-&gt;array + 9, 0);
	}

	CollectionProxy OpOvCollection::operator[](const size_t index) {
		return CollectionProxy(*this, index);
	}

}
}</code
			>
		</div>

	</div>

	<p>C++ - main.cpp</p>
	<code class='cpp'
	>#include &lt;iostream&gt;
#include &lt;string&gt;
#include "OpOvCollection.hpp"

int main(int argc, const char* argv[]) {

	using std::cout;
	using std::endl;
	using std::string;

	using MarcoLuglio::IndexerExample::OpOvCollection;


	auto opOvCollection = OpOvCollection();
	opOvCollection[0] = 7;
	opOvCollection[1] = 45;
	opOvCollection[2] = 83;

	string value = (string)opOvCollection[2];

	// 83
	cout &lt;&lt; value &lt;&lt; endl;

	return 0;

}</code
	>

</div>

<div class='codeblock'>

	<div class='pair'>

		<div>
			<p>Objective-C - IndexedCollection.h</p>
			<code class='objectivec'
>@interface {
}

// pode ser indexada por inteiros
- (id) objectAtIndexedSubscript:(int)index;
- (void) setObject:(id)obj atIndexedSubscript:(int)index;

// ou por outros tipos
- (id) objectForKeyedSubscript:(NSString)key;
- (void) setObject:(id)obj forKeyedSubscript:(NSString)key;

@end</code
			>
		</div>

		<div>
			<p>Objective-C - IndexedCollection.m</p>
			<code class='objectivec'
>#import "IndexedCollection.h"

@implementation

// TODO

@end</code
			>
		</div>

	</div>

	<p>Objective-C - IndexedCollection.h</p>
	<code class='objectivec'
>#import "IndexedCollection.h"

int main(int argc, const char* argv[]) {

	IndexedCollection* indexedCollection = [IndexedCollection new];

	indexedCollection[0] = "sunday";
	indexedCollection[1] = "monday I'm in love";
	indexedCollection[2] = "tuesday and wednesday too";

	// "tuesday and wednesday too"
	NSLog(indexedCollection["tuesday"]);

	return 0;

}</code
	>

</div>

<div class='codeblock'>

<p>Swift - SubscriptCollection.swift</p>
<code class='swift'
>// Swift n√£o tem valores padr√£o para tipos, nem tem uma classe base comum
// Ent√£o usamos um protocolo que o tipo gen√©rico deve seguir
public final class SubscriptCollection&lt;T:StringLiteralConvertible&gt; {

	init() {
		self.array = [T](count:10, repeatedValue:"")
	}

	// pode ser indexada por inteiros
	subscript(index:Int) -&gt; T {
		get {
			return self.array[index]
		}
		set(newValue) {
			self.array[index] = newValue
		}
	}

	// ou por outros tipos
	subscript(key:String) -&gt; T {
		get {
			var string:String
			var stringStart:String
			var stringIndex:String.Index
			for item in self.array {
				string = String(item)
				if string.isEmpty || string == "nil" {
					continue
				}
				stringIndex = string.startIndex.advancedBy(key.characters.count)
				stringStart = string.substringToIndex(stringIndex)
				if stringStart == key {
					return item
				}
			}
			// retorna uma string vazia se n√£o encontrar um item pela chave
			// j√° que o tipo deve poder ser convertido para string
			return ""
		}
	}

	// e ainda por mais de um √≠ndice
	subscript(key:String, index:Int) -&gt; T {
		get {
			var string:String
			var stringStart:String
			var stringIndex:String.Index
			var currentIndex = 0
			for item in self.array {
				string = String(item)
				if string.isEmpty || string == "nil" {
					continue
				}
				stringIndex = string.startIndex.advancedBy(key.characters.count)
				stringStart = string.substringToIndex(stringIndex)
				if stringStart == key {
					if currentIndex == index {
						return item
					} else {
						currentIndex = currentIndex + 1
					}
				}
			}
			return ""
		}
	}

	var array:Array&lt;T&gt;

}</code
>

<p>Swift - main.swift</p>
<code class='swift'
>var subscriptCollection = SubscriptCollection&lt;String&gt;()
subscriptCollection[0] = "sundays are slow";
subscriptCollection[1] = "mondays are mediocre";
subscriptCollection[2] = "tuesday and wednesday too";
subscriptCollection[3] = "monday again";

// "tuesday and wednesday too"
print(subscriptCollection["tuesday"]);

// "monday again"
print(subscriptCollection["monday", 1]);</code
>

</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// TODO ver
// <a href='https://doc.rust-lang.org/std/ops/trait.Index.html'>https://doc.rust-lang.org/std/ops/trait.Index.html</a>
// <a href='https://doc.rust-lang.org/std/ops/trait.IndexMut.html'>https://doc.rust-lang.org/std/ops/trait.IndexMut.html</a>
</code
>
</div>

<div class='codeblock'>

<p>C# - IndexedCollection.cs</p>
<code class='cs'
>namespace MarcoLuglio.IndexerExample {

	public sealed class IndexedCollection&lt;T&gt; {

		public IndexedCollection() {
			this.array = new T[10];
		}

		// pode ser indexada por inteiros
		public T this[int index] {
			get {
				return this.array [index];
			}
			set {
				this.array [index] = value;
			}
		}

		// ou por outros tipos
		public T this[string key] {
			get {
				foreach(var item in this.array) {
					if (item.ToString().StartsWith(key)) {
						return item;
					}
				}
				// retorna valor padr√£o para o tipo
				// se n√£o encontrar um item pela chave
				return default(T);
			}
		}

		private T[] array;

	}

}</code
>

<p>C# - MainClass.cs</p>
<code class='cs'
>using System;

namespace MarcoLuglio.IndexerExample {

	public class MainClass {
		public static void Main(string[] args) {

			var indexedCollection = new IndexedCollection&lt;string&gt;();
			indexedCollection[0] = @"sunday";
			indexedCollection[1] = @"monday I'm in love";
			indexedCollection[2] = @"tuesday and wednesday too";

			// "tuesday and wednesday too"
			Console.WriteLine(indexedCollection[@"tuesday"]);

		}
	}

}</code
>

</div>

<div class='codeblock'>
<p>Java</p>
-
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>'use strict';

const indexingProxy = {

	get(alvo, propriedade, receiver) {

		// pode ser indexada por inteiros
		if (/^\d+$/.test(propriedade)) {
			return Reflect.get(alvo._array, propriedade, receiver);
		}

		// ou por outros tipos
		for (let valor of alvo._array) {
			if (valor.startsWith(propriedade)) {
				return valor;
			}
		}

		// retorna null
		// se n√£o encontrar um item pela chave
		return null;

	},

	set(alvo, propriedade, valor, receiver) {

		// pode ser indexada por inteiros
		if (/^\d+$/.test(propriedade)) {
			alvo._array[propriedade] = valor;
			return true;
		}

		// ou por outros tipos
		alvo._array.push(valor);
		return true;

	}

};

class Collection {
	constructor() {
		Object.defineProperty(this, '_array', {value: []});
	}
}

const collection = new Collection();
const indexedCollection = new Proxy(collection, indexingProxy);

indexedCollection[0] = "sunday";
indexedCollection[1] = "monday I'm in love";
indexedCollection[2] = "tuesday and wednesday too";

// "tuesday and wednesday too"
console.log(indexedCollection["tuesday"]);</code
>
</div>

</div>

<ol>
	<li>C# / Swift</li>
	<li>JavaScript</li>
	<li>C++</li>
</ol>

<p>C# possibilita a cria√ß√£o de indexers de maneira relativamente simples. Swift requer passos extras devido ao fato de que n√£o existe uma maneira r√°pida de obter o valor padr√£o de um tipo gen√©rico, mas isso √© compensado pelo fato de que √© simples utilizar mais de um √≠ndice com o operador <code class='swift'>[]</code>.
<br />JavaScript n√£o diferencia os operadores <code class='javascript'>.</code> e <code class='javascript'>[]</code>, mas se os utilizarmos ingenuamente, deixaremos o c√≥digo lento, criando propriedades nos objetos em tempo de execu√ß√£o. Por isso o uso de um <code class='javascript'>Proxy</code> se faz necess√°rio.
<br />C++ Tamb√©m requer um proxy, mas por outros motivos. O operador <code class='cpp'>[]</code> em C++ s√≥ retorna valores, ent√£o devemos retornar um proxy que possui uma refer√™ncia para a posi√ß√£o desejada na cole√ß√£o original, e por meio dele alterar o valor nessa posi√ß√£o. Para que isso seja poss√≠vel, o proxy tamb√©m deve ter alguns overloads de operadores, tornando tudo mais verborr√°gico e complicado do que nas outras linguagens.</p>

</section>



<section>

<h2 id='templateid'>Interface Bin√°ria C <span>Foreign Function Interface</span></h2>



<h3>Exportar para C</h3>

<div class='comparison'>

<div class='codeblock'>

	<div class='pair'>

		<div>
			<p>C++ - TabelaNutricional.hpp</p>
			<code class='cpp'
			>#pragma once

#ifdef __cplusplus
namespace MarcoLuglio {
namespace FFIExample {
extern "C" {
#endif

	struct TabelaNutricional {
		float valorEnergetico;
		float carboidratos;
		float proteinas;
		float gordurasTotais;
		float gordurasSaturadas;
		float gordurasTrans;
		float fibraAlimentar;
		float sodio;
	};

#ifdef __cplusplus
}
}
}
#endif</code
			>
		</div>

		<div>
			<p>C++ - TabelaNutricional.cpp</p>
			<code class='cpp'
			>#include "TabelaNutricional.hpp"

namespace MarcoLuglio {
namespace FFIExample {

	// TODO ver se esse arquivo
	// √© realmente necess√°rio

}
}</code
			>
		</div>

	</div>

	<div class='pair'>

		<div>
			<p>C++ - TabelaNutricionalBiblioteca.hpp</p>
			<code class='cpp'
			>#pragma once

#ifdef _MSC_VER // Visual Studio specific macro
#define DLLEXPORT __declspec(dllexport)
#else
#define DLLEXPORT __attribute__((visibility("default")))
#endif

#include "TabelaNutricional.hpp"

#ifdef __cplusplus
namespace MarcoLuglio {
namespace FFIExample {
extern "C" {
#endif

	DLLEXPORT struct TabelaNutricional calcular(float porcao);

#ifdef __cplusplus
}
}
}
#endif</code
			>
		</div>

		<div>
			<p>C++ - TabelaNutricionalBibliteca.cpp</p>
			<code class='cpp'
			>#include "TabelaNutricional.hpp"
#include "TabelaNutricionalBibliteca.hpp"

namespace MarcoLuglio {
namespace FFIExample {

	TabelaNutricional calcular(const float porcao) {

		TabelaNutricional tabela{};
		// ...
		return tabela;

	}

}
}</code
			>
		</div>

	</div>

</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>-</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>-</code
>
</div>

<div class='codeblock'>
<p>Rust - TabelaNutricional.rs</p>
<code class='rust'
>#[repr(C)]
pub struct TabelaNutricional {
	valorEnergetico: f32,
	carboidratos: f32,
	proteinas: f32,
	gordurasTotais: f32,
	gordurasSaturadas: f32,
	gordurasTrans: f32,
	fibraAlimentar: f32,
	sodio: f32
}

#[no_mangle]
pub extern fn calcular(porcao:f32) -&gt; TabelaNutricional {
	let mut tabela = TabelaNutricional{
		valorEnergetico: 1_f32,
		carboidratos: 1_f32,
		proteinas: 1_f32,
		gordurasTotais: 1_f32,
		gordurasSaturadas: 1_f32,
		gordurasTrans: 1_f32,
		fibraAlimentar: 1_f32,
		sodio: 2_f32
	};
	// TODO usar porcao
	return tabela;
}

// compilar com
// rustc --crate-type dylib TabelaNutricional.rs
// vai gerar libTabelaNutricional.dylib</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>-</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>-</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>-</code
>
</div>

</div>



<h3>Importar do C</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// usar LoadLibrary/GetProcAddress/FreeLibrary no Windows
// ou dlopen/dlsym/dlclose no Mac e Linux
// ou linkar as bibliotecas em tempo de compila√ß√£o
// ou adicionar as refer√™ncias nas IDEs respectivas</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>#[link(name = "TabelaNutricionalBiblioteca")]
extern "C" {
	fn calcular(porcao:f32) -&gt; i32;
}

fn main() {
	unsafe {
		calcular(20);
	}
}</code
>
</div>

<div class='codeblock'>
<p>C# - TabelaNutricionalBibliotecaNative.cs</p>
<code class='cs'
>// Adicionar a refer√™ncia ao arquivo na IDE e:

using System.Runtime.InteropServices;

namespace MarcoLuglio.FFIExample {

	[StructLayout(LayoutKind.Sequential)]
	public struct TabelaNutricional {
		public float valorEnergetico;
		public float carboidratos;
		public float proteinas;
		public float gordurasTotais;
		public float gordurasSaturadas;
		public float gordurasTrans;
		public float fibraAlimentar;
		public float sodio;
	};

	public static class SalarioBibliotecaNative {

		[DllImport(
			"TabelaNutricionalBiblioteca.dll",
			CallingConvention = CallingConvention.Cdecl,
			EntryPoint = @"calcular"
		)]
		public static extern TabelaNutricional calcular(float porcao);

	}

}</code
>
</div>

<div class='codeblock'>

<p>Java - TabelaNutricional.java</p>
<code class='java'
>package marcoLuglio.ffiExample;

public final class TabelaNutricional {
	public float valorEnergetico;
	public float carboidratos;
	public float proteinas;
	public float gordurasTotais;
	public float gordurasSaturadas;
	public float gordurasTrans;
	public float fibraAlimentar;
	public float sodio;
}</code
>

<p>Java - TabelaNutricionalBibliotecaNative.java</p>
<code class='java'
>package marcoLuglio.ffiExample;

public final class TabelaNutricionalBibliotecaNative {

	static {System.loadLibrary("TabelaNutricionalBiblioteca");}

	private native TabelaNutricional calcular(float porcao);

}</code
>

<p>C - ?.c</p>
<code class='c'
>// TODO</code
>

</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// No navegador n√£o existe, mas veja
// <a href='https://webassembly.github.io/'>Web Assembly</a>
// J√° usando node.js veja o <a href='https://github.com/node-ffi/node-ffi'>plug-in FFI</a></code
>
</div>

</div>



<ol>
	<li>C++ / Rust</li>
	<li>Objective-C / C#</li>
	<li>Swift</li>
	<li>Java</li>
	<li>JavaScript</li>
</ol>

<p>C++ e Rust s√£o os √∫nicos que conseguem exportar bibliotecas compat√≠veis com C, por se tratarem de linguagens nativas. C++ Possui grande preocupa√ß√£o com a compatibilidade com C, e pode misturar de maneira transparente blocos de c√≥digo em C.<br />
As bibliotecas geradas por Rust s√£o enormes se comparados com as do C++, para comportar as regras da linguagem.<br />
Objective-C √© constru√≠do tendo C como base. Portanto, assim como C++, pode usar C de maneira transparente. S√≥ n√£o pode exportar para C :(<br />
Swift?? TODO<br />
C# possui uma sintaxe limpa para interagir com <abbr title="Application Programming Interface">API</abbr>s em C<br />
Java pode at√© ser bonitinho dentro do arquivo Java, mas o arquivo C que interage com ele √© bastante complexo. Tanto que foram criadas ferramentas que geram parte deste arquivo automaticamente.<br />
JavaScript ainda n√£o chegou l√°.</p>



</section>



<!--
<section>

<h2 id='templateid'>Template</h2>

<div class='comparison'>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Kotlin</p>
<code class='kotlin'
>
</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>
</code
>
</div>

<div class='codeblock'>
<p><abbr title='Visual Basic for Applications'>VBA</abbr> / <abbr title='Visual Basic 6'>VB6</abbr></p>
<code class='visualbasic'
></code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>
-->

<!--
switch fallthrough
rust loop {}
swift lazy
c# explicit e implicit keywords
named breaks
goto?
enums
pass by reference, inout, ref, etc
unions?
guard e match
convers√£o de n√∫meros com ? : e com += ver https://blog.jooq.org/2014/11/03/10-things-you-didnt-know-about-java/
observer ou eventos customizados
default parameter values, compare strings, valores n√£o iniciados, null pointer exception, type erasure, linq, traits, extension methods, if (a = 1) if let while let, macros, floata == floatb ou Math.abs(floata - floatb) < 0.001

La√ßos for
Sobrecarga de fun√ß√£o
Pointers, references, pointer to references, pointer to pointer, cast pointers to references
Eventos e setTimeout
Observar objetos KVO, notification center, etc.
Enums

Requisi√ß√µes http


Certifica√ß√£o
Overload pode ter visibilidade diferente?
Operator mess?
Cast um tipo para string chama tostring?

Functional interface exemplo com m√©todos poss√≠veis default overwrite object etc.

Type erasure
-->

</body>
</html>