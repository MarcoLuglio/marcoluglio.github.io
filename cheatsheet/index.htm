<!DOCTYPE html>
<html
	xmlns='http://www.w3.org/1999/xhtml'
	lang='pt-BR'
	xml:lang='pt-br'
	>
<head>
	<title>Cheat Sheet</title>
	<meta charset='utf-8' />
	<link rel='stylesheet' href='css/main.css' />
	<script src='../tutorialjs/js/utils.js'></script>
	<script src='../tutorialjs/js/index.js'></script>
	<script src='../tutorialjs/js/highlighter.js'></script>
	<script src='js/extendedhighlighter.js'></script>
	<script src='js/home.js'></script>
</head>
<body>



<h1>Cheat Sheet <span>para Programadores Mobile</span></h1>

<p><strong>WORK IN PROGRESS ;)</strong></p>

<p>Artigo criado por necessidades práticas no desenvolvimento de aplicativos para dispositivos móveis. Fui parcialmente inspirado no <a rel='external nofollow' href='http://www.25hoursaday.com/CsharpVsJava.html'>artigo icônico de Dare Obasanjo comparando C# e Java</a>.</p>

<section>

<h2>Índice</h2>
<nav id='indice'>
</nav>

</section>



<section>

<h2 id='olamundo'>Olá Mundo</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++ - Olá Mundo - main.cpp</p>
<code class='cpp'
>// requer uma biblioteca para IO
#include &lt;iostream&gt;

// requer uma função main na raiz
int main(int argc, const char* argv[]) {
	std::cout &lt;&lt; "Olá Mundo";
	// requer um código de retorno
	return 0;
}</code
>
</div>

<div class='codeblock'>
<p>Objective-C - Olá Mundo - main.m</p>
<code class='objectivec'
>// requer uma biblioteca para IO
#import &lt;Foundation/Foundation.h&gt;

// requer uma função main
int main(int argc, const char* argv[]) {
	NSLog(@"Olá Mundo");
	// requer um código de retorno
	return 0;
}</code
>
</div>

<div class='codeblock'>
<p>Swift - Olá Mundo - main.swift</p>
<code class='swift'
>print("Olá Mundo")</code
>
</div>

<div class='codeblock'>
<p>Rust - Olá Mundo - mais.rs</p>
<code class='rust'
>// requer uma função main
fn main() {
	println!("Olá Mundo");
}</code
>
</div>

<div class='codeblock'>
<p>C# - Olá Mundo - OlaMundo.cs</p>
<code class='cs'
>public class OlaMundo {
	// requer um método estático main em uma classe
	public static void Main(string[] args) {
		System.Console.WriteLine("Olá Mundo");
	}
}</code
>
</div>

<div class='codeblock'>
<p>Java - Olá Mundo - OlaMundo.java</p>
<code class='java'
>public class OlaMundo {
	// requer um método estático main em uma classe
	public static void main(String[] args) {
		System.out.println("Olá Mundo");
	}
}</code
>
</div>

<div class='codeblock'>
<p>JavaScript - Olá Mundo - main.js</p>
<code class='javascript'
>console.log('Olá Mundo')</code
>
</div>

</div>

<ol>
	<li>Swift</li>
	<li>JavaScript</li>
	<li>Rust</li>
	<li>C# / Java</li>
	<li>C++ / Objective-C</li>
</ol>

<p>Swift é a mais simples de todas. Nem <code class='swift'>;</code> ela precisa, e seu uso nem é recomendado.<br />
JavaScript perde por pouco. Também não requer <code class='javascript'>;</code> embora ao contrário do que ocorre com Swift, seu uso seja recomendado. Seu <code class='javascript'>console.log</code> também é um pouco maior que o método <code class='swift'>print</code>.<br />
Rust ainda requer uma função <code class='rust'>main</code>, mas o retorno dela não precisa ser declarado explicitamente. Diferente das demais linguagens, usa um macro para IO, por isso <code class='rust'>print!</code> leva uma exclamação (não, não era porque eu estava entusiasmado quando escrevi o código).<br />
C# e Java são idênticos, ambos requerendo uma classe que contenha o método <code class='generic'>main</code>. Sentiu uma leve pressão para escrever orientado a objeto aqui? Também é recomendado que o nome do arquivo tenha o mesmo nome da classe.<br />
C++ e Objective-C são bastante parecidos pois possuem forte influência do C. São os mais verborrágicos.</p>

</section>



<section>

<h2 id='declaracaodevariaveis'>Declaração de Variáveis</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>auto x{5}; // tipo implícito
int x{5}; // tipo explícito
int x(5); // estilo antigo
int x = 5; // estilo c

const int z{5}; // constante
constexpr int x{5}; // expressão constante

int* x; // ponteiro</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>int x = 5; // variável
const int x = 5; // constante

int* x; // ponteiro</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>let x = 5 // tipo implícito
let x:Int = 5 // tipo explícito

var x = 5 // variável
let x = 5 // constante

let (x, y) = (1, 2) // desestruturação</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>let x = 5; // tipo implícito
let x:i32 = 5; // tipo explícito

let mut x = 5; // variável
let x = 5; // constante

let (x, y) = (1, 2); // desestruturação</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>var x = 5; // tipo implícito
int a = 5; // tipo explícito

var x = 5; // variável
const int x = 5; // constante

// tipo ignorado em tempo de compilação
dynamic x = 5;

// nomes válidos

var eu1;
var _ = "bem sucinto";
var _123 = "meio confuso";

// podemos ainda usar @ na frente
// do nome pra evitar colisões
// com palavras-chave e tipos
var @if = "muito confuso";
var @int = "muito confuso";</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>int x = 5; // variável
final int x = 5; // constante

// não precisa ser inicializada na declaração
final int x;
x = 5;</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>'use strict';

let x = 5; // tipo dinâmico
var x = 5; // estilo antigo

// lança exceção em modo estrito
// mas é aceito em modo normal
x = 5;

let x = 5; // variável
const x = 5; // constante

[x, y] = [1, 2]; // desestruturação</code
>
</div>

</div>

<ol>
	<li>Rust / Swift</li>
	<li>C#</li>
	<li>JavaScript</li>
	<li>C++</li>
	<li>Java</li>
	<li>Objective-C</li>
</ol>

<p>Quem diria que um tópico tão simples seria tão diverso entre as linguagens?</p>
<p>Rust e Swift são quase idênticos, mudando apenas uma coisa. Swift faz a declaração de variáveis e constantes serem <q>equivalentes</q>, enquanto Rust faz a declaração de variávies mais difíceis que de constantes. Mas porque Swift utilizou <code class='swift'>let</code> ao invés de <code class='cpp'>const</code>?<br />
JavaScript é a única das linguagens comparadas que possibilita mudar os tipos das variáveis dinamicamente. Sua sintaxe de desestruturação não permite declarar e atribuir um valor ao mesmo tempo. As variáveis já devem ser declaradas antes da atribuição. JavaScript possui um estilo legado de declaracão, que cria variáveis com regras de escopo diferentes do que a maioria dos programadores espera, além de possuir um modo estrito para coibir práticas legadas.<br />
C++ é o que tem mais legado de coisas que não deram certo, e sua última sintaxe pode ter regras mais seguras, mas certamente é bastante estranha. Tipagem implícita requer a palavra <code class='cpp'>auto</code>. Para aumentar a performance de nosso código, temos o recurso <code class='cpp'>constexpr</code>.<br />
Java parou no tempo e Objective-C também (mas cá entre nós, a Apple pelo menos admite). Porém, Objective-c ainda tem tipos ponteiro para deixar as coisas mais confusas.</p>

</section>



<section>

<h2 id='modulos'>Módulos</h2>

<div class='comparison large'>

<div class='codeblock'>

	<div class='pair'>

		<div>

<p>C++ Microsoft - DentroDoModulo.hpp</p>
<code class='cpp'
>
#pragma once

namespace marcoluglio {
	class DentroDoModulo {};
}</code
>

		</div>

		<div>

<p>C++ - DentroDoModulo.cpp</p>
<code class='cpp'
>
#include "DentroDoModulo.hpp"

namespace marcoluglio {
	//
}</code
>

		</div>

	</div>

<p>C++ - main.cpp</p>
<code class='cpp'
>#include "DentroDoModulo.hpp"

int main(int argc, const char* argv[]) {
	using marcoluglio::DentroDoModulo;
	DentroDoModulo meuObjeto = DentroDoModulo();
}</code
>

</div>

<div class='codeblock'>

	<div class='pair'>

		<div>

<p>C++ - DentroDoModulo.hpp</p>
<code class='cpp'
>#ifndef MARCOLUGLIO_DENTRODOMODULO_HPP_INCLUDED
#define MARCOLUGLIO_DENTRODOMODULO_HPP_INCLUDED

namespace marcoluglio {
	class DentroDoModulo {};
}

#endif /* MARCOLUGLIO_DENTRODOMODULO_HPP_INCLUDED */</code
>

		</div>

		<div>

<p>C++ - DentroDoModulo.cpp</p>
<code class='cpp'
>
#include "DentroDoModulo.hpp"

namespace marcoluglio {
	//
}</code
>

		</div>

	</div>

<p>C++ - main.cpp</p>
<code class='cpp'
>#include "DentroDoModulo.hpp"

int main(int argc, const char* argv[]) {
	using marcoluglio::DentroDoModulo;
	DentroDoModulo meuObjeto = DentroDoModulo();
}</code
>

</div>

<div class='codeblock'>

	<div class='pair'>

		<div>

<p>Objective-C - MLGDentroDoModulo.h</p>
<code class='objectivec'
>
#import &lt;Foundation/Foundation.h&gt;

@interface MLGDentroDoModulo : NSObject
	//
@end

</code
>

		</div>

		<div>

<p>Objective-C - MLGDentroDoModulo.m</p>
<code class='objectivec'
>
#import "MLGDentroDoModulo.h"

@implementation MLGDentroDoModulo
	//
@end</code
>

		</div>

	</div>

<p>Objective-C - main.m</p>
<code class='objectivec'
>#import &lt;Foundation/Foundation.h&gt;
#import "MLGDentroDoModulo.h"

int main(int argc, const char* argv[]) {
	MLGDentroDoModulo* meuObjeto;
	meuObjeto = [[MLGDentroDoModulo alloc] init];
	return 0;

	// não possui namespaces
	// a utilização de prefixos com 3 letras
	// ou mais nas classes é a alternativa
	// recomendada

}</code
>

</div>

<div class='codeblock'>
<p>Swift - DentroDoModulo.swift</p>
<code class='swift'
>// a criação de namespaces é implícita
// para cada módulo

// um módulo é um agrupamento macro, bem
// diferente do que se utiliza nas
// outras linguagens

// ele abrange um target inteiro de
// compilação como um framework,
// uma biblioteca ou um executável

import UIKit

class DentroDoModulo: UIViewController {
}</code
>

<p>Swift - main.swift</p>
<code class='swift'
>let meuObjeto = DentroDoModulo()</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>mod
</code
>
<p>Rust</p>
<code class='rust'
>use
</code
>
</div>

<div class='codeblock'>
<p>C# - DentroDoModulo.cs</p>
<code class='cs'
>namespace marcoluglio {
	public class DentroDoModulo { /**/ }
}</code
>
<p>C# - main.cs</p>
<code class='cs'
>using marcoluglio;

class MainClass {
	public static void Main(string[] args) {
		DentroDoModulo meuObjeto;
		meuObjeto = new DentroDoModulo();
	}
}</code
>
</div>

<div class='codeblock'>
<p>Java - marcoluglio/DentroDoModulo.java</p>
<code class='java'
>package marcoluglio;

public class DentroDoModulo { /**/ }</code
>
<p>Java - main.java</p>
<code class='java'
>import marcoluglio.DentroDoModulo;

public class OlaMundo {
	public static void main(String[] args) {
		DentroDoModulo meuObjeto;
		meuObjeto = new DentroDoModulo();
	}
}</code
>
</div>

<div class='codeblock'>
<p>JavaScript compatibilidade</p>
<code class='javascript'
>'use strict';

define('dentroDoModulo', () => {
	const DentroDoModulo = class DentroDoModulo() { /**/ }
	return DentroDoModulo;
});

define(['dentroDoModulo'], (DentroDoModulo) => {
	let meuObjeto = new DentroDoModulo();
});
</code
>
</div>

<div class='codeblock'>
<p>JavaScript - DentroDoModulo.js</p>
<code class='javascript'
>'use strict';

export default class DentroDoModulo { /**/ }</code
>

<p>JavaScript - main.js</p>
<code class='javascript'
>'use strict';

import DentroDoModulo from 'DentroDoModulo';

let meuObjeto = new DentroDoModulo();</code
>
</div>

</div>

<ol>
	<li>C# / Java</li>
	<li>JavaScript</li>
	<li>Rust</li>
	<li>C++</li>
	<li>Swift</li>
	<li>Objective-C</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='stackheap'>Stack e Heap</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// TODO
// tipos na stack por padrão

// tipos com new na heap

// enums?
// closures?
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// TODO
// structs na stack?
// e classes?
// enums?
// closures? tem closures?
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// TODO
// primtive on stack
// structs ?? implementation dependent??
// classes and closures on the heap
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// TODO
// &amp;'static str statically allocated lives inside the program binary code
// stack by default
// heap
// String
// Box&lt;T&gt;
// Vec&lt;T&gt;
// growable on heap
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// tipos valor na stack

// tipos primitivos na stack
int i = 10;

// enums na stack

// structs às vezes na stack
AStruct a;
Point p;

// nullables na stack

// tipos de referência na heap

// class, interface, array e delegate
string a = "Na heap"; // TODO verificar string heap
object o = new object();</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// tipos primitivos na stack
int i = 10;

// tipos de referência na heap
String s = "Na heap"; // TODO verificar string heap
Object o = new Object();
// enums tb?</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// Não existe uma definição
// na especificação
// A máquina virtual pode ou não
// alocar tipos primitivos
// e tipos de referência
// tanto na stack quanto na heap
</code
>
</div>

</div>

<ol>
	<li>C++ / Rust</li>
	<li>Objective-C / Swift / C#</li>
	<li>Java</li>
	<li>JavaScript</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='nullnullable'>Null e Nullable</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// tipo optional é preferível
// ao ponteiro nullable

std::optional&lt;int&gt; k; // C++17
boost::optional&lt;int&gt; l; // boost

// PONTEIROS
// =========

int* m = nullptr; // C++11

// tipo nullptr_t só pode ser nullptr
// não pode receber nenhum outro valor
std::nullptr_t n = nullptr; // C++11

// versões antigas usam o tipo NULL
// que é 0 por baixo dos panos
int* o = NULL; // old</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// nil object
// Nil class
// NSNull singleton to represent null

// PONTEIROS
// =========

int* o = NULL;</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// optionals devem ter o tipo especificado
// em sua declaração
var k:Int? = nil
var l:AClass? = nil
let m = l?.propriedade // m recebe nil
let n = l!.propriedade // lança erro se l for nil

// nil coalescing operator
let o = k ?? 10 // o será do tipo Int

// ok mas não é idiomático
let p = k != nil ? k : 10 // p será do tipo Int?

// PS: nullable é chamado de optional
// e null é chamado de nil em Swift</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// não existem tipos nullable
// mas existe um tipo std::Option&lt;T&gt;
// que pode conter None ou Some()

// tipo explícito
let mut k:Option&lt;i32&gt; = None;
let mut l:Option&lt;AStruct&gt; = None;

// tipo implícito Option&lt;i32&gt;
let mut m = None::&lt;i32&gt;;
let mut n = Some(10);

// erro, não pode passar um valor diretamente
// tem que usar Some(valor)
let mut o:Option&lt;i32&gt; = 10;

// não possui operador específico para Option
let p = match n { // p será do tipo i32
	Some(some) => some,
	None => 10,
};

// ok mas panic se for None
let q = n.unwrap(); // q será do tipo i32

// PONTEIROS
// =========

// TODO
let p:*const i32 = ptr::null();
let p:*mut i32 = ptr::null();
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// nullable não pode ser usado com var
// um tipo deve ser especificado
int? k = null;
AClass? l = null;
int? m = l?.propriedade; // C# 6
int? m = (l != null) ? l.propriedade : null;

// null coalescing operator
var n = k ?? 10; // n será do tipo int

// ok mas não é idiomático
var o = (k != null) ? k : 10; // o será do tipo int?</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// tipos primitivos não podem ser nullable
int a = null; // erro

// qualquer tipo de referência é nullable
Integer k = null;
AClass l = null;
Integer m = (l != null) ? l.propriedade : null;

// não possui operador específico para null
int n = (k != null) ? k : 10; // n aceita ser do tipo int ou Integer</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>'use strict';

// qualquer tipo é sempre nullable
let k = null;
let l = (k &amp;&amp; k.propriedade) ? k.propriedade : null;

// null coalescing operator
let m = k || 10;

// ok mas não é idiomático
let n = (k || k === 0) ? k : 10;</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section class='tiposprimitivos'>

<h2 id='tiposnumericos'>Tipos Primitivos Numéricos</h2>



<h3 id='integer'>Integer</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>char</td><td>8 bits?</td></tr>
		<tr><td>short</td><td>16 bits ou mais</td></tr>
		<tr><td>int</td><td>16 bits ou mais</td></tr>
		<tr><td>long</td><td>32 bits ou mais</td></tr>
		<tr><td>long long</td><td>64 bits ou mais</td></tr>
	</tbody>
</table>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>int8_t</td><td>8 bits</td></tr>
		<tr><td>int16_t</td><td>16 bits</td></tr>
		<tr><td>int32_t</td><td>32 bits</td></tr>
		<tr><td>int64_t</td><td>64 bits</td></tr>
	</tbody>
</table>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>int_least8_t</td><td>8 bits ou mais</td></tr>
		<tr><td>int_least16_t</td><td>16 bits ou mais</td></tr>
		<tr><td>int_least32_t</td><td>32 bits ou mais</td></tr>
		<tr><td>int_least64_t</td><td>64 bits ou mais</td></tr>
	</tbody>
</table>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>int_fast8_t</td><td>8 bits ou mais</td></tr>
		<tr><td>int_fast16_t</td><td>16 bits ou mais</td></tr>
		<tr><td>int_fast32_t</td><td>32 bits ou mais</td></tr>
		<tr><td>int_fast64_t</td><td>64 bits ou mais</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Objective-C</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>char</td><td>8 bits?</td></tr>
		<tr><td>short</td><td>16 bits?</td></tr>
		<tr><td>int</td><td>16 bits?</td></tr>
		<tr><td>long</td><td>32 bits?</td></tr>
		<tr><td>long long</td><td>64 bits?</td></tr>
	</tbody>
</table>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>int8_t</td><td>8 bits</td></tr>
		<tr><td>int16_t</td><td>16 bits</td></tr>
		<tr><td>int32_t</td><td>32 bits</td></tr>
		<tr><td>int64_t</td><td>64 bits</td></tr>
	</tbody>
</table>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>int_least8_t</td><td>8 bits ou mais</td></tr>
		<tr><td>int_least16_t</td><td>16 bits ou mais</td></tr>
		<tr><td>int_least32_t</td><td>32 bits ou mais</td></tr>
		<tr><td>int_least64_t</td><td>64 bits ou mais</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Swift (Obj-C)</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>CChar</td><td>8 bits</td></tr>
		<tr><td>CShort</td><td>16 bits</td></tr>
		<tr><td>CInt</td><td>16 bits</td></tr>
		<tr><td>CLong</td><td>32 bits</td></tr>
		<tr><td>CLongLong</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Swift</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>Int8</td><td>8 bits</td></tr>
		<tr><td>Int16</td><td>16 bits</td></tr>
		<tr><td>Int32</td><td>32 bits</td></tr>
		<tr><td>Int64</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Rust</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>i8</td><td>8 bits</td></tr>
		<tr><td>i16</td><td>16 bits</td></tr>
		<tr><td>i32</td><td>32 bits</td></tr>
		<tr><td>i64</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>C#</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>sbyte</td><td>8 bits</td></tr>
		<tr><td>short</td><td>16 bits</td></tr>
		<tr><td>int</td><td>32 bits</td></tr>
		<tr><td>long</td><td>64 bits</td></tr>
		<tr><td>decimal</td><td>128 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Java</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>byte</td><td>8 bits</td></tr>
		<tr><td>short</td><td>16 bits</td></tr>
		<tr><td>int</td><td>32 bits</td></tr>
		<tr><td>long</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

</div>



<h3 id='unsignedinteger'>Unsigned Integer</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>char</td><td>8 bits?</td></tr>
		<tr><td>unsigned short</td><td>16 bits ou mais</td></tr>
		<tr><td>unsigned int</td><td>16 bits ou mais</td></tr>
		<tr><td>unsigned long</td><td>32 bits ou mais</td></tr>
		<tr><td>unsigned long long</td><td>64 bits ou mais</td></tr>
	</tbody>
</table>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>uint8_t</td><td>8 bits</td></tr>
		<tr><td>uint16_t</td><td>16 bits</td></tr>
		<tr><td>uint32_t</td><td>32 bits</td></tr>
		<tr><td>uint64_t</td><td>64 bits</td></tr>
	</tbody>
</table>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>uint_least8_t</td><td>8 bits ou mais</td></tr>
		<tr><td>uint_least16_t</td><td>16 bits ou mais</td></tr>
		<tr><td>uint_least32_t</td><td>32 bits ou mais</td></tr>
		<tr><td>uint_least64_t</td><td>64 bits ou mais</td></tr>
	</tbody>
</table>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>uint_fast8_t</td><td>8 bits ou mais</td></tr>
		<tr><td>uint_fast16_t</td><td>16 bits ou mais</td></tr>
		<tr><td>uint_fast32_t</td><td>32 bits ou mais</td></tr>
		<tr><td>uint_fast64_t</td><td>64 bits ou mais</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Objective-C</p>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>unsigned char</td><td>8 bits?</td></tr>
		<tr><td>unsigned short</td><td>16 bits?</td></tr>
		<tr><td>unsigned int</td><td>16 bits?</td></tr>
		<tr><td>unsigned long</td><td>32 bits?</td></tr>
		<tr><td>unsigned long long</td><td>64 bits?</td></tr>
	</tbody>
</table>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>uint8_t</td><td>8 bits</td></tr>
		<tr><td>uint16_t</td><td>16 bits</td></tr>
		<tr><td>uint32_t</td><td>32 bits</td></tr>
		<tr><td>uint64_t</td><td>64 bits</td></tr>
	</tbody>
</table>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>uint_least8_t</td><td>8 bits ou mais</td></tr>
		<tr><td>uint_least16_t</td><td>16 bits ou mais</td></tr>
		<tr><td>uint_least32_t</td><td>32 bits ou mais</td></tr>
		<tr><td>uint_least64_t</td><td>64 bits ou mais</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Swift (Obj-C)</p>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>CUnsignedChar</td><td>8 bits</td></tr>
		<tr><td>CUnsignedShort</td><td>16 bits</td></tr>
		<tr><td>CUnsignedInt</td><td>16 bits</td></tr>
		<tr><td>CUnsignedLong</td><td>32 bits</td></tr>
		<tr><td>CUnsignedLongLong</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Swift</p>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>UInt8</td><td>8 bits</td></tr>
		<tr><td>UInt16</td><td>16 bits</td></tr>
		<tr><td>UInt32</td><td>32 bits</td></tr>
		<tr><td>UInt64</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Rust</p>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>u8</td><td>8 bits</td></tr>
		<tr><td>u16</td><td>16 bits</td></tr>
		<tr><td>u32</td><td>32 bits</td></tr>
		<tr><td>u64</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>C#</p>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>byte</td><td>8 bits</td></tr>
		<tr><td>ushort</td><td>16 bits</td></tr>
		<tr><td>uint</td><td>32 bits</td></tr>
		<tr><td>ulong</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Java</p>
-
</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

</div>



<h3 id='pointerinteger'>Pointer Sized Integer</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>

<table>
	<caption>Pointer Sized Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>intptr_t</td><td>Depende do hardware</td></tr>
		<tr><td>uintptr_t</td><td>Depende do hardware</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Objective-C</p>

<table>
	<caption>Pointer Sized Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>NSInteger</td><td>32 ou 64 bits</td></tr>
		<tr><td>NSUInteger</td><td>32 ou 64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Swift (Obj-C)</p>
-
</div>

<div class='codeblock'>
<p>Swift</p>

<table>
	<caption>Pointer Sized Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>Int</td><td>Depende do Hardware</td></tr>
		<tr><td>UInt</td><td>Depende do Hardware</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Rust</p>

<table>
	<caption>Pointer Sized Integer</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>isize</td><td>Depende do hardware</td></tr>
		<tr><td>usize</td><td>Depende do hardware</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>C#</p>
-
</div>

<div class='codeblock'>
<p>Java</p>
-
</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

</div>



<h3 id='floatingpoint'>Floating Point</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>

<table>
	<caption>Floating Point</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>float</td><td>?</td></tr>
		<tr><td>double</td><td>?</td></tr>
	</tbody>
</table>

<table>
	<caption>Floating Point</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>long double</td><td>?</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Objective-C</p>

<table>
	<caption>Floating Point</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>float</td><td>?</td></tr>
		<tr><td>double</td><td>?</td></tr>
	</tbody>
</table>

<table>
	<caption>Floating Point</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>long double</td><td>?</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Swift (Obj-C)</p>

<table>
	<caption>Floating Point (IEEE-754)</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>CFloat</td><td>32 bits</td></tr>
		<tr><td>CDouble</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Swift</p>

<table>
	<caption>Floating Point (IEEE-754)</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>Float</td><td>32 bits</td></tr>
		<tr><td>Double</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Rust</p>

<table>
	<caption>Floating Point (IEEE-754)</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>f32</td><td>32 bits</td></tr>
		<tr><td>f64</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>C#</p>

<table>
	<caption>Floating Point (IEEE 754)</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>float</td><td>32 bits</td></tr>
		<tr><td>double</td><td>64 bits</td></tr>
	</tbody>
</table>

<table>
	<caption>Floating Point</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>decimal</td><td>128 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Java</p>

<table>
	<caption>Floating Point (IEEE 754)</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>float</td><td>32 bits</td></tr>
		<tr><td>double</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>JavaScript</p>

<table>
	<caption>Floating Point (IEEE 754)</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>Number</td><td>64 bits</td></tr>
	</tbody>
</table>

</div>

</div>



<h2 id='outrostiposnumericos'>Tipos Numéricos Não Primitivos</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
-
</div>

<div class='codeblock'>
<p>Objective-C</p>
<table>
	<caption>Numeric</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>NSNumber</td><td>cluster de tipos</td></tr>
	</tbody>
</table>
</div>

<div class='codeblock'>
<p>Swift (Obj-C)</p>
-
</div>

<div class='codeblock'>
<p>Swift</p>
<table>
	<caption>Floating Point</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>Float80</td><td>80 bits</td></tr>
	</tbody>
</table>
</div>

<div class='codeblock'>
<p>Rust</p>
<table>
	<caption>Floating Point</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>num::bigint::BigInt</td><td>?</td></tr>
		<tr><td>num::bigint::BigUint</td><td>?</td></tr>
	</tbody>
</table>
</div>

<div class='codeblock'>
<p>C#</p>
<table>
	<caption>Numeric</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>BigInteger</td><td>?</td></tr>
		<tr><td>Complex</td><td>?</td></tr>
	</tbody>
</table>
</div>

<div class='codeblock'>
<p>Java</p>
<table>
	<caption>Numeric</caption>
	<thead>
		<tr><th>tipo</th><th>tamanho</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>BigInteger</td><td>?</td></tr>
		<tr><td>BigDecimal</td><td>?</td></tr>
	</tbody>
</table>
</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

</div>



<ol>
	<li>Rust</li>
	<li>Swift</li>
	<li>C#</li>
	<li>Java</li>
	<li>C++</li>
	<li>Objective-C</li>
	<li>JavaScript</li>
</ol>

<p>Rust nomeia claramente os tipos numéricos que usa, além de usar nomes curtos.<br />
Swift prefere ser um pouco mais conservador e utilizar nomes como <code class='swift'>Int</code> e <code class='swift'>Double</code>. Possui também tipos para compatibilidade com as <abbr>API</abbr>s em C e Objective-C.<br />
C# mantém os nomes herdados do C (embora seja possível criar <em>type aliases</em> por arquivo). Notem a inconsistência com <code class='cs'>sbyte</code> e <code class='cs'>byte</code> devido a esta decisão. C# possui um tipo de 128 bits. Como roda numa máquina virtual, não possui tipos com tamanhos de memória como Rust e Swift. Não sei ao certo como é feito com <em>Native</em> .NET.<br />
Java não possui tipos sem sinal.<br />
C++ possui uma leve melhoria em relação à C, mas ainda é bem extenso.<br />
Objective-C mistura tipos de C e os próprios, fazendo uma salada só. Os tipos que ele herda de C não possuem tamanho fixo. Existe apenas a garantia de que <code class='objectivec'>short &lt;= int &lt;= long &lt;= long long</code>. Mesma coisa vale para <code class='objectivec'>float &lt;= double &lt;= long double</code>. Então existem tipos de tamanho fixo criados na especificacão C99 e os tipos incluídos pelo framework da Apple.<br />
JavaScript só possui um tipo numérico.</p>
<p>Notem que existe uma divergência entre C++ e Objective-C e as demais linguagens em relação à nomeclatura. Para as duas linguagens, <code class='cpp'>int</code> e <code class='cpp'>long</code> possuem tamanhos diferentes das demais. Por isso, ponto para as linguagens que indicam explicitamente o tamanho dos tipos no próprio nome.</p>

</section>



<section class='tiposprimitivos'>

<h2 id='boxtiposnumericos'>Boxing de Tipos Primitivos Numéricos</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
-
</div>

<div class='codeblock'>
<p>Objective-C</p>
<table>
	<caption>Numeric</caption>
	<thead>
		<tr><th>tipo</th><th>classe</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>?</td><td>NSNumber</td></tr>
	</tbody>
</table>
</div>

<div class='codeblock'>
<p>Swift</p>
-
</div>

<div class='codeblock'>
<p>Rust</p>
-
</div>

<div class='codeblock'>
<p>C#</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>struct</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>sbyte</td><td>SByte</td></tr>
		<tr><td>short</td><td>Int16</td></tr>
		<tr><td>int</td><td>Int32</td></tr>
		<tr><td>long</td><td>Int64</td></tr>
		<tr><td>decimal</td><td>Decimal</td></tr>
	</tbody>
</table>

<table>
	<caption>Unsigned Integer</caption>
	<thead>
		<tr><th>tipo</th><th>classe</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>byte</td><td>Byte</td></tr>
		<tr><td>ushort</td><td>UInt16</td></tr>
		<tr><td>uint</td><td>UInt32</td></tr>
		<tr><td>ulong</td><td>UInt64</td></tr>
	</tbody>
</table>

<table>
	<caption>Floating Point (IEEE 754)</caption>
	<thead>
		<tr><th>tipo</th><th>classe</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>float</td><td>Single</td></tr>
		<tr><td>double</td><td>Double</td></tr>
	</tbody>
</table>

<table>
	<caption>Floating Point</caption>
	<thead>
		<tr><th>tipo</th><th>classe</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>decimal</td><td>Decimal</td></tr>
	</tbody>
</table>

</div>

<div class='codeblock'>
<p>Java</p>

<table>
	<caption>Signed Integer</caption>
	<thead>
		<tr><th>tipo</th><th>classe</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>byte</td><td>Byte</td></tr>
		<tr><td>short</td><td>Short</td></tr>
		<tr><td>int</td><td>Integer</td></tr>
		<tr><td>long</td><td>Long</td></tr>
	</tbody>
</table>

<table>
	<caption>Floating Point (IEEE 754)</caption>
	<thead>
		<tr><th>tipo</th><th>classe</th></tr>
	</thead>
	<tfoot>
		<tr><td colspan='2'></td></tr>
	</tfoot>
	<tbody>
		<tr><td>float</td><td>Float</td></tr>
		<tr><td>double</td><td>Double</td></tr>
	</tbody>
</table>
</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='literaisnumericas'>Literais Numéricas</h2>



<h3 id='literaisdecimaisinteiros'>Decimais Inteiros</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// int32_t (x64 LP64)
auto i1{1};
auto i2{-1};

// uint32_t (x64 LP64)
auto u1{1u};
auto u2{2'147'483'648U};


// int64_t (x64 LP64)
auto l1{2'147'483'648};
auto l2{-2'147'483'649};
auto l3{1l};
auto l4{1L};
auto l5{1ll};
auto l6{1LL};

// uint64_t (x64 LP64)
auto ul1{9'223'372'036'854'775'808};
auto ul2{1ul};
auto ul3{1UL};
auto ul4{1ull};
auto ul5{1ULL};</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// Int (x64)
let i1 = 1
let i2 = -1
let i3 = 2_147_483_648
let i4 = -2_147_483_649;












// UInt (x64)
let u1:UInt = 9_223_372_036_854_775_808

// lança exceção
// does not fit inside Int (x64)
let e1 = 9_223_372_036_854_775_808
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// i8
let i81 = 1_i8;
let i82 = -1i8;

// u8
let u81 = 1_u8;

// i16
let i161 = 1i16;
let i162 = -1_i16;

// u16
let u161 = 1u16;

// i32
let i1 = 1;
let i2 = -1;
let i3 = 1_i32;

// avisa overflow -2147483648
let i4:i32 = 2_147_483_648;
let i5 = 2_147_483_648_i32;
let i6 = 2_147_483_648;

// avisa underflow 2147483647
let i7:i32 = -2_147_483_649;
let i8 = -2_147_483_649_i32;
let i9 = -2_147_483_649;

// u32
let u1 = 2_147_483_648_u32;

// i64
let i641 = 1_i64;
let i642 = -1_i64;

// u64
let u641 = 1_u64;            </code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// int
var i1 = 1;
var i2 = -1;

// uint
var u1 = 1u;
var u2 = 2147483648U;
var u3 = 2147483648;

// long
var l1 = 2147483648L;
var l2 = -2147483649;
var l3 = -2147483649L;
var l4 = 1l;
var l5 = 1L;


// ulong
// terminal com ul ou lu
// TODO                      </code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// int
Object i1 = 1;
Object i2 = -1;






// long
Object l1 = 2_147_483_648l;
Object l2 = -2_147_483_649L;
Object l3 = 1l;
Object l4 = 1L;


// lança exceção
// integer number too large
Object l5 = 9_223_372_036_854_775_808L;</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
-
</div>

</div>



<h3 id='literaisdecimaisfloatingpoint'>Decimais Floating Point</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
                                    </code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// Float
let f1:Float = 1

// Double
let d1 = 1.0
let d2 = 0.7 // não aceita .7          </code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// f32 (float)
let f1 = 1f32;


// f64 (double)
let d1 = 1f64;
let d2 = 1.0;                </code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// float
var f1 = 1f;
var f2 = 1F;

// double
var db1 = 1d;
var db2 = 1D;
var db3 = 1.0;
var db4 = .7;

// decimal
var dc = 1m;                 </code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// float
Object f1 = 1f;
Object f2 = 1F;

// double
Object d1 = 1d;
Object d2 = 1D;
Object f3 = 1.0;
Object f4 = .7;              </code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// double
let d1 = 1;
let d2 = -1;
let d3 = 2147483648;
let d4 = -2147483649;
let d5 = 1.0;
let d6 = .7;                 </code
>
</div>

</div>



<h3 id='notacoesnumericas'>Notações</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
                                    </code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>// notação científica
let c1 = 1e0
let c2 = 1e-1
let c3 = -0.7_e-2

// notação binária
let b1 = 0b0000_0001
let b2 = -0b0000_0010

// notação octal
let o1 = 0o01234567
let o2 = -0o1234567

// notação hexadecimal
let cor = 0xff_00_00
let x1 = -0x0123456789ABCDEF

// notação hexadecimal científica
let xc1 = 0xff0000p0
let xc2 = -0x0123456789ABCDEF_p9       </code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// notação científica
let c1 = 1e_0;
let c2 = 1e-1;
let c3 = -0.7_e-2;

// notação binária
let b1 = 0b_0000_0001;
let b2 = -0b0000_0010;

// notação octal
let o1 = 0o_01234567;
let o2 = -0o1234567;

// notação hexadecimal
let cor = 0x_ff_00_00;
let x1 = -0x0123456789ABCDEF;

// TODO misturar notações
// com sufixos</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>// notação científica
double c1 = 1e0;
double c2 = 1e-1;
double c3 = -.7e-2;

// C# 7 deverá ter
// <a rel='external nofollow' href='https://github.com/dotnet/roslyn/issues/215'>literais binárias</a>
// e <a rel='external nofollow' href='https://github.com/dotnet/roslyn/issues/216'>separadores de digitos</a>





// notação hexadecimal
int cor = 0xff0000;
int x1 = -0X0123456789ABCDEF;

// TODO misturar notações
// com sufixos</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>// notação científica
double c1 = 1e0;
double c2 = 1e-1;
double c3 = -.7e-2;

// notação binária
int b1 = 0b0000_0001;
int b2 = -0B00000010;

// notação octal
int o1 = 01_234_567;
int o2 = -01234567;

// notação hexadecimal
int cor = 0xff_00_00;
int x1 = -0X0123456789ABCDEF;

// TODO misturar notações
// com sufixos</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// notação científica
let c1 = 1e0;
let c2 = 1e-1;
let c3 = -.7e-2;

// notação binária
let b1 = 0B00000001;
let b2 = -0b00000010;

// notação octal
let o1 = 0o01234567;
let o2 = -0O1234567;

// notação hexadecimal
let cor = 0xff0000;
let x1 = -0X0123456789ABCDEF;</code
>
</div>

</div>



<h3 id='paddingnumerico'>Padding</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>// números começando com 0
// são considerados notação
// octal                            </code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>let i1 = 10
let p1 = 01
let p2 = 00.1                          </code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>let i1 = 10;
let p1 = 01;
let p2 = 00.1;               </code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>var i1 = 10;
var p1 = 01;
var p1 = 00.1;               </code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='javascript'
>// números começando com 0
// são considerados notação
// octal                     </code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>let i1 = 10;
let p1 = 01;                 </code
>
</div>

</div>



<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='conversoesnumericas'>Conversão entre Tipos Numéricos</h2>



<h3 id='operacoesnumericas'>Operações</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>unchecked {

int i32_1 = 2;
int i32_2 = 4;
int i32_min = Int32.MinValue;
int i32_max = Int32.MaxValue;

long i64 = i32_max; // implicit conversion 2147483647 (long)
short i16 = (short)i32_max; // explicit conversion -1 (short)

var adicao1 = i32_max + 1; // -2147483648 (int)
var adicao2 = i64 + i32_1; // 2147483649 (long)
var adicao3 = i64 + i32_max; // 4294967294 (long)

var subtracao1 = i32_min - 1; // 2147483647 (int)
var subtracao2 = i16 - i32_1; // -3 (int)
var subtracao3 = i16 - i32_max; // -2147483648 (int)

var multiplicacao1 = i32_1 * i32_2; // 8 (int)
var multiplicacao2 = i32_max * i32_1; // -2 (int)
var multiplicacao3 = i32_1 * i64; // 4294967294 (long)

var divisao1 = i32_2 / i32_1; // 2 (int)
var divisao2 = i32_1 / i32_2; // 0 (int)
var divisao3 = i16 / i32_1; // 0 (int)

}



// conversão implícita se o número couber no outro
// byte -> int, uint ou float por exemplo
// sbyte -> int ou float

// conversão explícita
// entre integrals
// entre floats
// de floats para integrals

// tipo numerico não converte pra char

/*

When you convert from a double or float value to an integral type,
the value is truncated. If the resulting integral value is outside
the range of the destination value, the result depends on the
overflow checking context.

When you convert double to float, the double value is rounded
to the nearest float value. If the double value is too small
or too large to fit into the destination type, the result
will be zero or infinity.

When you convert decimal to float or double, the decimal value is rounded
to the nearest double or float value.
*/</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>

int i32_1 = 2;
int i32_2 = 4;
int i32_min = Integer.MIN_VALUE;
int i32_max = Integer.MAX_VALUE;

long i64 = i32_max; // implicit conversion 2147483647 (long)
short i16 = (short)i32_max; // explicit conversion -1 (short)

Object adicao1 = i32_max + 1; // -2147483648 (int)
Object adicao2 = i64 + i32_1; // 2147483649 (long)
Object adicao3 = i64 + i32_max; // 4294967294 (long)

Object subtracao1 = i32_min - 1; // 2147483647 (int)
Object subtracao2 = i16 - i32_1; // -3 (int)
Object subtracao3 = i16 - i32_max; // -2147483648 (int)

Object multiplicacao1 = i32_1 * i32_2; // 8 (int)
Object multiplicacao2 = i32_max * i32_1; // -2 (int)
Object multiplicacao3 = i32_1 * i64; // 4294967294 (long)

Object divisao1 = i32_2 / i32_1; // 2 (int)
Object divisao2 = i32_1 / i32_2; // 0 (int)
Object divisao3 = i16 / i32_1; // 0 (int)

// char converte tb
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>'use strict';

// só usa um único tipo numérico double
// não há o que converter

// números não sofrem overflow nem underflow,
// mas não dão aviso se você tentar passar
// dos limites

let i = Number.MAX_VALUE;
let j = Number.MAX_VALUE + 1; // não dá aviso
if (i === j) {
	console.log('j foi limitado');
}

i = -i
j = -j - 1; // não dá aviso
if (i === j) {
	console.log('j foi limitado');
}</code
>
</div>

</div>



<h3 id='conversoesnumericasfuncoes'>Argumentos</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>
</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>/*

{

// conversão explícita de int para byte 1
this.recebeByte((byte)1);

// conversão explícita 44
this.recebeByte((byte)300);

}

private void recebeByte(byte numero) {
	System.out.println("\nRecebe byte");
	System.out.println(numero);
}
*/
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// só usa um único tipo numérico double
// não há o que converter</code
>
</div>

</div>



<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='tiposchar'>Chars</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>
</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>// só usa strings
// não possui chars</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='tiposstring'>Strings</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>auto cString = "mãe d'água";
auto cStringEscape = "A primeira faz \"tchan\"";
auto rawString = R"(A segunda faz "tchun")";
auto html = R"(&lt;em class="especial"&gt;ênfase&lt;/em&gt;)";

auto meuSeparador = R"meuSeparador(aa)meuSeparador";
auto meuSeparador = R"meuSeparador( )" )meuSeparador"; // FIXME highlighter raw string

auto calvinHarris = "how deep\nis your love"; // 2 linhas

auto pareceMasNaoE = "começa e \
termina na mesma linha?"; // 1 linha apenas

// várias linhas
auto josePauloPaes = "Meu amor é simples, Dora,\n\
Como a água e o pão.\n\
\n\
Como o céu refletido\n\
Nas pupilas de um cão.";

// várias linhas
auto leminski = R"(Merda é veneno.
No entanto, não há nada
que seja mais bonito
que uma bela cagada.
Cagam ricos, cagam pobres,
cagam reis e cagam fadas.
Não há merda que se compare
à bosta da pessoa amada.)";

// concatenação
// TODO</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>let simples = "A primeira faz \"tchan\" e só"

let calvinHarris = "how deep\nis your love" // 2 linhas

// concatenação - única maneira de usar várias linhas
let josePauloPaes = "Meu amor é simples, Dora," +
"\nComo a água e o pão." +
"\n" +
"\nComo o céu refletido" +
"\nNas pupilas de um cão."</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// tipo &amp;str

let simples = "A primeira faz \"tchan\" e só";

let calvinHarris = "how deep\nis your love"; // 2 linhas

// várias linhas
let josePauloPaes = "Meu amor é simples, Dora,
Como a água e o pão.

Como o céu refletido
Nas pupilas de um cão.";

// concatenação
let leminski = concat!("Merda é veneno.",
	"No entanto, não há nada",
	"que seja mais bonito",
	"que uma bela cagada.",
	"Cagam ricos, cagam pobres,",
	"cagam reis e cagam fadas.",
	"Não há merda que se compare",
	"à bosta da pessoa amada."
);

// tipo String

let simples = "A primeira faz \"tchan\" e só".to_string();</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>var simples = "A primeira faz \"tchan\"";
var dupla = @"A segunda faz ""tchun""";
var interpolated = $"A segunda faz \"tchun\"";
</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>String simples = "A primeira faz \"tchan\" e só";

String calvinHarris = "how deep\nis your love"; // 2 linhas

// concatenação - única maneira de usar várias linhas
String josePauloPaes = "Meu amor é simples, Dora,\n" +
"Como a água e o pão.\n" +
"\n" +
"Como o céu refletido\n" +
"Nas pupilas de um cão.";

// concatenação
StringBuilder leminskiBuilder = new StringBuilder();
leminskiBuilder.append("Merda é veneno.");
leminskiBuilder.append("\nNo entanto, não há nada");
leminskiBuilder.append("\nque seja mais bonito");
leminskiBuilder.append("\nque uma bela cagada.");
leminskiBuilder.append("\nCagam ricos, cagam pobres,");
leminskiBuilder.append("\ncagam reis e cagam fadas.");
leminskiBuilder.append("\nNão há merda que se compare");
leminskiBuilder.append("\nà bosta da pessoa amada.");

String leminski = leminskiBuilder.toString();

// StringBuilder não é thread safe
// Existe também a classe StringBuffer, que é</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>'use strict';

let simples = 'A primeira faz "tchan"';
let dupla = "A segunda faz 'tchun'";
let duplaTemplate = `A primeira faz "tchan". A segunda faz 'tchun'`;

const iara = "mãe d'água";
const modoDificil = 'O\'Reilly';
let html = '<em class="especial">ênfase</em>';

let calvinHarris = 'how deep\nis your love'; // 2 linhas

let pareceMasNaoE = 'começa e \
termina na mesma linha?'; // 1 linha apenas

// várias linhas
let josePauloPaes = 'Meu amor é simples, Dora,\n\
Como a água e o pão.\n\
\n\
Como o céu refletido\n\
Nas pupilas de um cão.';

// várias linhas
let leminskiTemplate = `Merda é veneno.
No entanto, não há nada
que seja mais bonito
que uma bela cagada.
Cagam ricos, cagam pobres,
cagam reis e cagam fadas.
Não há merda que se compare
à bosta da pessoa amada.`;

let emoji = '😍';
let es5 = '\uD83D\uDE0D'; // code units / surrogates
let es6 = '\u{1F60D}'; // code point

// string é imutável, então seus métodos retornam novas instâncias
let beeGees = calvinHarris.replace('love', 'looove');

'Gritando'.toUpperCase(); // retorna 'GRITANDO'</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='tiposboolean'>Tipos Primitivos Boolean</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>auto oitoOuOitenta = true;
oitoOuOitenta = false;

// converte para true
oitoOuOitenta = !oitoOuOitenta;</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>var oitoOuOitenta = true;
oitoOuOitenta = false;

// converte para true
oitoOuOitenta = !oitoOuOitenta;
// TODO Boolean.Parse</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>boolean oitoOuOitenta = true;
oitoOuOitenta = false;

// converte para true
oitoOuOitenta = !oitoOuOitenta;
// TODO Boolean.parseBoolean</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>let oitoOuOitenta = true;
oitoOuOitenta = false;

// converte para true
oitoOuOitenta = !oitoOuOitenta;

// TODO falar de falsy e truthy e !!

/*
// falsy
var bZero = new Boolean(0);
var bNull = new Boolean(null);
var bEmptyString = new Boolean('');
var bfalse = new Boolean(false);
// undefined e NaN

// truthy
var btrueString = new Boolean('true');
var bfalseString = new Boolean('false');
var bSuLin = new Boolean('Su Lin');
var bArrayProto = new Boolean([]);
var bObjProto = new Boolean({});*/</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='excecoes'>Exceções</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>#include &lt;exception&gt;

using std::exception;

try {
	throw anyType;
	// ou simplesmente
	throw;
} catch(const exception&amp; ex) {
	//
} catch(...) {
	//
}

// NÃO COPIE!!! DEPRECATED!!!

// havia uma sintaxe para "checked exceptions"
int myfunction(int param) throw();
int myfunction(int param) throw(someType);</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>- (void)someMethod {
	@try {
		//
	} @catch (NSException *exception) {
		@throw exception; //  rethrows exception?
	} @finally {
		//
	}
}

// ou

someCFunction(); // TODO</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>enum MLError : ErrorType {
	case Bad
	case Worse
}

func canThrowErrors() throws -> String {
	throw MLError.Bad
}

func cannotThrowErrors() -> String {
	//
}

defer {
	//
}

// usar do-catch, try?, try! ou indicar throws</code
>
<!-- https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html -->
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>match may_panic() {
	Ok(result) => println!("{}", result),
	Err(err) => println!("Error: {}", err),
}

// ou

let result = try!(may_panic());</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>try {

	someObject.mayThrowException();

} catch (Exception ex) {

	// rethrows exception
	throw;

	// ou throw nova com InnerException
	// não devemos lançar System.Exception diretamente
	throw new ArgumentException("Novo erro", ex);

} finally {
	//
}</code
>
</div>

<div class='codeblock'>

<p>Java - Main.java</p>
<code class='java'
>package marcoluglio.exceptionexample;

public class Main {

	<strong>// Indicamos que não queremos cuidar da checked exception</strong>
	<strong class='small comment'>// neste ponto do código com "throws" e deixamos o erro</strong>
	<strong class='small comment'>// se propagar</strong>
	public static void main(String[] args) <strong class='small'>throws Exception</strong> {
		PodeOuNao problematico = new PodeOuNao();
		<strong>problematico.checkedMethod();</strong>
		problematico.uncheckedMethod();
	}

}</code
>

<p>Java - Main.java</p>
<code class='java'
>package marcoluglio.exceptionexample;

public class Main {

	public static void main(String[] args) {
		PodeOuNao problematico = new PodeOuNao();
		<strong>// Contemos a propagação da checked exception</strong>
		<strong class='small comment'>// com try catch</strong>
		<strong class='small'>try {</strong>
			<strong>problematico.checkedMethod();</strong>
		<strong class='small'>} catch(Exception ex) {</strong>
			//
		<strong>} finally {</strong>
			//
		<strong>}</strong>
		problematico.uncheckedMethod();
	}

}</code
>

<p>Java - PodeOuNao.java</p>
<code class='java'
>package marcoluglio.exceptionexample;

public final class PodeOuNao {

	// checked exceptions devem ser cercadas por
	// try catch ou o método deve indicar explicitamente
	// que pode lançá-las com "throws"
	public void checkedMethod() throws Exception {
		throw new Exception("pego na compilação!");
	}

	// unchecked expections não precisam de tais
	// cuidados
	public void uncheckedMethod() {
		throw new RuntimeException("pego na execução!");
	}

}</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>try {
	throw anyType;
	// mas geralmente
	throw new Error('Whoops!');
} catch (e if e instanceof Error) {
	//
} catch (ex) {
	throw ex; // rethrows
} finally {
	//
}

// TODO pode nested

try {
	// sem catch
} finally {
	//
}</code
>
<!-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch -->
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>


<section>

<h2 id='funcoes'>Funções</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>
</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>
</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>



<h3 id='funcoesinternas'>Funções Internas</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>
</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>
</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>



<h3 id='lambdas'>Lambdas</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>
</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>
</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>



<h3 id='funcoesvariadicas'>Funções Variádicas</h3>

<div class='comparison'>

<div class='codeblock'>

<p>C++</p>
<code class='cpp'
>// argumentos do mesmo tipo

#include &lt;iostream&gt;

using std::string;
using std::cout;
using std::endl;

template&lt;typename... Tipos&gt;
void imprimirSimples(string titulo, Tipos... paginas) {

	const uint16_t quantidadeDeParametros {sizeof...(paginas)};

	// não pode criar uma array com 0 elementos
	if (quantidadeDeParametros == 0) {
		return;
	}

	// expande os argumentos
	int paginasArray[quantidadeDeParametros] {paginas...};

	for (auto pagina : paginasArray) {
		cout &lt;&lt; "Imprimindo página " &lt;&lt; pagina &lt;&lt; endl;
	}

}

imprimirSimples(1, 2, 5);</code
>

<p>C++</p>
<code class='cpp'
>// argumentos de todos os tipos

#include &lt;iostream&gt;
#include &lt;boost/range/irange.hpp&gt;

using std::string;
using std::cout;
using std::endl;

/// imprimirHelper template genérico
template&lt;typename T&gt;
void imprimirHelper(T pagina) {
	// poderia usar a linha abaixo para descobrir o tipo de T
	// porém, melhor usar o template especializado
	// if (std::is_same&lt;T, int&gt;::value) { /* ... */ }
	cout &lt;&lt; "Imprimindo outra coisa" &lt;&lt; endl;
}

/// imprimirHelper template especializado para int
template&lt;&gt;
void imprimirHelper&lt;int&gt;(int pagina) {
	cout &lt;&lt; "Imprimindo página " &lt;&lt; pagina &lt;&lt; endl;
}

/// imprimirHelper template especializado para boost::irange
template&lt;&gt;
void imprimirHelper&lt;boost::irange&gt;(boost::irange faixa) {
	cout &lt;&lt; "Imprimindo página " &lt;&lt; std::begin(faixa) &lt;&lt; " até " &lt;&lt; std::end(faixa) &lt;&lt; endl;
}


// foward declaration imprimir template?? Não estou certo da função disso :/
void imprimir(string titulo) {}

// implementação imprimir template
template&lt;typename Tipo, typename... Tipos&gt;
void imprimir(string titulo, Tipo pagina, Tipos... paginas) {
	// executa o helper especializado e chama recursivamente a si mesmo
	imprimirHelper(pagina);
	imprimir(titulo, paginas...);
}

imprimir&lt;int, boost::irange, string&gt;("resumo", 1, boost::irange(2, 5), "capítulo 2");</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>// macros não seguras estilo C

#include &lt;iostream&gt;
#include &lt;cstdarg&gt;

void imprimirSimplesMacro(const std::string titulo, ...) {

	// va_list argumentos recebe o que vir depois do parâmetro titulo
	va_list argumentos;
	va_start(argumentos, titulo);

	int pagina;
	while (true) {
		pagina = va_arg(argumentos, int);
		if (pagina == -1) {
			break;
		}
		std::cout &lt;&lt; "Imprimindo " &lt;&lt; pagina &lt;&lt; std::endl;
	}

	va_end(argumentos);

}

// preciso sempre passar -1 no final como terminador
// se não dá overflow e lê pedaço de memória além do que deveria
imprimirSimplesMacro("resumo", 1, 2, 5, -1);</code
>
</div>

<div class='codeblock'>

<p>Swift</p>
<code class='swift'
>// argumentos do mesmo tipo

func imprimirSimples(titulo titulo:String, paginas:Int...) {
	for pagina in paginas {
		print("Imprimindo página \(pagina) num total de \(paginas.count)")
	}
}

imprimirSimples(titulo: "resumo", paginas: 1, 2, 5)</code
>

<p>Swift</p>
<code class='swift'
>// argumentos de todos os tipos

func imprimir(titulo titulo:String, paginas:Any...) {
	for valor in paginas {
		switch valor {
		case let pagina as Int:
			print("Imprimindo página \(pagina)")
		case let faixa as Range&lt;Int&gt;:
			print("Imprimindo páginas \(faixa.first!) até \(faixa.last!)")
		default:
			print("Imprimindo outra coisa")
		}
	}
}

imprimir(titulo: "resumo", paginas: 1, 2...5, "capítulo 2")</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
Até a versão 1.8 não possui
</div>

<div class='codeblock'>

<p>C#</p>
<code class='cs'
>// argumentos do mesmo tipo

void ImprimirSimples(string titulo, params int[] paginas) {
	foreach (int pagina in paginas) {
		System.Console.WriteLine(
			@"Imprimindo pagina {0} num total de {1}",
			pagina,
			paginas.Length
		);
	}
}

ImprimirSimples(@"resumo", 1, 2, 5);</code
>

<p>C#</p>
<code class='cs'
>// argumentos de todos os tipos

void Imprimir(string titulo, params object[] paginas) {
	foreach (object valor in paginas) {
		if (valor is int) {
			System.Console.WriteLine(@"Imprimindo página {0}", valor);
		} else if (valor is IEnumerable&lt;int&gt;) {
			System.Console.WriteLine(
				@"Imprimindo páginas {0} até {1}",
				(valor as IEnumerable&lt;int&gt;).First(),
				(valor as IEnumerable&lt;int&gt;).Last()
			);
		} else {
			System.Console.WriteLine(@"Imprimindo outra coisa");
		}
	}
}

Imprimir(@"resumo", 1, Enumerable.Range(2, 4), @"capítulo 2");</code
>
</div>

<div class='codeblock'>

<p>Java</p>
<code class='java'
>// argumentos do mesmo tipo

void imprimirSimples(String titulo, int... paginas) {
	for (int pagina : paginas) {
		System.out.println(String.format("Imprimindo página %1", pagina));
	}
}

imprimirSimples("resumo", 1, 2, 5);</code
>

<p>Java</p>
<code class='java'
>// argumentos de todos os tipos

void imprimir(String titulo, Object... paginas) {
	for (Object valor : paginas) {
		if (valor instanceof Integer) {
			System.out.println(String.format("Imprimindo página %d", valor));
		} else if (valor instanceof Range&lt;Integer&gt;) {
			System.out.println(String.format(
				"Imprimindo páginas %d até %d",
				((Range&lt;Integer&gt;)valor).getMinimum(),
				((Range&lt;Integer&gt;)valor).getMaximum()
			));
		} else {
			System.out.println("Imprimindo outra coisa");
		}
	}
}

imprimir("resumo", 1, Range.between(2, 5), "capítulo 2");</code
>
</div>

<div class='codeblock'>

<p>JavaScript</p>
<code class='javascript'
>'use strict';

// argumentos do mesmo tipo

function imprimirSimples(titulo, ...paginas) {
	for (let pagina of paginas) {
		console.log(`Imprimindo página ${pagina}`);
	}
}

imprimirSimples("resumo", 1, 2, 5);</code
>

<p>JavaScript</p>
<code class='javascript'
>'use strict';

// argumentos de todos os tipos

function imprimir(titulo, ...valores) {
	for (let valor of valores) {
		if (Number.isInteger(valor)) {
			console.log(`Imprimindo página ${valor}`);
		} else if ((valor.begin || valor.begin === 0)
			&amp;&amp; valor.end
			) {
			console.log(`Imprimindo páginas ${valor.begin} até ${valor.end}`);
		} else {
			console.log('Imprimindo outra coisa');
		}
	}
}

imprimir("resumo", 1, {begin: 2, end: 5}, "capítulo 2");</code
>
</div>

</div>



<h3 id='generators'>Generators</h3>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>
</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>
</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>



<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='async'>Async</h2>

<!-- tasks, promises e futures, deferreds, generators, events/delegates -->

<h3 id='threads'>Threads</h3>

<div class='comparison'>

<div class='codeblock'>

<p>C++ - main.cpp</p>
<code class='cpp'
>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;boost/algorithm/string.hpp&gt;
#include "cout_mutex.hpp" // para simplicidade do exemplo
#include "Model.hpp"
#include "ParallelWorker.hpp"
#include "parallelWorkerFunction.hpp"

int main(int argc, const char* argv[]) {

	using std::string;
	using std::cout;
	using std::endl;

	using std::make_unique;
	using std::thread;
	using std::ref;

	using MarcoLuglio::ThreadExample::Model;
	using MarcoLuglio::ThreadExample::ParallelWorker;
	using MarcoLuglio::ThreadExample::parallelWorkerFunction;

	// memória compartilhada entre as threads
	// como as threads não viverão mais que
	// a main thread, posso usar unique_ptr
	auto dataQueue = make_unique&lt;Model&gt;();
	dataQueue.Push("dislexicos");
	dataQueue.Push("devem");
	dataQueue.Push("ler");
	dataQueue.Push("frases");
	dataQueue.Push("assim");

	// alternativa 1: método
	auto worker{ParallelWorker(*dataQueue)};
	thread parallelThread{&amp;ParallelWorker::Work, worker};

	// alternativa 2: função
	thread functionThread{parallelWorkerFunction, ref(*dataQueue)};

	// alternativa 3: lambda
	thread lambdaThread{[](Model&amp; dataQueue){
		string element;
		auto sair = false;
		while (!sair) {
			element = dataQueue.Next();
			// deixa a thread terminar naturalmente
			if (element == "") {
				sair = true;
				continue;
			}
			boost::to_upper(element);
			cout_mutex.lock();
			cout &lt;&lt; element &lt;&lt; endl;
			cout_mutex.unlock();
		}
	}, ref(*dataQueue)};

	// espera as threads terminarem antes de prosseguir
	parallelThread.join();
	functionThread.join();
	lambdaThread.join();

}</code
>


	<div class='pair'>

		<div>

		<p>C++ - Model.hpp</p>
<code class='cpp'
>#pragma once

#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;

namespace MarcoLuglio {
namespace ThreadExample {

	using std::string;
	using std::queue;
	using std::mutex;

	// C++ possui classes nativas com acesso
	// sincronizado, mas não as utilizei para
	// demonstrar o uso de locks manuais
	class Model final {

	public:
		Model();
		~Model();
		void Push(string);
		string Next();

	private:

		queue&lt;string&gt; dataQueue;

		/// Lock simples explícita para sincronização
		mutex modelLock;

	};

}
}</code
>

		</div>

		<div>

<p>C++ - Model.cpp</p>
<code class='cpp'
>#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;
#include "Model.hpp"

namespace MarcoLuglio {
namespace ThreadExample {

	using std::string;
	using std::queue;
	using std::lock_guard;
	using std::mutex;

	Model::Model() {
		dataQueue = queue&lt;string&gt;();
	};

	Model::~Model() {
		//
	};

	void Model::Push(string) {
		// só a main thread insere, então
		// não precisa sincronizar
		dataQueue.push(element);
	};

	string Model::Next() {
		// sincroniza o acesso das threads
		lock_guard&lt;mutex&gt; _{modelLock};
		if (!dataQueue.empty()) {
			string element = dataQueue.front();
			dataQueue.pop();
			return element;
		}
		// string não pode ser nullptr em c++
		return "";
	};

}
}</code
>

		</div>

	</div>

	<div class='pair'>

		<div>

<p>C++ - ParallelWorker.hpp</p>
<code class='cpp'
>#pragma once

namespace MarcoLuglio {
namespace ThreadExample {

	class Model;

	class ParallelWorker final {

	public:
		explicit ParallelWorker(Model&amp; model);
		~ParallelWorker();
		void Work();

	private:
		Model* dataQueue;
		std::string element;

		/// Flag para término da thread
		bool sair;

	};

}
}</code
>

		</div>

		<div>

<p>C++ - ParallelWorker.cpp</p>
<code class='cpp'
>#include &lt;iostream&gt;
#include &lt;boost/algorithm/string.hpp&gt;
#include "cout_mutex.hpp" // para simplicidade do exemplo
#include "Model.hpp"
#include "ParallelWorker.hpp"

namespace MarcoLuglio {
namespace ThreadExample {

	using std::cout;
	using std::endl;

	ParallelWorker::ParallelWorker(Model&amp; model) {
		dataQueue = &amp;model;
		sair = false;
	};

	ParallelWorker::~ParallelWorker() {
		//
	};

	void ParallelWorker::Work() {
		while (!sair) {
			element = dataQueue->Next();
			// deixa a thread terminar naturalmente
			if (element == "") {
				sair = true;
				continue;
			}
			boost::to_upper(element);
			cout_mutex.lock();
			cout &lt;&lt; element &lt;&lt; endl;
			cout_mutex.unlock();
		}
	};

}
}</code
>

		</div>

	</div>

	<div class='pair'>

		<div>

<p>C++ - parallelWorkerFunction.hpp</p>
<code class='cpp'
>#pragma once

namespace MarcoLuglio {
namespace ThreadExample {

	class Model;

	void parallelWorkerFunction(Model&amp; dataQueue);

}
}</code
>

		</div>

		<div>

<p>C++ - parallelWorkerFunction.cpp</p>
<code class='cpp'
>#include &lt;iostream&gt;
#include &lt;boost/algorithm/string.hpp&gt;
#include "cout_mutex.hpp" // para simplicidade do exemplo
#include "Model.hpp"
#include "parallelWorkerFunction.hpp"

namespace MarcoLuglio {
namespace ThreadExample {

	using std::string;
	using std::cout;
	using std::endl;

	void parallelWorkerFunction(Model&amp; dataQueue) {
		string element;
		auto sair = false;
		while (!sair) {
			element = dataQueue.Next();
			// deixa a thread terminar naturalmente
			if (element == "") {
				sair = true;
				continue;
			}
			boost::to_upper(element);
			cout_mutex.lock();
			cout &lt;&lt; element &lt;&lt; endl;
			cout_mutex.unlock();
		}
	}

}
}</code
>

		</div>

	</div>

</div>

<div class='codeblock'>
<p>Objective-C</p>
<!--
http://www.cs.umd.edu/class/spring2010/cmsc498i/files/lectures/21_PerfConcurrency.pdf

https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html
https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html
https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html

https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man3/pthread.3.html
-->
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>

<p>Swift - Cocoa threads</p>
<code class='swift'>import Foundation

func join(thread:NSThread) {
	while !thread.finished { /**/ }
}

public final class NSParallelWorker {

	@objc public func work() {
		// deixa a thread terminar naturalmente
		while !self.sair {
			print("parallel worker")
			self.sair = true
		}
	}

	private var sair:Bool = false

}

// foundation thread com métodos
let nsParallelWorker = NSParallelWorker()
let selector = #selector(NSParallelWorker.work)
let nsThread:NSThread = NSThread.init(
	target: nsParallelWorker,
	selector: selector,
	object: nil
	)
nsThread.start()

// espera as threads terminarem antes de prosseguir
join(nsThread)</code
>

<p>Swift - POSIX threads</p>
<code class='swift'>//int threadError = pthread_create(
//	&amp;posixThreadID,
//	&amp;attr,
//	&amp;PosixThreadMainRoutine,
//	NULL
//	);

let pThread:pthread_t;
let pThreadAttr:pthread_attr_t;
pthread_attr_init(UnsafeMutablePointer&lt;pthread_attr_t&gt;(pThreadAttr))
let threadError = pthread_create(
	UnsafeMutablePointer&lt;pthread_t&gt;(pThread),
	UnsafePointer&lt;pthread_attr_t&gt;(pThreadAttr),
	{(UnsafeMutablePointer&lt;Void&gt;) -&gt; UnsafeMutablePointer&lt;Void&gt; in
		//code
	}, nil)
// let modelLock:pthread_mutex_t =
// pthread_join(
//	pThread,
//	UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Void&gt;&gt;
//	);</code
>
<!--
usar semáforos para controlar acesso à coleção
dispatch tasks para uma única queue
usar uma queue que não modifica a coleção até processar tudo


dispatch_group_t myGroup = dispatch_group_create();
dispatch_group_async(myGroup, dispatch_get_global_queue(), ^{
	//stuff to do in the background
});

//do some stuff

dispatch_group_wait(myGroup, DISPATCH_TIME_FOREVER);
dispatch_release(myGroup);

NSTask executa um novo processo
override NSOperation :(

-->

</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>// queue
use std::collections::vec_deque::VecDeque;

// threads
use std::thread;

// channels
use std::sync::mpsc::{Sender, Receiver};
use std::sync::mpsc;

fn uppercase(c:char) -> char {
	c.to_uppercase().next().unwrap()
}

fn main() {

	let mut model = VecDeque::new();
	model.push_back("dislexicos");
	model.push_back("devem");
	model.push_back("ler");
	model.push_back("frases");
	model.push_back("assim");

	let (senderChannel, receiverChannel)
		:(Sender&lt;&amp;str&gt;, Receiver&lt;&amp;str&gt;)
		= mpsc::channel();

	// envia dados pelo canal
	for element in model {
		senderChannel.send(element);
	}

	// fecha o canal
	drop(senderChannel);

	// alternativa 1: thread e lambda
	let mut lambdaElement = "lambda";
	let lambda_thread = thread::spawn(move || {

		let mut element:&amp;str;
		let mut elementUppercase:String;

		// roda até o canal ser fechado
		for element in receiverChannel {
			let uppercase:String = element
				.chars()
				.map(uppercase)
				.collect();
			println!("{:?}", uppercase);
		}

		// poderíamos usar receiverChannel.recv().unwrap()
		// e receiverChannel.try_recv().unwrap()

	});

	// alternativa 2: Builder e lambda
	let mut builderElement = "builder";
	let builder_thread = thread::Builder::new()
		.name("builder thread".to_string())
		.spawn(move || {

		let uppercase:String = builderElement
			.chars()
			.map(uppercase)
			.collect();
		println!("{:?}", uppercase);

	});

	// espera as threads terminarem antes de prosseguir
	lambda_thread.join();
	builder_thread.unwrap().join();

}</code
>
</div>

<div class='codeblock'>

<p>C# - MainClass.cs</p>
<code class='cs'
>using System;
using System.Threading;

namespace MarcoLuglio.ThreadExample {

	public class MainClass {

		public static void Main(string[] args) {

			// memória compartilhada entre as threads
			var dataQueue = new Model();
			dataQueue.Push("dislexicos");
			dataQueue.Push("devem");
			dataQueue.Push("ler");
			dataQueue.Push("frases");
			dataQueue.Push("assim");





			// alternativa 1: método
			var worker = new ParallelWorker(dataQueue);
			var parallelThread = new Thread(worker.Work);
			parallelThread.Start();


			// alternativa 2: lambda
			var lambdaThread = new Thread(() => {
				string element;
				var sair = false;
				while (!sair) {
					// dataQueue capturado pelo lambda
					element = dataQueue.Next();
					// deixa a thread terminar naturalmente
					if (element == null) {
						sair = true;
						continue;
					}
					Console.WriteLine(element.ToUpper());
				}
			});
			lambdaThread.Start();


			// espera as threads terminarem antes de prosseguir
			parallelThread.Join();
			lambdaThread.Join();

		}

	}

}



</code
>

<p>C# - Model.cs</p>
<code class='cs'
>using System.Collections.Generic;

namespace MarcoLuglio.ThreadExample {

	// C# possui classes nativas com acesso
	// sincronizado, mas não as utilizei para
	// demonstrar o uso de locks manuais
	public sealed class Model {

		public Model() {
			this.modelLock = new object();
			this.dataQueue = new Queue<string>();
		}

		public void Push(string element) {
			// só a main thread insere, então
			// não precisa sincronizar
			this.dataQueue.Enqueue(element);
		}

		public string Next() {
			// sincroniza o acesso das threads
			lock (this.modelLock) {
				if (this.dataQueue.Count == 0) {
					return null;
				}
				return this.dataQueue.Dequeue();
			}
		}

		private readonly Queue<string> dataQueue;

		/// &lt;summary&gt;
		/// Lock simples explícita para sincronização
		/// &lt;/summary&gt;
		private readonly object modelLock;

	}

}</code
>

<p>C# - ParallelWorker.cs</p>
<code class='cs'
>using System;

namespace MarcoLuglio.ThreadExample {

	public sealed class ParallelWorker {

		public ParallelWorker(Model dataQueue) {
			this.dataQueue = dataQueue;
		}

		// método "Main" da thread
		public void Work() {
			while (!this.sair) {
				this.element = this.dataQueue.Next();
				// deixa a thread terminar naturalmente
				if (this.element == null) {
					this.sair = true;
					continue;
				}
				Console.WriteLine(this.element.ToUpper());
			}
		}

		private Model dataQueue;
		private string element;

		/// &lt;summary&gt;
		/// Flag para término da thread
		/// &lt;/summary&gt;
		private bool sair = false;

	}

}</code
>

</div>

<div class='codeblock'>

<p>Java - Main.java</p>
<code class='java'
>


package marcoluglio.threadexample;

public class Main {

	public static void main(String[] args) {

		// memória compartilhada entre as threads
		Model dataQueue = new Model();
		dataQueue.push("dislexicos");
		dataQueue.push("devem");
		dataQueue.push("ler");
		dataQueue.push("frases");
		dataQueue.push("assim");

		// alternativa 1: subclasse de Thread
		ParallelThread parallelThread = new ParallelThread(dataQueue);
		parallelThread.start();

		// alternativa 2: interface Runnable
		Runnable parallelRunnable = new ParallelRunnable(dataQueue);
		Thread parallelRunnableThread = new Thread(parallelRunnable);
		parallelRunnableThread.start();

		// alternativa 3: lambda Runnable
		// ou interface funcional Runnable
		Runnable lambda = () -> {
			String element;
			boolean sair = false;
			while (!sair) {
				// dataQueue capturado pelo lambda
				element = dataQueue.next();
				// deixa a thread terminar naturalmente
				if (element == null) {
					sair = true;
					continue;
				}
				System.out.println(element.toUpperCase());
			}
		};
		Thread lambdaRunnable = new Thread(lambda);
		lambdaRunnable.start();

		// espera as threads terminarem antes de prosseguir
		try {
			parallelThread.join();
			parallelRunnable.join();
			lambdaRunnable.join();
		} catch (InterruptedException e) {
			// fazer alguma coisa
		}

	}

}</code
>

<p>Java - Model.java</p>
<code class='java'
>package marcoluglio.threadexample;

import java.util.LinkedList;

// Java possui classes nativas com acesso
// sincronizado, mas não as utilizei para
// demonstrar o uso de locks manuais
public final class Model {

	public Model() {
		this.modelLock = new Object();
		this.dataQueue = new LinkedList&lt;String&gt;();
	}

	public void push(String element) {
		// só a main thread insere, então
		// não precisa sincronizar
		this.dataQueue.add(element);
	}

	public String next() {
		// sincroniza o acesso das threads
		synchronized(this.modelLock) {
			return this.dataQueue.poll();
		}
	}

	private LinkedList&lt;String&gt; dataQueue;

	/** Lock simples explícita para sincronização */
	private final Object modelLock; // TODO testar o final

}







</code
>

<p>Java - ParallelThread.java</p>
<code class='java'
>

package marcoluglio.threadexample;

public final class ParallelThread extends Thread {

	public ParallelThread(Model dataQueue) {
		this.dataQueue = dataQueue;
	}

	// método "main" da thread
	@Override
	public void run() {
		while (!this.sair) {
			this.element = this.dataQueue.next();
			// deixa a thread terminar naturalmente
			if (this.element == null) {
				this.sair = true;
				continue;
			}
			System.out.println(this.element.toUpperCase());
		}
	}

	private Model dataQueue;
	private String element;

	/** Flag para término da thread */
	private boolean sair = false;

}</code
>

<p>Java - ParallelRunnable.java</p>
<code class='java'
>package marcoluglio.threadexample;

public final class ParallelRunnable implements Runnable {

	public ParallelRunnable(Model dataQueue) {
		this.dataQueue = dataQueue;
	}

	// método "main" da thread
	@Override
	public void run() {
		while (!this.sair) {
			this.element = this.dataQueue.next();
			// deixa a thread terminar naturalmente
			if (this.element == null) {
				this.sair = true;
				continue;
			}
			System.out.println(this.element.toUpperCase());
		}
	}

	private Model dataQueue;
	private String element;

	/** Flag para término da thread */
	private boolean sair = false;

}</code
>

</div>

<div class='codeblock'>

<p>JavaScript - main.js</p>
<code class='javascript'
>'use strict';

// cria a worker thread de uso exclusivo
// da main thread
let webWorker = new Worker('worker.js');

// web workers não compartilham memória
// apenas trocam mensagens entre si
// e não podem acessar o DOM

// envia mensagens para a worker thread
webWorker.postMessage(['algum', 'valor']);
webWorker.postMessage([10, 20]);

// callback para recepção de mensagens
// da worker thread
webWorker.onmessage = (event) => {
	console.log(event.data);
};

// mata a thread imediatamente se quiser
// webWorker.terminate();</code
>

<p>JavaScript - worker.js</p>
<code class='javascript'
>'use strict';

// callback para recepção de mensagens
// da main thread (ui thread)
onmessage = (event) => {

	console.log(event.data[0]);
	console.log(event.data[1]);
	let result = event.data.join(' ');

	// envia mensagens para a main thread
	postMessage(result);

	// termina a thread se quiser
	// close();

};</code
>

</div>

<div class='codeblock'>

<p>JavaScript - sharedThread1.js</p>
<code class='javascript'
>'use strict';

<strong>// cria uma worker thread compartilhada</strong>
let <strong class='small'>webWorkerOp1</strong> = new <strong class='small'>SharedWorker(</strong>'worker.js'<strong class='small'>);</strong>

// envia mensagens para a worker thread compartilhada
webWorkerOp1<strong>.port</strong>.postMessage(['algum', 'valor']);
webWorkerOp1<strong>.port</strong>.postMessage([10, 20]);

// callback para recepção de mensagens
// da worker thread
webWorkerOp1<strong>.port</strong>.onmessage = (event) => {
	console.log(event.data);
};</code
>

<p>JavaScript - sharedThread2.js</p>
<code class='javascript'
>'use strict';

// cria uma worker thread compartilhada
let <strong>webWorkerOp2</strong> = new <strong>SharedWorker(</strong>'worker.js'<strong>);</strong>

// envia mensagens para a worker thread compartilhada
webWorkerOp2<strong>.port</strong>.postMessage(['misturar', 2]);
webWorkerOp2<strong>.port</strong>.postMessage([10, 20]);

// callback para recepção de mensagens
// da worker thread
webWorkerOp2<strong>.port</strong>.onmessage = (event) => {
	console.log(event.data);
};</code
>

<p>JavaScript - worker.js</p>
<code class='javascript'
>'use strict';

<strong>onconnect = (event) => {</strong>

	<strong>let port = event.ports[0];</strong>

	// callback para recepção de mensagens
	// da main thread (ui thread)
	<strong>port.</strong>onmessage = (event) => {

		console.log(event.data[0]);
		console.log(event.data[1]);
		let result = event.data.join(' ');

		// envia mensagens para a main thread
		<strong>port.</strong>postMessage(result);

		// termina a thread se quiser
		// close();

	};

<strong>};</strong></code
>

</div>

</div>



<h3 id='tasks'>Tasks</h2>

<div class='comparison'>

<div class='codeblock'>

<p>C++ - main.cpp</p>
<code class='cpp'
>#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;boost/algorithm/string.hpp&gt;

#include "taskFunction.hpp"

int main(int argc, const char* argv[]) {

	using std::async;
	using std::string;
	using std::cout;
	using std::endl;

	using MarcoLuglio::TaskExample::taskFunction;

	// alternativa 1: método
	// TODO

	// alternativa 2: função
	auto functionFuture = async(taskFunction, "função");

	// alternativa 3: lambda
	auto lambdaFuture = async([](string element) -> string {
		boost::to_upper(element);
		return element;
	}, "lambda");


	// espera os Futures calcularem um valor
	// concreto antes de prosseguir
	cout &lt;&lt; functionFuture.get() &lt;&lt; endl;
	cout &lt;&lt; lambdaFuture.get() &lt;&lt; endl;

	return 0;

}</code
>

	<div class='pair'>

		<div>

<p>C++ - taskFunction.hpp</p>
<code class='cpp'
>#pragma once

#include &lt;string&gt;

namespace MarcoLuglio {
namespace TaskExample {

	using std::string;

	string taskFunction(string element);

}
}</code
>

		</div>

		<div>

<p>C++ - taskFunction.cpp</p>
<code class='cpp'
>#include &lt;boost/algorithm/string.hpp&gt;
#include "taskFunction.hpp"


namespace MarcoLuglio {
namespace TaskExample {

	using std::string;

	string taskFunction(string element) {
		boost::to_upper(element);
		return element;
	}

}
}</code
>

		</div>

	</div>

</div>

<div class='codeblock'>
<p>Objective-C</p>
-
</div>

<div class='codeblock'>

<p>Swift - Console</p>
<code class='swift'
>// libdispatch ou Grande Central Dispatch
import Dispatch

// funções auxiliares para simplificar sincronização

func check(semaforo:dispatch_semaphore_t) -&gt; Int {
	let waitResult = dispatch_semaphore_wait(
		semaforo,
		dispatch_time(DISPATCH_TIME_NOW, 1_000_000_000)
		)
	return waitResult
}

func wait(semaforo:dispatch_semaphore_t) {
	while check(semaforo) != 0 { /**/ }
}

// tasks

var element = "lambda"

let utilityQueue = dispatch_get_global_queue(
	QOS_CLASS_UTILITY,
	0
	)
let semaforo = dispatch_semaphore_create(0)

dispatch_async(utilityQueue) {
	element = element.uppercaseString
	print(element)
	dispatch_semaphore_signal(semaforo)
}

// espera os blocos terminarem antes de prosseguir
wait(semaforo)

/*
Os tipos pré-definidos de queues são:
QOS_CLASS_USER_INTERACTIVE - if it should not cause the ui to lag or hang
QOS_CLASS_USER_INITIATED - if is started by ui interaction such as a click
QOS_CLASS_UTILITY - if it is a slow operation such as io
QOS_CLASS_BACKGROUND - background tasks
*/</code
>

<p>Swift - UI</p>
<code class='swift'>// libdispatch ou Grande Central Dispatch
import Dispatch

// funções auxiliares para simplificar sincronização

func check(semaforo:dispatch_semaphore_t) -&gt; Int {
	let waitResult = dispatch_semaphore_wait(
		semaforo,
		dispatch_time(DISPATCH_TIME_NOW, 1_000_000_000)
		)
	return waitResult
}

func wait(semaforo:dispatch_semaphore_t) {
	while check(semaforo) != 0 { /**/ }
}

// tasks

var element = "lambda"

let utilityQueue = dispatch_get_global_queue(
	QOS_CLASS_UTILITY,
	0
	)
let semaforo = dispatch_semaphore_create(0)

dispatch_async(utilityQueue) {
	element = element.uppercaseString
	let mainQueue = dispatch_get_main_queue()
	dispatch_async(mainQueue) {
		print(element)
		dispatch_semaphore_signal(semaforo)
	}
}

// espera os blocos terminarem antes de prosseguir
wait(semaforo)</code
>

</div>

<div class='codeblock'>
<p>Rust</p>
-
</div>

<div class='codeblock'>

<p>C# - MainClass.cs</p>
<code class='cs'
>using System;

namespace MarcoLuglio.TaskExample {

	class MainClass {

		public static void Main(string[] args) {
			// async não pode ser usado no método
			// main, então chamamos no objeto
			var mainObject = new MainClass();
			mainObject.main();
		}

		private async void main() {
			var promise = new Promise(@"some value");
			var resultado = await promise.GetResultAsync();
			Console.WriteLine(@"esperou " + resultado);
		}

	}

}</code
>

<p>C# - Promise.cs</p>
<code class='cs'
>using System.Threading.Tasks;

namespace MarcoLuglio.TaskExample {

	public class Promise {

		public Promise(string element) {
			this.element = element;
		}

		public async Task&lt;string&gt; GetResultAsync() {
			return this.element.ToUpper();
		}

		string element;

	}

}</code
>

</div>

<div class='codeblock'>

<p>Java - Main.java</p>
<code class='java'
>package marcoluglio.taskexample;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;

public class Main {

	public static void main(String[] args) {

		// gerencia threads
		ExecutorService executor = Executors.newFixedThreadPool(2);

		// alternativa 1: interface Callable
		Task callableTask = new Task("async");
		Future&lt;String&gt; taskFuture = executor.submit(callableTask);

		// alternativa 2: lambda Callable
		String element = "lambda";
		Future&lt;String&gt; lambdaFuture = executor.submit(() -> {
			return element.toUpperCase();
		});

		// alternativa 3: Threads e Futures manuais sem executor
		Task manualTask = new Task("manual");
		FutureTask&lt;String&gt; manualFuture = new FutureTask&lt;String&gt;(manualTask);
		new Thread(manualFuture).start();

		try {

			// espera os Futures calcularem um valor
			// concreto antes de prosseguir
			System.out.println(taskFuture.get());
			System.out.println(lambdaFuture.get());
			System.out.println(manualFuture.get());

			// encerra as threads do executor
			executor.shutdown();

		} catch (InterruptedException e) {
			// fazer alguma coisa
		} catch (ExecutionException e) {
			// fazer alguma coisa
		}

	}

}</code
>

<p>Java - Task.java</p>
<code class='java'
>package marcoluglio.taskexample;

import java.util.concurrent.Callable;

public class Task implements Callable&lt;String&gt; {

	public Task(String element) {
		this.element = element;
	}

	@Override
	public String call() throws Exception {
		return this.element.toUpperCase();
	}

	String element;

}</code
>

</div>

<div class='codeblock'>

<p>Java Android - AsyncTask.java</p>
<code class='java'
>// TODO AsyncTask</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>function workAsync(element) {
	return new Promise((resolve, reject) => {
		resolve(element.toUpperCase());
	});
}

workAsync('some value')
	.then((result) => {
		console.log(result);
	});</code
>
</div>

</div>



<ol>
	<li>C#</li>
	<li>C++</li>
	<li>JavaScript</li>
	<li>Java</li>
</ol>

<p>A</p>

</section>



<section>

<h2 id='templateid'>Template</h2>

<div class='comparison'>

<div class='codeblock'>
<p>C++</p>
<code class='cpp'
>
</code
>
</div>

<div class='codeblock'>
<p>Objective-C</p>
<code class='objectivec'
>
</code
>
</div>

<div class='codeblock'>
<p>Swift</p>
<code class='swift'
>
</code
>
</div>

<div class='codeblock'>
<p>Rust</p>
<code class='rust'
>
</code
>
</div>

<div class='codeblock'>
<p>C#</p>
<code class='cs'
>
</code
>
</div>

<div class='codeblock'>
<p>Java</p>
<code class='java'
>
</code
>
</div>

<div class='codeblock'>
<p>JavaScript</p>
<code class='javascript'
>
</code
>
</div>

</div>

<ol>
	<li>a</li>
</ol>

<p>A</p>

</section>



</body>
</html>