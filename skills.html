<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<!-- Formatação da página -->
	<link href='css/principal.css' rel='stylesheet' type='text/css' media='screen, projection, tv' />
</head>
<body>
	<svg id='chart' width="800" height="600" version="1.1" xmlns="http://www.w3.org/2000/svg">

		<style>
			text {
				font: normal 16px Oswald;
			}
		</style>

		<defs>
			<linearGradient id="darkBlueGradientRight" gradientUnits="userSpaceOnUse" x1="0" y1="180" x2="60" y2="300">
				<stop offset="0" style="stop-color:#004CD6"/>
				<stop offset="1" style="stop-color:#00266B"/>
			</linearGradient>
			<linearGradient id="darkBlueGradientLeft" gradientUnits="userSpaceOnUse" x1="60" y1="162.68" x2="0" y2="282.68">
				<stop offset="0" style="stop-color:#004CD6"/>
				<stop offset="1" style="stop-color:#00266B"/>
			</linearGradient>
			<linearGradient id="lightBlueGradientRight" gradientUnits="userSpaceOnUse" x1="0" y1="180" x2="60" y2="300">
				<stop offset="0" style="stop-color:#448BC9"/>
				<stop offset="1" style="stop-color:#1A5589"/>
			</linearGradient>
			<linearGradient id="lightBlueGradientLeft" gradientUnits="userSpaceOnUse" x1="60" y1="162.68" x2="0" y2="282.68">
				<stop offset="0" style="stop-color:#448BC9"/>
				<stop offset="1" style="stop-color:#1A5589"/>
			</linearGradient>
			<linearGradient id="grayGradientRight" gradientUnits="userSpaceOnUse" x1="0" y1="180" x2="60" y2="300">
				<stop offset="0" style="stop-color:#A9B4C4"/>
				<stop offset="1" style="stop-color:#838C99"/>
			</linearGradient>
			<linearGradient id="grayGradientLeft" gradientUnits="userSpaceOnUse" x1="60" y1="162.68" x2="0" y2="282.68">
				<stop offset="0" style="stop-color:#A9B4C4"/>
				<stop offset="1" style="stop-color:#838C99"/>
			</linearGradient>
			<linearGradient id="magentaGradientRight" gradientUnits="userSpaceOnUse" x1="0" y1="180" x2="60" y2="300">
				<stop offset="0.3748" style="stop-color:#E72E88"/>
				<stop offset="1" style="stop-color:#94275C"/>
			</linearGradient>
			<linearGradient id="magentaGradientLeft" gradientUnits="userSpaceOnUse" x1="60" y1="162.68" x2="0" y2="282.68">
				<stop offset="0.3748" style="stop-color:#E72E88"/>
				<stop offset="1" style="stop-color:#94275C"/>
			</linearGradient>
			<linearGradient id="wineGradientRight" gradientUnits="userSpaceOnUse" x1="0" y1="180" x2="60" y2="300">
				<stop offset="0.3748" style="stop-color:#731744"/>
				<stop offset="1" style="stop-color:#280A19"/>
			</linearGradient>
			<linearGradient id="wineGradientLeft" gradientUnits="userSpaceOnUse" x1="60" y1="162.68" x2="0" y2="282.68">
				<stop offset="0.3748" style="stop-color:#731744"/>
				<stop offset="1" style="stop-color:#280A19"/>
			</linearGradient>
			<linearGradient id="limeGradientRight" gradientUnits="userSpaceOnUse" x1="0" y1="180" x2="60" y2="300">
				<stop offset="0" style="stop-color:#8AD100"/>
				<stop offset="1" style="stop-color:#5E8F00"/>
			</linearGradient>
			<linearGradient id="limeGradientLeft" gradientUnits="userSpaceOnUse" x1="60" y1="162.68" x2="0" y2="282.68">
				<stop offset="0" style="stop-color:#8AD100"/>
				<stop offset="1" style="stop-color:#5E8F00"/>
			</linearGradient>
		</defs>

		<!--
		<g id='darkBlueChart'>
			<g></g>
			<polygon class='leftFace' points='' />
			<polygon class='rightFace' points='' fill="url('#darkBlueGradientRight')" />
		</g>
		-->
		<g id='lightBlueChart' transform="translate(60 30)">
			<polygon class='leftFace' points='' fill="url('#lightBlueGradientLeft')" />
			<polygon class='rightFace' points='' fill="url('#lightBlueGradientRight')" />
		</g>
		<g id='grayChart' transform="translate(160 80)">
			<polygon class='leftFace' points='' fill="url('#grayGradientLeft')" />
			<polygon class='rightFace' points='' fill="url('#grayGradientRight')" />
		</g>
		<g id='magentaChart' transform="translate(260 130)">
			<polygon class='leftFace' points='' fill="url('#magentaGradientLeft')" />
			<polygon class='rightFace' points='' fill="url('#magentaGradientRight')" />
		</g>
		<g id='wineChart' transform="translate(360 180)">
			<polygon class='leftFace' points='' fill="url('#wineGradientLeft')" />
			<polygon class='rightFace' points='' fill="url('#wineGradientRight')" />
		</g>
		<g id='limeChart'>
			<polygon class='leftFace' points='' fill="url('#limeGradientLeft')" />
			<polygon class='rightFace' points='' fill="url('#limeGradientRight')" />
		</g>

		<!--isometric transform-->
		<!-- Math.cos(30 * Math.PI / 180) = 0.8660254037844387 -->

	</svg>
	<script>
		(() => {

			'use strict';

			const skills = [
				{
					name: 'core',
					svgId: 'lightBlueChart',
					labelColor: '#448BC9',
					topCapColor: '#519AD4',
					list: [
						{ name: 'infra as code', score: 5 },
						{ name: 'i18n', score: 5 },
						{ name: 'metrics', score: 6 },
						{ name: 'devops', score: 7 },
						{ name: 'oauth', score: 7 },
						{ name: 'azure/aws', score: 7 },
						{ name: 'ux', score: 8 },
						{ name: 'bdd/tdd', score: 8 },
						{ name: 'ddd', score: 8 },
						{ name: 'git', score: 9 },
						{ name: 'architecture', score: 9 },
						{ name: 'design patterns', score: 10 },
						{ name: 'test automation', score: 10 },
						{ name: 'agile', score: 10 }
					]
				},
				{
					name: 'front-end',
					svgId: 'grayChart',
					labelColor: '#788598',
					topCapColor: '#A9B7C9',
					list: [
						{ name: 'speech', score: 2 },
						{ name: 'sockets', score: 4 },
						{ name: 'web assembly', score: 5 },
						{ name: 'swift', score: 5 },
						{ name: 'pwa', score: 5 },
						{ name: 'react/redux', score: 6 },
						{ name: 'angular/ngrx', score: 7 },
						{ name: 'maps', score: 7 },
						{ name: 'e2e tests', score: 7 },
						{ name: 'webforms/mvc', score: 8 },
						{ name: 'css/responsive', score: 10 },
						{ name: 'js/ts', score: 10 },
					]
				},
				{
					name: 'back-end',
					svgId: 'magentaChart',
					labelColor: '#E72E88',
					topCapColor: '#FF54A6',
					list: [
						{ name: 'machine learning', score: 4 },
						{ name: 'c++/rust', score: 4 },
						{ name: 'go', score: 5 },
						{ name: 'containers', score: 5 },
						{ name: 'serverless', score: 6 },
						{ name: 'tests', score: 7 },
						{ name: 'wcf/soap', score: 7 },
						{ name: 'graphql', score: 7 },
						{ name: 'grpc', score: 7 },
						{ name: 'microservices', score: 8 },
						{ name: 'swagger/raml', score: 8 },
						{ name: 'rest', score: 9 },
						{ name: 'c#', score: 10 },
					]
				},
				{
					name: 'storage',
					svgId: 'wineChart',
					labelColor: '#731744',
					topCapColor: '#A32161',
					list: [
						{ name: 'kafka', score: 5 },
						{ name: 'mongodb', score: 6 },
						{ name: 'indexeddb', score: 6 },
						{ name: 'cosmosdb', score: 7 },
						{ name: 'dapper', score: 7 },
						{ name: 'entity fw', score: 8 },
						{ name: 't-sql', score: 9 }
					],
				}
			];

			const chartsWidth = 300;
			const chartsHeight = 10;
			const chartThickness = 25;
			const degrees30 = 30 * Math.PI / 180;
			const sin30 = Math.sin(degrees30);
			const cos30 = Math.cos(degrees30);
			const labelMarginH = 10;
			const labelOffsetY = 18;

			const charts = document.querySelector('#chart');
			const svgNamespace = 'http://www.w3.org/2000/svg';

			function plotChart(skillGroup) {

				const points = [];
				let tempList = skillGroup.list;
				const numberOfPoints = 1 + tempList.length;
				let i = 1;

				points.push({
					x: 0,
					y: 300
				});

				for (const skill of tempList) {

					const segment = chartsWidth * i;

					points.push({
						x: segment * cos30 / numberOfPoints,
						y: 300 - (segment * sin30 / numberOfPoints) - (chartsHeight * skill.score)
					});

					i++;
				}

				points.push({
					x: chartsWidth * cos30,
					y: 300 - (chartsWidth * sin30)
				});

				// TODO

				// para o right
				// acrescentar primeira ponta com offset após primeira
				// offset nos pontos intermediários
				// acrescentar última ponta com offset antes da última primeira

				// para left
				// acrescentar as pontas com offset
				// acrescentar primeira ponta com offset após primeira
				// acrescentar pontos intermediários com offset em qual order?
				// acrescentar última ponta com offset antes da última primeira

				const chart = document.querySelector(`#${skillGroup.svgId}`);
				const leftFace = chart.querySelector('.leftFace');
				const rightFace = chart.querySelector('.rightFace');

				let skillText = document.createElementNS(svgNamespace, 'g');
				let previousPoint = points[0];

				let leftSvgPoint = charts.createSVGPoint();
				leftSvgPoint.x = points[0].x;
				leftSvgPoint.y = points[0].y;
				leftFace.points.appendItem(leftSvgPoint);


				i = 0;

				for (const point of points) {

					leftSvgPoint = charts.createSVGPoint();
					leftSvgPoint.x = point.x - (chartThickness * cos30);
					leftSvgPoint.y = point.y - (chartThickness * sin30);
					leftFace.points.appendItem(leftSvgPoint);

					let rightSvgPoint = charts.createSVGPoint();
					rightSvgPoint.x = point.x;
					rightSvgPoint.y = point.y;
					rightFace.points.appendItem(rightSvgPoint);

					if (previousPoint != point && i > 1 && i < points.length - 1) {

						let topCap = document.createElementNS(svgNamespace, 'polygon');

						let topCapPoint = charts.createSVGPoint();
						topCapPoint.x = previousPoint.x;
						topCapPoint.y = previousPoint.y;
						topCap.points.appendItem(topCapPoint);

						topCapPoint = charts.createSVGPoint();
						topCapPoint.x = previousPoint.x - (chartThickness * cos30);
						topCapPoint.y = previousPoint.y - (chartThickness * sin30);
						topCap.points.appendItem(topCapPoint);

						topCapPoint = charts.createSVGPoint();
						topCapPoint.x = point.x - (chartThickness * cos30);
						topCapPoint.y = point.y - (chartThickness * sin30);
						topCap.points.appendItem(topCapPoint);

						topCapPoint = charts.createSVGPoint();
						topCapPoint.x = point.x;
						topCapPoint.y = point.y;
						topCap.points.appendItem(topCapPoint);

						// TODO calcular cor dos caps baseado na inclinação...
						topCap.setAttribute('fill', skillGroup.topCapColor);

						chart.appendChild(topCap);

					}

					previousPoint = point;
					i++;

				}

				i = 1;
				const lastChild = chart.childNodes.length;

				for (const point of points) {

					// there are two extra points, one at the start, and another at the end
					// hence we get the skill at i - 1
					if (!skillGroup.list[i-1]) {
						continue;
					}

					let skillTextLabel = document.createElementNS(svgNamespace, 'text');
					skillTextLabel.setAttribute('x', 40); // default layout, will be calculated later to fit the text
					skillTextLabel.setAttribute('y', 15);
					skillTextLabel.setAttribute('dominant-baseline', 'middle');
					skillTextLabel.setAttribute('text-anchor', 'middle');
					skillTextLabel.setAttribute('fill', 'white');
					let skillTextLabelNode = document.createTextNode(skillGroup.list[i-1].name);
					skillTextLabel.appendChild(skillTextLabelNode);

					let skillTextRect = document.createElementNS(svgNamespace, 'rect');

					// default layout, will be calculated later to fit the text
					skillTextRect.setAttribute('x', 0);
					skillTextRect.setAttribute('y', 0);
					skillTextRect.setAttribute('width', 80);
					skillTextRect.setAttribute('height', 28);

					skillTextRect.setAttribute('fill', skillGroup.labelColor);

					skillText.appendChild(skillTextRect);
					skillText.appendChild(skillTextLabel);
					chart.insertBefore(skillText, chart.childNodes[lastChild]);

					// measure is only possible after the element has been added to the document
					let skillTextBoundingBox = skillTextLabel.getBBox();
					let skillTextWidth = skillTextBoundingBox.width;
					let skillTextRectWidth = skillTextWidth + labelMarginH;
					let skillTextRectCenterX = skillTextRectWidth / 2;
					//let skillTextHeight = skillTextBoundingBox.height;
					skillTextRect.setAttribute('width', skillTextRectWidth);
					skillTextLabel.setAttribute('x', skillTextRectCenterX);

					let skillTextOffsetX = points[i].x - (chartThickness * cos30 / 2) - (skillTextRectCenterX * cos30);
					let skillTextOffsetY = points[i].y - (chartThickness * sin30 / 2) - 28 - (skillTextRectCenterX * sin30) - labelOffsetY;
					skillText.setAttribute('transform', `translate(${skillTextOffsetX} ${skillTextOffsetY}) skewY(30) scale(0.8660 1)`); // TODO calculate translation

					skillText = document.createElementNS(svgNamespace, 'g');
					i++;

				}

				leftSvgPoint = charts.createSVGPoint();
				leftSvgPoint.x = points[points.length - 1].x;
				leftSvgPoint.y = points[points.length - 1].y;
				leftFace.points.appendItem(leftSvgPoint);

			}

			for (let skillGroup of skills) {
				plotChart(skillGroup);
			}

		})();
	</script>
</body>
</html>